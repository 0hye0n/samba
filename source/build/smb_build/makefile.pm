###########################################################
### SMB Build System					###
### - create output for Makefile			###
###							###
###  Copyright (C) Stefan (metze) Metzmacher 2004	###
###  Copyright (C) Jelmer Vernooij 2005			###
###  Released under the GNU GPL				###
###########################################################

package smb_build::makefile;
use smb_build::env;
use strict;

use base 'smb_build::env';

sub new($$$$)
{
	my ($myname, $config, $CTX, $mkfile) = @_;
	my $self = new smb_build::env($config);
	
	bless($self, $myname);

	$self->{output} = "";

	$self->output("################################################\n");
	$self->output("# Autogenerated by build/smb_build/makefile.pm #\n");
	$self->output("################################################\n");
	$self->output("\n");

	$self->output("default: all\n\n");

	$self->_prepare_path_vars();
	$self->_prepare_compiler_linker();
	$self->_prepare_SUFFIXES();
	$self->_prepare_hostcc_rule();
	$self->_prepare_depend_CC_rule();
	$self->_prepare_std_CC_rule("c","o",'$(PICFLAG)',"Compiling","Rule for std objectfiles");
	$self->_prepare_std_CC_rule("h","h.gch",'$(PICFLAG)',"Precompiling","Rule for precompiled headerfiles");

	$self->_prepare_man_rule("1");
	$self->_prepare_man_rule("3");
	$self->_prepare_man_rule("5");
	$self->_prepare_man_rule("7");
	
	$self->_prepare_config_status();

	$self->_prepare_dummy_MAKEDIR($CTX);
	$self->_prepare_manpages($CTX);
	$self->_prepare_binaries($CTX);
	$self->_prepare_libraries($CTX);
	$self->_prepare_headers($CTX);
	$self->_prepare_target_settings($CTX);
	$self->_prepare_rule_lists($CTX);
	$self->_prepare_clean_rules();

	if ($self->{developer}) {
		$self->output(<<__EOD__
#-include \$(_ALL_OBJS_OBJS:.o=.d)
IDL_FILES = \$(wildcard librpc/idl/*.idl)
\$(patsubst librpc/idl/%.idl,librpc/gen_ndr/ndr_%.c,\$(IDL_FILES)) \\
\$(patsubst librpc/idl/%.idl,librpc/gen_ndr/ndr_\%_c.c,\$(IDL_FILES)) \\
\$(patsubst librpc/idl/%.idl,librpc/gen_ndr/ndr_%.h,\$(IDL_FILES)): idl
__EOD__
);
	}

	$self->output($mkfile);

	return $self;
}

sub output($$)
{
	my ($self, $text) = @_;

	$self->{output} .= $text;
}

sub _prepare_path_vars($)
{
	my ($self) = @_;

	$self->output(<< "__EOD__"
prefix = $self->{config}->{prefix}
exec_prefix = $self->{config}->{exec_prefix}
selftest_prefix = $self->{config}->{selftest_prefix}
VPATH = $self->{config}->{srcdir}
srcdir = $self->{config}->{srcdir}
builddir = $self->{config}->{builddir}

BASEDIR = $self->{config}->{prefix}
BINDIR = $self->{config}->{bindir}
SBINDIR = $self->{config}->{sbindir}
datadir = $self->{config}->{datadir}
LIBDIR = $self->{config}->{libdir}
INCLUDEDIR = $self->{config}->{includedir}
CONFIGDIR = $self->{config}->{configdir}
localstatedir = $self->{config}->{localstatedir}
SWATDIR = $self->{config}->{swatdir}
VARDIR = $self->{config}->{localstatedir}
LOGFILEBASE = $self->{config}->{logfilebase}
NCALRPCDIR = $self->{config}->{localstatedir}/ncalrpc
LOCKDIR = $self->{config}->{lockdir}
PIDDIR = $self->{config}->{piddir}
MANDIR = $self->{config}->{mandir}
PRIVATEDIR = $self->{config}->{privatedir}

__EOD__
);
	$self->output(<< '__EOD__'

# The permissions to give the executables
INSTALLPERMS = 0755

# set these to where to find various files
# These can be overridden by command line switches (see smbd(8))
# or in smb.conf (see smb.conf(5))
CONFIGFILE = $(CONFIGDIR)/smb.conf
LMHOSTSFILE = $(CONFIGDIR)/lmhosts

PATH_FLAGS = -DCONFIGFILE=\"$(CONFIGFILE)\"  -DSBINDIR=\"$(SBINDIR)\" \
	 -DBINDIR=\"$(BINDIR)\" -DLMHOSTSFILE=\"$(LMHOSTSFILE)\" \
	 -DLOCKDIR=\"$(LOCKDIR)\" -DPIDDIR=\"$(PIDDIR)\" -DLIBDIR=\"$(LIBDIR)\" \
	 -DLOGFILEBASE=\"$(LOGFILEBASE)\" -DSHLIBEXT=\"$(SHLIBEXT)\" \
	 -DCONFIGDIR=\"$(CONFIGDIR)\" -DNCALRPCDIR=\"$(NCALRPCDIR)\" \
	 -DSWATDIR=\"$(SWATDIR)\" -DPRIVATE_DIR=\"$(PRIVATEDIR)\"
__EOD__
);
}

sub _prepare_compiler_linker($)
{
	my ($self) = @_;

	$self->output(<< "__EOD__"
SHELL=$self->{config}->{SHELL}

PERL=$self->{config}->{PERL}

CC=$self->{config}->{CC}
CFLAGS=-I\$(srcdir)/include -I\$(srcdir) -I\$(srcdir)/lib -D_SAMBA_BUILD_ -DHAVE_CONFIG_H $self->{config}->{CFLAGS} $self->{config}->{CPPFLAGS}
PICFLAG=$self->{config}->{PICFLAG}
HOSTCC=$self->{config}->{HOSTCC}

CPP=$self->{config}->{CPP}
CPPFLAGS=$self->{config}->{CPPFLAGS}

LD=$self->{config}->{LD}
LD_FLAGS=$self->{config}->{LDFLAGS} 

STLD=$self->{config}->{AR}
STLD_FLAGS=-rc

SHLD=$self->{config}->{CC}
SHLD_FLAGS=$self->{config}->{LDSHFLAGS}
SONAMEFLAG=$self->{config}->{SONAMEFLAG}
SHLIBEXT=$self->{config}->{SHLIBEXT}

XSLTPROC=$self->{config}->{XSLTPROC}

LEX=$self->{config}->{LEX}
YACC=$self->{config}->{YACC}
YAPP=$self->{config}->{YAPP}
PIDL_ARGS=$self->{config}->{PIDL_ARGS}

GCOV=$self->{config}->{GCOV}

DEFAULT_TEST_TARGET=$self->{config}->{DEFAULT_TEST_TARGET}

__EOD__
);
}

sub _prepare_SUFFIXES($)
{
	my $self = shift;
	$self->output(<< '__EOD__'
.SUFFIXES: .x .c .et .y .l .d .o .h .h.gch .a .so .1 .1.xml .3 .3.xml .5 .5.xml .7 .7.xml .ho

__EOD__
);
}

sub _prepare_man_rule($$)
{
	my ($self, $suffix) = @_;

	$self->output(<< "__EOD__"
.$suffix.xml.$suffix:
	\$(XSLTPROC) -o \$@ http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl \$<

__EOD__
);
}

sub _prepare_config_status($)
{
	my $self = shift;
	my @parsed_files = @smb_build::config_mk::parsed_files;
	my $deps = "";
	
	foreach (@parsed_files) {
		/^([^ |]+)/;
		$deps.= " $1";
	}

	$self->output("

Makefile: config.status $deps
	./config.status

");
}

sub _prepare_headers($$)
{
	my ($self, $ctx) = @_;

	my @headers = ();
	
	foreach (values %$ctx) {
		next unless defined $_->{PUBLIC_HEADERS};

		foreach my $h (@{$_->{PUBLIC_HEADERS}}) {
			push (@headers, "$_->{BASEDIR}/$h");
		}
	}
	
	$self->output("PUBLIC_HEADERS = " . array2oneperline(\@headers) . "\n");
}

sub _prepare_libraries($$)
{
	my ($self, $ctx) = @_;

	my @shared_list = ();
	my @static_list = ();

	foreach (values %$ctx) {
		next unless defined $_->{OUTPUT_TYPE};
		next unless defined($_->{INSTALLDIR});
		next unless ($_->{INSTALLDIR} eq "LIBDIR");

		push(@shared_list, $_->{OUTPUT}) if ($_->{OUTPUT_TYPE} eq "SHARED_LIBRARY");
		push(@static_list, $_->{OUTPUT}) if ($_->{OUTPUT_TYPE} eq "STATIC_LIBRARY");
	}

	$self->output("STATIC_LIBS = " . array2oneperline(\@static_list) . "\n");
	$self->output("SHARED_LIBS = " . array2oneperline(\@shared_list) . "\n");

}

sub _prepare_binaries($$)
{
	my ($self, $ctx) = @_;

	my @bbn_list = ();
	my @sbn_list = ();

	foreach (values %$ctx) {
		next unless defined $_->{OUTPUT_TYPE};
		next unless ($_->{OUTPUT_TYPE} eq "BINARY");

		next unless defined($_->{INSTALLDIR});

		push(@sbn_list, $_->{OUTPUT}) if ($_->{INSTALLDIR} eq "SBINDIR");
		push(@bbn_list, $_->{OUTPUT}) if ($_->{INSTALLDIR} eq "BINDIR");
	}

	$self->output("BIN_PROGS = " . array2oneperline(\@bbn_list) . "\n");
	$self->output("SBIN_PROGS = " . array2oneperline(\@sbn_list) . "\n");
}

sub _prepare_manpages($$)
{
	my ($self, $ctx) = @_;

	my @mp_list = ();

	foreach (values %$ctx) {
		my $dir = $_->{BASEDIR};
		next unless defined($dir);
		$dir =~ s/^\.\///g;
		push (@mp_list, "$dir/$_->{MANPAGE}") if (defined($_->{MANPAGE}) and $_->{MANPAGE} ne "");
	}
	
	my $mp = array2oneperline(\@mp_list);
	$self->output("MANPAGES = $mp\n");
}

sub _prepare_dummy_MAKEDIR($$)
{
	my ($self,$ctx) = @_;

	$self->output(<< '__EOD__'
bin/.dummy:
	@: >> $@ || : > $@

dynconfig.o: dynconfig.c Makefile
	@echo Compiling $*.c
	@$(CC) $(CFLAGS) $(PICFLAG) $(PATH_FLAGS) -c $< -o $@
__EOD__
);
	if ($self->{config}->{BROKEN_CC} eq "yes") {
		$self->output('	-mv `echo $@ | sed \'s%^.*/%%g\'` $@
');
	}
	$self->output("\n");
}

sub _prepare_depend_CC_rule($)
{
	my $self = shift;
	$self->output(<< '__EOD__'

.c.d:
	@echo "Generating dependencies for $<"
	@$(CC) -MM -MG -MT $(<:.c=.o) -MF $@ $(CFLAGS) $<

__EOD__
);
}

###########################################################
# This function creates a standard make rule which is using $(CC)
#
# $output = _prepare_std_CC_rule($srcext,$destext,$flags,$message,$comment)
#
# $srcext -	sourcefile extension
#
# $destext -	destinationfile extension
#
# $flags -	additional compiler flags
#
# $message -	logmessage which is echoed while running this rule
#
# $comment -	just a comment what this rule should do
#
# $output -		the resulting output buffer
sub _prepare_std_CC_rule($$$$$$)
{
	my ($self,$src,$dst,$flags,$message,$comment) = @_;

	$self->output(<< "__EOD__"
# $comment
.$src.$dst:
	\@echo $message \$\*.$src
	\@\$(CC) `script/cflags.sh \$\@` \$(CFLAGS) $flags -c \$< -o \$\@
__EOD__
);
	if ($self->{config}->{BROKEN_CC} eq "yes") {
		$self->output('	-mv `echo $@ | sed \'s%^.*/%%g\'` $@
');
	}

	$self->output("\n");
}

sub _prepare_hostcc_rule($)
{
	my ($self) = @_;
	
	$self->output(<< "__EOD__"
.c.ho:
	\@echo Compiling \$\*.c with host compiler
	\@\$(HOSTCC) `script/cflags.sh \$\@` \$(CFLAGS) -c \$< -o \$\@
__EOD__
);
	if ($self->{config}->{BROKEN_CC} eq "yes") {
		$self->output('	-mv `echo $@ | sed \'s%^.*/%%g\' -e \'s%\.ho$$%.o%\'` $@
');
	}

	$self->output("\n");
}



sub array2oneperline($)
{
	my $array = shift;
	my $output = "";

	foreach (@$array) {
		next unless defined($_);

		$output .= " \\\n\t\t$_";
	}

	return $output;
}

###########################################################
# This function creates a object file list
#
# $output = _prepare_var_obj_list($var, $var_ctx)
#
# $var_ctx -		the subsystem context
#
# $var_ctx->{NAME} 	-	the <var> name
# $var_ctx->{OBJ_LIST} 	-	the list of objectfiles which sould be linked to this <var>
#
# $output -		the resulting output buffer
sub _prepare_obj_list($$)
{
	my ($var,$ctx) = @_;

	my $tmplist = array2oneperline($ctx->{OBJ_LIST});
	return "" if ($tmplist eq "");

	return "$var\_$ctx->{NAME}_OBJS =$tmplist\n";
}

sub _prepare_cflags($$)
{
	my ($var,$ctx) = @_;

	my $tmplist = array2oneperline($ctx->{CFLAGS});
	return "" if ($tmplist eq "");

	return "$var\_$ctx->{NAME}_CFLAGS =$tmplist\n";
}

###########################################################
# This function creates a make rule for linking a library
#
# $output = _prepare_shared_library_rule($library_ctx)
#
# $library_ctx -		the library context
#
# $library_ctx->{NAME} -		the library name
#
# $library_ctx->{DEPEND_LIST} -		the list of rules on which this library depends
#
# $library_ctx->{LIBRARY_NAME} -	the shared library name
# $library_ctx->{LIBRARY_REALNAME} -	the shared library real name
# $library_ctx->{LIBRARY_SONAME} - the shared library soname
# $library_ctx->{LINK_LIST} -	the list of objectfiles and external libraries
#					which sould be linked to this shared library
# $library_ctx->{LINK_FLAGS} -	linker flags used by this shared library
#
# $output -		the resulting output buffer
sub _prepare_shared_library_rule($$)
{
	my ($self,$ctx) = @_;

	my $tmpdepend = array2oneperline($ctx->{DEPEND_LIST});
	my $tmpshlink = array2oneperline($ctx->{LINK_LIST});
	my $tmpshflag = array2oneperline($ctx->{LINK_FLAGS});

	$self->output(<< "__EOD__"
LIBRARY_$ctx->{NAME}_DEPEND_LIST =$tmpdepend
LIBRARY_$ctx->{NAME}_SHARED_LINK_LIST =$tmpshlink
LIBRARY_$ctx->{NAME}_SHARED_LINK_FLAGS =$tmpshflag
#

$ctx->{TARGET}: \$(LIBRARY_$ctx->{NAME}_DEPEND_LIST) \$(LIBRARY_$ctx->{NAME}_OBJS) bin/.dummy
	\@echo Linking \$\@
	\@\$(SHLD) \$(SHLD_FLAGS) -o \$\@ \\
		\$(LIBRARY_$ctx->{NAME}_SHARED_LINK_FLAGS) \\
		\$(LIBRARY_$ctx->{NAME}_SHARED_LINK_LIST)

__EOD__
);
	if (defined($ctx->{LIBRARY_SONAME})) {
	    $self->output(<< "__EOD__"
# Symlink $ctx->{LIBRARY_SONAME}
bin/$ctx->{LIBRARY_SONAME}: bin/$ctx->{LIBRARY_REALNAME} bin/.dummy
	\@echo Symlink \$\@
	\@ln -sf $ctx->{LIBRARY_REALNAME} \$\@
# Symlink $ctx->{LIBRARY_NAME}
bin/$ctx->{LIBRARY_NAME}: bin/$ctx->{LIBRARY_SONAME} bin/.dummy
	\@echo Symlink \$\@
	\@ln -sf $ctx->{LIBRARY_SONAME} \$\@

__EOD__
);
	}

	$self->output("library_$ctx->{NAME}: basics bin/lib$ctx->{LIBRARY_NAME}\n");
}

sub _prepare_mergedobj_rule($$)
{
	my ($self,$ctx) = @_;

	return "" unless $ctx->{TARGET};

	my $tmpdepend = array2oneperline($ctx->{DEPEND_LIST});

	$self->output("$ctx->{TYPE}_$ctx->{NAME}_DEPEND_LIST = $tmpdepend\n");

	$self->output("$ctx->{TARGET}: \$($ctx->{TYPE}_$ctx->{NAME}_OBJS)\n");

	$self->output("\t\@echo \"Pre-Linking $ctx->{TYPE} $ctx->{NAME}\"\n");
	$self->output("\t@\$(LD) -r \$($ctx->{TYPE}_$ctx->{NAME}_OBJS) -o $ctx->{TARGET}\n");
	$self->output("\n");
}

sub _prepare_objlist_rule($$)
{
	my ($self,$ctx) = @_;
	my $tmpdepend = array2oneperline($ctx->{DEPEND_LIST});

	return "" unless $ctx->{TARGET};

	$self->output("$ctx->{TYPE}_$ctx->{NAME}_DEPEND_LIST = $tmpdepend\n");
	$self->output("$ctx->{TARGET}: ");
	$self->output("\$($ctx->{TYPE}_$ctx->{NAME}_DEPEND_LIST) \$($ctx->{TYPE}_$ctx->{NAME}_OBJS)\n");
	$self->output("\t\@touch $ctx->{TARGET}\n");
}

###########################################################
# This function creates a make rule for linking a library
#
# $output = _prepare_static_library_rule($library_ctx)
#
# $library_ctx -		the library context
#
# $library_ctx->{NAME} -		the library name
#
# $library_ctx->{DEPEND_LIST} -		the list of rules on which this library depends
#
# $library_ctx->{LIBRARY_NAME} -	the static library name
# $library_ctx->{LINK_LIST} -	the list of objectfiles	which sould be linked
#					to this static library
# $library_ctx->{LINK_FLAGS} -	linker flags used by this static library
#
# $output -		the resulting output buffer
sub _prepare_static_library_rule($$)
{
	my ($self,$ctx) = @_;

	my $tmpdepend = array2oneperline($ctx->{DEPEND_LIST});
	my $tmpstlink = array2oneperline($ctx->{LINK_LIST});
	my $tmpstflag = array2oneperline($ctx->{LINK_FLAGS});

	$self->output(<< "__EOD__"
LIBRARY_$ctx->{NAME}_DEPEND_LIST =$tmpdepend
#
LIBRARY_$ctx->{NAME}_STATIC_LINK_LIST =$tmpstlink
#
$ctx->{TARGET}: \$(LIBRARY_$ctx->{NAME}_DEPEND_LIST) \$(LIBRARY_$ctx->{NAME}_OBJS) bin/.dummy
	\@echo Linking \$@
	\@\$(STLD) \$(STLD_FLAGS) \$@ \\
		\$(LIBRARY_$ctx->{NAME}_STATIC_LINK_LIST)

library_$ctx->{NAME}: basics $ctx->{TARGET}

__EOD__
);
}

###########################################################
# This function creates a make rule for linking a binary
#
# $output = _prepare_binary_rule($binary_ctx)
#
# $binary_ctx -		the binary context
#
# $binary_ctx->{NAME} -		the binary name
# $binary_ctx->{BINARY} -	the binary binary name
#
# $binary_ctx->{DEPEND_LIST} -	the list of rules on which this binary depends
# $binary_ctx->{LINK_LIST} -	the list of objectfiles and external libraries
#				which sould be linked to this binary
# $binary_ctx->{LINK_FLAGS} -	linker flags used by this binary
#
# $output -		the resulting output buffer
sub _prepare_binary_rule($$)
{
	my ($self,$ctx) = @_;

	my $tmpdepend = array2oneperline($ctx->{DEPEND_LIST});
	my $tmplink = array2oneperline($ctx->{LINK_LIST});
	my $tmpflag = array2oneperline($ctx->{LINK_FLAGS});

	$self->output(<< "__EOD__"
#
BINARY_$ctx->{NAME}_DEPEND_LIST =$tmpdepend
BINARY_$ctx->{NAME}_LINK_LIST =$tmplink
BINARY_$ctx->{NAME}_LINK_FLAGS =$tmpflag
#
bin/$ctx->{BINARY}: bin/.dummy \$(BINARY_$ctx->{NAME}_DEPEND_LIST) \$(BINARY_$ctx->{NAME}_OBJS)
	\@echo Linking \$\@
	\@\$(CC) \$(LD_FLAGS) -o \$\@ \\
		\$\(BINARY_$ctx->{NAME}_LINK_FLAGS) \\
		\$\(BINARY_$ctx->{NAME}_LINK_LIST) \\
		\$\(BINARY_$ctx->{NAME}_LINK_FLAGS)
binary_$ctx->{BINARY}: basics bin/$ctx->{BINARY}

__EOD__
);
}

sub _prepare_clean_rules($)
{
	my ($self) = @_;
	$self->output(<< '__EOD__'
clean: heimdal_clean
	@echo Removing headers
	@-rm -f include/proto.h
	@echo Removing objects
	@-find . -name '*.o' -exec rm -f '{}' \;
	@echo Removing binaries
	@-rm -f $(BIN_PROGS) $(SBIN_PROGS)
	@echo Removing dummy targets
	@-rm -f bin/.*_*
	@echo Removing generated files
	@-rm -rf librpc/gen_* 
	@-rm -f lib/registry/regf.h lib/registry/tdr_regf*

distclean: clean
	-rm -f bin/.dummy
	-rm -f include/config.h include/smb_build.h
	-rm -f Makefile 
	-rm -f config.status
	-rm -f config.log config.cache
	-rm -f samba4-deps.dot
	-rm -f config.pm config.mk
	-rm -f lib/registry/winregistry.pc
__EOD__
);
	if ($self->{developer}) {
		$self->output("\t\@-rm -f \$(_ALL_OBJS_OBJS:.o=.d)\n");
	}

	$self->output(<< '__EOD__'

removebackup:
	-rm -f *.bak *~ */*.bak */*~ */*/*.bak */*/*~ */*/*/*.bak */*/*/*~

realdistclean: distclean removebackup
	-rm -f include/config.h.in
	-rm -f include/version.h
	-rm -f configure
	-rm -f $(MANPAGES)
__EOD__
);
}

sub _prepare_make_target($)
{
	my $ctx = shift;
	my $tmpdepend;

	$tmpdepend = array2oneperline($ctx->{DEPEND_LIST});

	return "$ctx->{TARGET}: basics $tmpdepend\n";
}

sub _prepare_target_settings($$)
{
	my ($self, $CTX) = @_;

	foreach my $key (values %$CTX) {
		if (defined($key->{OBJ_LIST})) {
			$self->output(_prepare_obj_list($key->{TYPE}, $key));
			$self->output(_prepare_cflags($key->{TYPE}, $key));
		}
	}
}

sub _prepare_rule_lists($$)
{
	my ($self,$depend) = @_;

	foreach my $key (values %{$depend}) {
		next unless defined $key->{OUTPUT_TYPE};

		$self->_prepare_mergedobj_rule($key) if $key->{OUTPUT_TYPE} eq "MERGEDOBJ";
		$self->_prepare_objlist_rule($key) if $key->{OUTPUT_TYPE} eq "OBJLIST";
		$self->_prepare_static_library_rule($key) if $key->{OUTPUT_TYPE} eq "STATIC_LIBRARY";
		$self->_prepare_shared_library_rule($key) if $key->{OUTPUT_TYPE} eq "SHARED_LIBRARY";
		$self->_prepare_binary_rule($key) if $key->{OUTPUT_TYPE} eq "BINARY";
	}
}

###########################################################
# This function creates Makefile from the OUTPUT 
# context
#
# create_makefile($OUTPUT)
#
# $OUTPUT	-	the global OUTPUT context
#
# $output -		the resulting output buffer
sub write($$)
{
	my ($self,$file) = @_;

	open(MAKEFILE,">$file") || die ("Can't open $file\n");
	print MAKEFILE $self->{output};
	close(MAKEFILE);

	print "build/smb_build/main.pl: creating $file\n";
	return;	
}

1;
