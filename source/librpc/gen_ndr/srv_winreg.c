/*
 * Unix SMB/CIFS implementation.
 * server auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "librpc/gen_ndr/srv_winreg.h"

static BOOL api_winreg_OpenHKCR(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_OpenHKCR r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_OpenHKCR");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_OpenHKCR(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.handle = talloc_size(mem_ctx, sizeof(*r.out.handle));
	if (r.out.handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_OpenHKCR(p, r.in.system_name, r.in.access_mask, r.out.handle);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_OpenHKCR(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_OpenHKCU(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_OpenHKCU r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_OpenHKCU");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_OpenHKCU(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.handle = talloc_size(mem_ctx, sizeof(*r.out.handle));
	if (r.out.handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_OpenHKCU(p, r.in.system_name, r.in.access_mask, r.out.handle);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_OpenHKCU(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_OpenHKLM(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_OpenHKLM r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_OpenHKLM");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_OpenHKLM(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.handle = talloc_size(mem_ctx, sizeof(*r.out.handle));
	if (r.out.handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_OpenHKLM(p, r.in.system_name, r.in.access_mask, r.out.handle);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_OpenHKLM(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_OpenHKPD(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_OpenHKPD r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_OpenHKPD");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_OpenHKPD(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.handle = talloc_size(mem_ctx, sizeof(*r.out.handle));
	if (r.out.handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_OpenHKPD(p, r.in.system_name, r.in.access_mask, r.out.handle);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_OpenHKPD(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_OpenHKU(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_OpenHKU r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_OpenHKU");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_OpenHKU(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.handle = talloc_size(mem_ctx, sizeof(*r.out.handle));
	if (r.out.handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_OpenHKU(p, r.in.system_name, r.in.access_mask, r.out.handle);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_OpenHKU(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_CloseKey(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_CloseKey r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_CloseKey");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_CloseKey(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.handle = r.in.handle;
	r.out.result = _winreg_CloseKey(p, r.in.handle);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_CloseKey(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_CreateKey(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_CreateKey r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_CreateKey");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_CreateKey(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.new_handle = talloc_size(mem_ctx, sizeof(*r.out.new_handle));
	if (r.out.new_handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.action_taken = r.in.action_taken;
	r.out.result = _winreg_CreateKey(p, r.in.handle, r.in.name, r.in.keyclass, r.in.options, r.in.access_mask, r.in.secdesc, r.out.new_handle, r.in.action_taken);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_CreateKey(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_DeleteKey(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_DeleteKey r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_DeleteKey");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_DeleteKey(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_DeleteKey(p, r.in.handle, r.in.key);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_DeleteKey(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_DeleteValue(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_DeleteValue r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_DeleteValue");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_DeleteValue(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_DeleteValue(p, r.in.handle, r.in.value);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_DeleteValue(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_EnumKey(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_EnumKey r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_EnumKey");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_EnumKey(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.name = r.in.name;
	r.out.keyclass = r.in.keyclass;
	r.out.last_changed_time = r.in.last_changed_time;
	r.out.result = _winreg_EnumKey(p, r.in.handle, r.in.enum_index, r.in.name, r.in.keyclass, r.in.last_changed_time);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_EnumKey(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_EnumValue(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_EnumValue r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_EnumValue");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_EnumValue(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.name = r.in.name;
	r.out.type = r.in.type;
	r.out.value = r.in.value;
	r.out.size = r.in.size;
	r.out.length = r.in.length;
	r.out.result = _winreg_EnumValue(p, r.in.handle, r.in.enum_index, r.in.name, r.in.type, r.in.value, r.in.size, r.in.length);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_EnumValue(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_FlushKey(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_FlushKey r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_FlushKey");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_FlushKey(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_FlushKey(p, r.in.handle);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_FlushKey(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_GetKeySecurity(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_GetKeySecurity r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_GetKeySecurity");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_GetKeySecurity(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.sd = r.in.sd;
	r.out.result = _winreg_GetKeySecurity(p, r.in.handle, r.in.sec_info, r.in.sd);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_GetKeySecurity(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_LoadKey(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_LoadKey r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_LoadKey");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_LoadKey(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_LoadKey(p, r.in.handle, r.in.keyname, r.in.filename);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_LoadKey(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_NotifyChangeKeyValue(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_NotifyChangeKeyValue r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_NotifyChangeKeyValue");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_NotifyChangeKeyValue(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_NotifyChangeKeyValue(p, r.in.handle, r.in.watch_subtree, r.in.notify_filter, r.in.unknown, r.in.string1, r.in.string2, r.in.unknown2);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_NotifyChangeKeyValue(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_OpenKey(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_OpenKey r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_OpenKey");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_OpenKey(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.handle = talloc_size(mem_ctx, sizeof(*r.out.handle));
	if (r.out.handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_OpenKey(p, r.in.parent_handle, r.in.keyname, r.in.unknown, r.in.access_mask, r.out.handle);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_OpenKey(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_QueryInfoKey(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_QueryInfoKey r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_QueryInfoKey");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_QueryInfoKey(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.class_out = talloc_size(mem_ctx, sizeof(*r.out.class_out));
	if (r.out.class_out == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.num_subkeys = talloc_size(mem_ctx, sizeof(*r.out.num_subkeys));
	if (r.out.num_subkeys == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.max_subkeylen = talloc_size(mem_ctx, sizeof(*r.out.max_subkeylen));
	if (r.out.max_subkeylen == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.max_subkeysize = talloc_size(mem_ctx, sizeof(*r.out.max_subkeysize));
	if (r.out.max_subkeysize == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.num_values = talloc_size(mem_ctx, sizeof(*r.out.num_values));
	if (r.out.num_values == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.max_valnamelen = talloc_size(mem_ctx, sizeof(*r.out.max_valnamelen));
	if (r.out.max_valnamelen == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.max_valbufsize = talloc_size(mem_ctx, sizeof(*r.out.max_valbufsize));
	if (r.out.max_valbufsize == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.secdescsize = talloc_size(mem_ctx, sizeof(*r.out.secdescsize));
	if (r.out.secdescsize == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.last_changed_time = talloc_size(mem_ctx, sizeof(*r.out.last_changed_time));
	if (r.out.last_changed_time == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_QueryInfoKey(p, r.in.handle, r.in.class_in, r.out.class_out, r.out.num_subkeys, r.out.max_subkeylen, r.out.max_subkeysize, r.out.num_values, r.out.max_valnamelen, r.out.max_valbufsize, r.out.secdescsize, r.out.last_changed_time);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_QueryInfoKey(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_QueryValue(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_QueryValue r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_QueryValue");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_QueryValue(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.type = r.in.type;
	r.out.data = r.in.data;
	r.out.size = r.in.size;
	r.out.length = r.in.length;
	r.out.result = _winreg_QueryValue(p, r.in.handle, r.in.value_name, r.in.type, r.in.data, r.in.size, r.in.length);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_QueryValue(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_ReplaceKey(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_ReplaceKey r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_ReplaceKey");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_ReplaceKey(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_ReplaceKey(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_ReplaceKey(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_RestoreKey(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_RestoreKey r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_RestoreKey");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_RestoreKey(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_RestoreKey(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_RestoreKey(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_SaveKey(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_SaveKey r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_SaveKey");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_SaveKey(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_SaveKey(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_SaveKey(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_SetKeySecurity(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_SetKeySecurity r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_SetKeySecurity");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_SetKeySecurity(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.sd = r.in.sd;
	r.out.result = _winreg_SetKeySecurity(p, r.in.handle, r.in.access_mask, r.in.sd);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_SetKeySecurity(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_SetValue(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_SetValue r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_SetValue");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_SetValue(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_SetValue(p, r.in.handle, r.in.name, r.in.type, r.in.data, r.in.size);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_SetValue(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_UnLoadKey(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_UnLoadKey r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_UnLoadKey");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_UnLoadKey(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_UnLoadKey(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_UnLoadKey(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_InitiateSystemShutdown(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_InitiateSystemShutdown r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_InitiateSystemShutdown");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_InitiateSystemShutdown(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_InitiateSystemShutdown(p, r.in.hostname, r.in.message, r.in.timeout, r.in.force_apps, r.in.reboot);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_InitiateSystemShutdown(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_AbortSystemShutdown(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_AbortSystemShutdown r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_AbortSystemShutdown");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_AbortSystemShutdown(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_AbortSystemShutdown(p, r.in.server);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_AbortSystemShutdown(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_GetVersion(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_GetVersion r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_GetVersion");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_GetVersion(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.version = talloc_size(mem_ctx, sizeof(*r.out.version));
	if (r.out.version == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_GetVersion(p, r.in.handle, r.out.version);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_GetVersion(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_OpenHKCC(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_OpenHKCC r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_OpenHKCC");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_OpenHKCC(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.handle = talloc_size(mem_ctx, sizeof(*r.out.handle));
	if (r.out.handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_OpenHKCC(p, r.in.system_name, r.in.access_mask, r.out.handle);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_OpenHKCC(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_OpenHKDD(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_OpenHKDD r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_OpenHKDD");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_OpenHKDD(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.handle = talloc_size(mem_ctx, sizeof(*r.out.handle));
	if (r.out.handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_OpenHKDD(p, r.in.system_name, r.in.access_mask, r.out.handle);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_OpenHKDD(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_QueryMultipleValues(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_QueryMultipleValues r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_QueryMultipleValues");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_QueryMultipleValues(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.values = r.in.values;
	r.out.buffer = r.in.buffer;
	r.out.buffer_size = r.in.buffer_size;
	r.out.result = _winreg_QueryMultipleValues(p, r.in.key_handle, r.in.values, r.in.num_values, r.in.buffer, r.in.buffer_size);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_QueryMultipleValues(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_InitiateSystemShutdownEx(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_InitiateSystemShutdownEx r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_InitiateSystemShutdownEx");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_InitiateSystemShutdownEx(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_InitiateSystemShutdownEx(p, r.in.hostname, r.in.message, r.in.timeout, r.in.force_apps, r.in.reboot, r.in.reason);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_InitiateSystemShutdownEx(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_SaveKeyEx(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_SaveKeyEx r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_SaveKeyEx");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_SaveKeyEx(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_SaveKeyEx(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_SaveKeyEx(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_OpenHKPT(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_OpenHKPT r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_OpenHKPT");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_OpenHKPT(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.handle = talloc_size(mem_ctx, sizeof(*r.out.handle));
	if (r.out.handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_OpenHKPT(p, r.in.system_name, r.in.access_mask, r.out.handle);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_OpenHKPT(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_OpenHKPN(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_OpenHKPN r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_OpenHKPN");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_OpenHKPN(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.handle = talloc_size(mem_ctx, sizeof(*r.out.handle));
	if (r.out.handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_OpenHKPN(p, r.in.system_name, r.in.access_mask, r.out.handle);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_OpenHKPN(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_winreg_QueryMultipleValues2(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct winreg_QueryMultipleValues2 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_winreg_QueryMultipleValues2");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_winreg_QueryMultipleValues2(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _winreg_QueryMultipleValues2(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_winreg_QueryMultipleValues2(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}


/* Tables */
static struct api_struct api_winreg_cmds[] = 
{
	{"WINREG_OPENHKCR", DCERPC_WINREG_OPENHKCR, api_winreg_OpenHKCR},
	{"WINREG_OPENHKCU", DCERPC_WINREG_OPENHKCU, api_winreg_OpenHKCU},
	{"WINREG_OPENHKLM", DCERPC_WINREG_OPENHKLM, api_winreg_OpenHKLM},
	{"WINREG_OPENHKPD", DCERPC_WINREG_OPENHKPD, api_winreg_OpenHKPD},
	{"WINREG_OPENHKU", DCERPC_WINREG_OPENHKU, api_winreg_OpenHKU},
	{"WINREG_CLOSEKEY", DCERPC_WINREG_CLOSEKEY, api_winreg_CloseKey},
	{"WINREG_CREATEKEY", DCERPC_WINREG_CREATEKEY, api_winreg_CreateKey},
	{"WINREG_DELETEKEY", DCERPC_WINREG_DELETEKEY, api_winreg_DeleteKey},
	{"WINREG_DELETEVALUE", DCERPC_WINREG_DELETEVALUE, api_winreg_DeleteValue},
	{"WINREG_ENUMKEY", DCERPC_WINREG_ENUMKEY, api_winreg_EnumKey},
	{"WINREG_ENUMVALUE", DCERPC_WINREG_ENUMVALUE, api_winreg_EnumValue},
	{"WINREG_FLUSHKEY", DCERPC_WINREG_FLUSHKEY, api_winreg_FlushKey},
	{"WINREG_GETKEYSECURITY", DCERPC_WINREG_GETKEYSECURITY, api_winreg_GetKeySecurity},
	{"WINREG_LOADKEY", DCERPC_WINREG_LOADKEY, api_winreg_LoadKey},
	{"WINREG_NOTIFYCHANGEKEYVALUE", DCERPC_WINREG_NOTIFYCHANGEKEYVALUE, api_winreg_NotifyChangeKeyValue},
	{"WINREG_OPENKEY", DCERPC_WINREG_OPENKEY, api_winreg_OpenKey},
	{"WINREG_QUERYINFOKEY", DCERPC_WINREG_QUERYINFOKEY, api_winreg_QueryInfoKey},
	{"WINREG_QUERYVALUE", DCERPC_WINREG_QUERYVALUE, api_winreg_QueryValue},
	{"WINREG_REPLACEKEY", DCERPC_WINREG_REPLACEKEY, api_winreg_ReplaceKey},
	{"WINREG_RESTOREKEY", DCERPC_WINREG_RESTOREKEY, api_winreg_RestoreKey},
	{"WINREG_SAVEKEY", DCERPC_WINREG_SAVEKEY, api_winreg_SaveKey},
	{"WINREG_SETKEYSECURITY", DCERPC_WINREG_SETKEYSECURITY, api_winreg_SetKeySecurity},
	{"WINREG_SETVALUE", DCERPC_WINREG_SETVALUE, api_winreg_SetValue},
	{"WINREG_UNLOADKEY", DCERPC_WINREG_UNLOADKEY, api_winreg_UnLoadKey},
	{"WINREG_INITIATESYSTEMSHUTDOWN", DCERPC_WINREG_INITIATESYSTEMSHUTDOWN, api_winreg_InitiateSystemShutdown},
	{"WINREG_ABORTSYSTEMSHUTDOWN", DCERPC_WINREG_ABORTSYSTEMSHUTDOWN, api_winreg_AbortSystemShutdown},
	{"WINREG_GETVERSION", DCERPC_WINREG_GETVERSION, api_winreg_GetVersion},
	{"WINREG_OPENHKCC", DCERPC_WINREG_OPENHKCC, api_winreg_OpenHKCC},
	{"WINREG_OPENHKDD", DCERPC_WINREG_OPENHKDD, api_winreg_OpenHKDD},
	{"WINREG_QUERYMULTIPLEVALUES", DCERPC_WINREG_QUERYMULTIPLEVALUES, api_winreg_QueryMultipleValues},
	{"WINREG_INITIATESYSTEMSHUTDOWNEX", DCERPC_WINREG_INITIATESYSTEMSHUTDOWNEX, api_winreg_InitiateSystemShutdownEx},
	{"WINREG_SAVEKEYEX", DCERPC_WINREG_SAVEKEYEX, api_winreg_SaveKeyEx},
	{"WINREG_OPENHKPT", DCERPC_WINREG_OPENHKPT, api_winreg_OpenHKPT},
	{"WINREG_OPENHKPN", DCERPC_WINREG_OPENHKPN, api_winreg_OpenHKPN},
	{"WINREG_QUERYMULTIPLEVALUES2", DCERPC_WINREG_QUERYMULTIPLEVALUES2, api_winreg_QueryMultipleValues2},
};

void winreg_get_pipe_fns(struct api_struct **fns, int *n_fns)
{
	*fns = api_winreg_cmds;
	*n_fns = sizeof(api_winreg_cmds) / sizeof(struct api_struct);
}

NTSTATUS rpc_winreg_init(void)
{
	return rpc_pipe_register_commands(SMB_RPC_INTERFACE_VERSION, "winreg", "winreg", api_winreg_cmds, sizeof(api_winreg_cmds) / sizeof(struct api_struct));
}
