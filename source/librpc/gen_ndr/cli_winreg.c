/*
 * Unix SMB/CIFS implementation.
 * client auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "librpc/gen_ndr/cli_winreg.h"

NTSTATUS rpccli_winreg_OpenHKCR(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, uint16_t *system_name, uint32_t access_mask, struct policy_handle *handle)
{
	struct winreg_OpenHKCR r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.system_name = system_name;
	r.in.access_mask = access_mask;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_OpenHKCR, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_OPENHKCR, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_OpenHKCR, (ndr_push_flags_fn_t)ndr_push_winreg_OpenHKCR);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_OpenHKCR, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*handle = *r.out.handle;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_OpenHKCU(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, uint16_t *system_name, uint32_t access_mask, struct policy_handle *handle)
{
	struct winreg_OpenHKCU r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.system_name = system_name;
	r.in.access_mask = access_mask;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_OpenHKCU, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_OPENHKCU, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_OpenHKCU, (ndr_push_flags_fn_t)ndr_push_winreg_OpenHKCU);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_OpenHKCU, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*handle = *r.out.handle;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_OpenHKLM(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, uint16_t *system_name, uint32_t access_mask, struct policy_handle *handle)
{
	struct winreg_OpenHKLM r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.system_name = system_name;
	r.in.access_mask = access_mask;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_OpenHKLM, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_OPENHKLM, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_OpenHKLM, (ndr_push_flags_fn_t)ndr_push_winreg_OpenHKLM);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_OpenHKLM, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*handle = *r.out.handle;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_OpenHKPD(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, uint16_t *system_name, uint32_t access_mask, struct policy_handle *handle)
{
	struct winreg_OpenHKPD r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.system_name = system_name;
	r.in.access_mask = access_mask;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_OpenHKPD, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_OPENHKPD, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_OpenHKPD, (ndr_push_flags_fn_t)ndr_push_winreg_OpenHKPD);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_OpenHKPD, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*handle = *r.out.handle;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_OpenHKU(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, uint16_t *system_name, uint32_t access_mask, struct policy_handle *handle)
{
	struct winreg_OpenHKU r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.system_name = system_name;
	r.in.access_mask = access_mask;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_OpenHKU, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_OPENHKU, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_OpenHKU, (ndr_push_flags_fn_t)ndr_push_winreg_OpenHKU);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_OpenHKU, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*handle = *r.out.handle;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_CloseKey(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle)
{
	struct winreg_CloseKey r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_CloseKey, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_CLOSEKEY, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_CloseKey, (ndr_push_flags_fn_t)ndr_push_winreg_CloseKey);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_CloseKey, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*handle = *r.out.handle;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_CreateKey(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, struct winreg_String name, struct winreg_String keyclass, uint32_t options, uint32_t access_mask, struct winreg_SecBuf *secdesc, struct policy_handle *new_handle, enum winreg_CreateAction *action_taken)
{
	struct winreg_CreateKey r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.name = name;
	r.in.keyclass = keyclass;
	r.in.options = options;
	r.in.access_mask = access_mask;
	r.in.secdesc = secdesc;
	r.in.action_taken = action_taken;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_CreateKey, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_CREATEKEY, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_CreateKey, (ndr_push_flags_fn_t)ndr_push_winreg_CreateKey);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_CreateKey, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*new_handle = *r.out.new_handle;
	if ( action_taken ) {
		*action_taken = *r.out.action_taken;
	}
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_DeleteKey(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, struct winreg_String key)
{
	struct winreg_DeleteKey r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.key = key;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_DeleteKey, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_DELETEKEY, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_DeleteKey, (ndr_push_flags_fn_t)ndr_push_winreg_DeleteKey);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_DeleteKey, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_DeleteValue(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, struct winreg_String value)
{
	struct winreg_DeleteValue r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.value = value;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_DeleteValue, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_DELETEVALUE, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_DeleteValue, (ndr_push_flags_fn_t)ndr_push_winreg_DeleteValue);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_DeleteValue, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_EnumKey(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t enum_index, struct winreg_StringBuf *name, struct winreg_StringBuf *keyclass, NTTIME *last_changed_time)
{
	struct winreg_EnumKey r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.enum_index = enum_index;
	r.in.name = name;
	r.in.keyclass = keyclass;
	r.in.last_changed_time = last_changed_time;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_EnumKey, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_ENUMKEY, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_EnumKey, (ndr_push_flags_fn_t)ndr_push_winreg_EnumKey);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_EnumKey, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*name = *r.out.name;
	if ( keyclass ) {
		*keyclass = *r.out.keyclass;
	}
	if ( last_changed_time ) {
		*last_changed_time = *r.out.last_changed_time;
	}
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_EnumValue(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t enum_index, struct winreg_ValNameBuf *name, enum winreg_Type *type, uint8_t *value, uint32_t *size, uint32_t *length)
{
	struct winreg_EnumValue r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.enum_index = enum_index;
	r.in.name = name;
	r.in.type = type;
	r.in.value = value;
	r.in.size = size;
	r.in.length = length;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_EnumValue, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_ENUMVALUE, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_EnumValue, (ndr_push_flags_fn_t)ndr_push_winreg_EnumValue);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_EnumValue, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*name = *r.out.name;
	if ( type ) {
		*type = *r.out.type;
	}
	if ( value ) {
		*value = *r.out.value;
	}
	if ( size ) {
		*size = *r.out.size;
	}
	if ( length ) {
		*length = *r.out.length;
	}
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_FlushKey(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle)
{
	struct winreg_FlushKey r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_FlushKey, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_FLUSHKEY, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_FlushKey, (ndr_push_flags_fn_t)ndr_push_winreg_FlushKey);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_FlushKey, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_GetKeySecurity(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t sec_info, struct KeySecurityData *sd)
{
	struct winreg_GetKeySecurity r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.sec_info = sec_info;
	r.in.sd = sd;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_GetKeySecurity, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_GETKEYSECURITY, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_GetKeySecurity, (ndr_push_flags_fn_t)ndr_push_winreg_GetKeySecurity);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_GetKeySecurity, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*sd = *r.out.sd;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_LoadKey(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, struct winreg_String *keyname, struct winreg_String *filename)
{
	struct winreg_LoadKey r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.keyname = keyname;
	r.in.filename = filename;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_LoadKey, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_LOADKEY, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_LoadKey, (ndr_push_flags_fn_t)ndr_push_winreg_LoadKey);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_LoadKey, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_NotifyChangeKeyValue(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint8_t watch_subtree, uint32_t notify_filter, uint32_t unknown, struct winreg_String string1, struct winreg_String string2, uint32_t unknown2)
{
	struct winreg_NotifyChangeKeyValue r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.watch_subtree = watch_subtree;
	r.in.notify_filter = notify_filter;
	r.in.unknown = unknown;
	r.in.string1 = string1;
	r.in.string2 = string2;
	r.in.unknown2 = unknown2;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_NotifyChangeKeyValue, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_NOTIFYCHANGEKEYVALUE, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_NotifyChangeKeyValue, (ndr_push_flags_fn_t)ndr_push_winreg_NotifyChangeKeyValue);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_NotifyChangeKeyValue, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_OpenKey(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *parent_handle, struct winreg_String keyname, uint32_t unknown, uint32_t access_mask, struct policy_handle *handle)
{
	struct winreg_OpenKey r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.parent_handle = parent_handle;
	r.in.keyname = keyname;
	r.in.unknown = unknown;
	r.in.access_mask = access_mask;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_OpenKey, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_OPENKEY, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_OpenKey, (ndr_push_flags_fn_t)ndr_push_winreg_OpenKey);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_OpenKey, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*handle = *r.out.handle;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_QueryInfoKey(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, struct winreg_String *classname, uint32_t *num_subkeys, uint32_t *max_subkeylen, uint32_t *max_classlen, uint32_t *num_values, uint32_t *max_valnamelen, uint32_t *max_valbufsize, uint32_t *secdescsize, NTTIME *last_changed_time)
{
	struct winreg_QueryInfoKey r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.classname = classname;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_QueryInfoKey, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_QUERYINFOKEY, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_QueryInfoKey, (ndr_push_flags_fn_t)ndr_push_winreg_QueryInfoKey);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_QueryInfoKey, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*classname = *r.out.classname;
	*num_subkeys = *r.out.num_subkeys;
	*max_subkeylen = *r.out.max_subkeylen;
	*max_classlen = *r.out.max_classlen;
	*num_values = *r.out.num_values;
	*max_valnamelen = *r.out.max_valnamelen;
	*max_valbufsize = *r.out.max_valbufsize;
	*secdescsize = *r.out.secdescsize;
	*last_changed_time = *r.out.last_changed_time;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_QueryValue(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, struct winreg_String value_name, enum winreg_Type *type, uint8_t *data, uint32_t *data_size, uint32_t *value_length)
{
	struct winreg_QueryValue r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.value_name = value_name;
	r.in.type = type;
	r.in.data = data;
	r.in.data_size = data_size;
	r.in.value_length = value_length;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_QueryValue, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_QUERYVALUE, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_QueryValue, (ndr_push_flags_fn_t)ndr_push_winreg_QueryValue);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_QueryValue, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	if ( type ) {
		*type = *r.out.type;
	}
	if ( data ) {
		*data = *r.out.data;
	}
	if ( data_size ) {
		*data_size = *r.out.data_size;
	}
	if ( value_length ) {
		*value_length = *r.out.value_length;
	}
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_ReplaceKey(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx)
{
	struct winreg_ReplaceKey r;
	NTSTATUS status;
	
	/* In parameters */
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_ReplaceKey, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_REPLACEKEY, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_ReplaceKey, (ndr_push_flags_fn_t)ndr_push_winreg_ReplaceKey);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_ReplaceKey, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_RestoreKey(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, struct winreg_String *filename, uint32_t flags)
{
	struct winreg_RestoreKey r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.filename = filename;
	r.in.flags = flags;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_RestoreKey, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_RESTOREKEY, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_RestoreKey, (ndr_push_flags_fn_t)ndr_push_winreg_RestoreKey);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_RestoreKey, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_SaveKey(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, struct winreg_String *filename, struct KeySecurityAttribute *sec_attrib)
{
	struct winreg_SaveKey r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.filename = filename;
	r.in.sec_attrib = sec_attrib;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_SaveKey, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_SAVEKEY, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_SaveKey, (ndr_push_flags_fn_t)ndr_push_winreg_SaveKey);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_SaveKey, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_SetKeySecurity(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t access_mask, struct KeySecurityData *sd)
{
	struct winreg_SetKeySecurity r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.access_mask = access_mask;
	r.in.sd = sd;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_SetKeySecurity, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_SETKEYSECURITY, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_SetKeySecurity, (ndr_push_flags_fn_t)ndr_push_winreg_SetKeySecurity);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_SetKeySecurity, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_SetValue(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, struct winreg_String name, enum winreg_Type type, uint8_t *data, uint32_t size)
{
	struct winreg_SetValue r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.name = name;
	r.in.type = type;
	r.in.data = data;
	r.in.size = size;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_SetValue, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_SETVALUE, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_SetValue, (ndr_push_flags_fn_t)ndr_push_winreg_SetValue);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_SetValue, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_UnLoadKey(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx)
{
	struct winreg_UnLoadKey r;
	NTSTATUS status;
	
	/* In parameters */
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_UnLoadKey, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_UNLOADKEY, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_UnLoadKey, (ndr_push_flags_fn_t)ndr_push_winreg_UnLoadKey);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_UnLoadKey, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_InitiateSystemShutdown(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, uint16_t *hostname, struct initshutdown_String *message, uint32_t timeout, uint8_t force_apps, uint8_t reboot)
{
	struct winreg_InitiateSystemShutdown r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.hostname = hostname;
	r.in.message = message;
	r.in.timeout = timeout;
	r.in.force_apps = force_apps;
	r.in.reboot = reboot;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_InitiateSystemShutdown, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_INITIATESYSTEMSHUTDOWN, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_InitiateSystemShutdown, (ndr_push_flags_fn_t)ndr_push_winreg_InitiateSystemShutdown);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_InitiateSystemShutdown, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_AbortSystemShutdown(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, uint16_t *server)
{
	struct winreg_AbortSystemShutdown r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.server = server;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_AbortSystemShutdown, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_ABORTSYSTEMSHUTDOWN, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_AbortSystemShutdown, (ndr_push_flags_fn_t)ndr_push_winreg_AbortSystemShutdown);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_AbortSystemShutdown, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_GetVersion(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t *version)
{
	struct winreg_GetVersion r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_GetVersion, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_GETVERSION, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_GetVersion, (ndr_push_flags_fn_t)ndr_push_winreg_GetVersion);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_GetVersion, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*version = *r.out.version;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_OpenHKCC(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, uint16_t *system_name, uint32_t access_mask, struct policy_handle *handle)
{
	struct winreg_OpenHKCC r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.system_name = system_name;
	r.in.access_mask = access_mask;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_OpenHKCC, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_OPENHKCC, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_OpenHKCC, (ndr_push_flags_fn_t)ndr_push_winreg_OpenHKCC);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_OpenHKCC, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*handle = *r.out.handle;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_OpenHKDD(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, uint16_t *system_name, uint32_t access_mask, struct policy_handle *handle)
{
	struct winreg_OpenHKDD r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.system_name = system_name;
	r.in.access_mask = access_mask;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_OpenHKDD, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_OPENHKDD, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_OpenHKDD, (ndr_push_flags_fn_t)ndr_push_winreg_OpenHKDD);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_OpenHKDD, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*handle = *r.out.handle;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_QueryMultipleValues(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *key_handle, struct QueryMultipleValue *values, uint32_t num_values, uint8_t *buffer, uint32_t *buffer_size)
{
	struct winreg_QueryMultipleValues r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.key_handle = key_handle;
	r.in.values = values;
	r.in.num_values = num_values;
	r.in.buffer = buffer;
	r.in.buffer_size = buffer_size;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_QueryMultipleValues, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_QUERYMULTIPLEVALUES, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_QueryMultipleValues, (ndr_push_flags_fn_t)ndr_push_winreg_QueryMultipleValues);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_QueryMultipleValues, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*values = *r.out.values;
	if ( buffer ) {
		*buffer = *r.out.buffer;
	}
	*buffer_size = *r.out.buffer_size;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_InitiateSystemShutdownEx(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, uint16_t *hostname, struct initshutdown_String *message, uint32_t timeout, uint8_t force_apps, uint8_t reboot, uint32_t reason)
{
	struct winreg_InitiateSystemShutdownEx r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.hostname = hostname;
	r.in.message = message;
	r.in.timeout = timeout;
	r.in.force_apps = force_apps;
	r.in.reboot = reboot;
	r.in.reason = reason;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_InitiateSystemShutdownEx, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_INITIATESYSTEMSHUTDOWNEX, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_InitiateSystemShutdownEx, (ndr_push_flags_fn_t)ndr_push_winreg_InitiateSystemShutdownEx);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_InitiateSystemShutdownEx, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_SaveKeyEx(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx)
{
	struct winreg_SaveKeyEx r;
	NTSTATUS status;
	
	/* In parameters */
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_SaveKeyEx, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_SAVEKEYEX, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_SaveKeyEx, (ndr_push_flags_fn_t)ndr_push_winreg_SaveKeyEx);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_SaveKeyEx, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_OpenHKPT(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, uint16_t *system_name, uint32_t access_mask, struct policy_handle *handle)
{
	struct winreg_OpenHKPT r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.system_name = system_name;
	r.in.access_mask = access_mask;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_OpenHKPT, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_OPENHKPT, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_OpenHKPT, (ndr_push_flags_fn_t)ndr_push_winreg_OpenHKPT);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_OpenHKPT, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*handle = *r.out.handle;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_OpenHKPN(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, uint16_t *system_name, uint32_t access_mask, struct policy_handle *handle)
{
	struct winreg_OpenHKPN r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.system_name = system_name;
	r.in.access_mask = access_mask;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_OpenHKPN, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_OPENHKPN, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_OpenHKPN, (ndr_push_flags_fn_t)ndr_push_winreg_OpenHKPN);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_OpenHKPN, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*handle = *r.out.handle;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_winreg_QueryMultipleValues2(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx)
{
	struct winreg_QueryMultipleValues2 r;
	NTSTATUS status;
	
	/* In parameters */
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(winreg_QueryMultipleValues2, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_WINREG, DCERPC_WINREG_QUERYMULTIPLEVALUES2, &r, (ndr_pull_flags_fn_t)ndr_pull_winreg_QueryMultipleValues2, (ndr_push_flags_fn_t)ndr_push_winreg_QueryMultipleValues2);
	
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(winreg_QueryMultipleValues2, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

