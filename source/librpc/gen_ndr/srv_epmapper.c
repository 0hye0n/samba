/*
 * Unix SMB/CIFS implementation.
 * server auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "librpc/gen_ndr/srv_epmapper.h"

static BOOL api_epm_Insert(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct epm_Insert r;
	TALLOC_CTX *mem_ctx = talloc_init("api_epm_Insert");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_epm_Insert(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(epm_Insert, &r);
	
	r.out.result = _epm_Insert(p, &r);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(epm_Insert, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_epm_Insert(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_epm_Delete(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct epm_Delete r;
	TALLOC_CTX *mem_ctx = talloc_init("api_epm_Delete");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_epm_Delete(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(epm_Delete, &r);
	
	r.out.result = _epm_Delete(p, &r);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(epm_Delete, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_epm_Delete(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_epm_Lookup(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct epm_Lookup r;
	TALLOC_CTX *mem_ctx = talloc_init("api_epm_Lookup");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_epm_Lookup(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(epm_Lookup, &r);
	
	ZERO_STRUCT(r.out);
	r.out.entry_handle = r.in.entry_handle;
	r.out.num_ents = talloc_zero(mem_ctx, uint32_t);
	if (r.out.num_ents == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.entries = talloc_zero_array(mem_ctx, struct epm_entry_t, r.in.max_ents);
	if (r.out.entries == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _epm_Lookup(p, &r);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(epm_Lookup, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_epm_Lookup(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_epm_Map(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct epm_Map r;
	TALLOC_CTX *mem_ctx = talloc_init("api_epm_Map");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_epm_Map(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(epm_Map, &r);
	
	ZERO_STRUCT(r.out);
	r.out.entry_handle = r.in.entry_handle;
	r.out.num_towers = talloc_zero(mem_ctx, uint32_t);
	if (r.out.num_towers == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.towers = talloc_zero_array(mem_ctx, struct epm_twr_p_t, r.in.max_towers);
	if (r.out.towers == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _epm_Map(p, &r);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(epm_Map, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_epm_Map(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_epm_LookupHandleFree(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct epm_LookupHandleFree r;
	TALLOC_CTX *mem_ctx = talloc_init("api_epm_LookupHandleFree");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_epm_LookupHandleFree(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(epm_LookupHandleFree, &r);
	
	ZERO_STRUCT(r.out);
	r.out.entry_handle = r.in.entry_handle;
	r.out.result = _epm_LookupHandleFree(p, &r);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(epm_LookupHandleFree, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_epm_LookupHandleFree(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_epm_InqObject(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct epm_InqObject r;
	TALLOC_CTX *mem_ctx = talloc_init("api_epm_InqObject");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_epm_InqObject(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(epm_InqObject, &r);
	
	r.out.result = _epm_InqObject(p, &r);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(epm_InqObject, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_epm_InqObject(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_epm_MgmtDelete(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct epm_MgmtDelete r;
	TALLOC_CTX *mem_ctx = talloc_init("api_epm_MgmtDelete");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_epm_MgmtDelete(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(epm_MgmtDelete, &r);
	
	r.out.result = _epm_MgmtDelete(p, &r);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(epm_MgmtDelete, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_epm_MgmtDelete(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_epm_MapAuth(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct epm_MapAuth r;
	TALLOC_CTX *mem_ctx = talloc_init("api_epm_MapAuth");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_epm_MapAuth(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(epm_MapAuth, &r);
	
	r.out.result = _epm_MapAuth(p, &r);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(epm_MapAuth, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_epm_MapAuth(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}


/* Tables */
static struct api_struct api_epmapper_cmds[] = 
{
	{"EPM_INSERT", NDR_EPM_INSERT, api_epm_Insert},
	{"EPM_DELETE", NDR_EPM_DELETE, api_epm_Delete},
	{"EPM_LOOKUP", NDR_EPM_LOOKUP, api_epm_Lookup},
	{"EPM_MAP", NDR_EPM_MAP, api_epm_Map},
	{"EPM_LOOKUPHANDLEFREE", NDR_EPM_LOOKUPHANDLEFREE, api_epm_LookupHandleFree},
	{"EPM_INQOBJECT", NDR_EPM_INQOBJECT, api_epm_InqObject},
	{"EPM_MGMTDELETE", NDR_EPM_MGMTDELETE, api_epm_MgmtDelete},
	{"EPM_MAPAUTH", NDR_EPM_MAPAUTH, api_epm_MapAuth},
};

void epmapper_get_pipe_fns(struct api_struct **fns, int *n_fns)
{
	*fns = api_epmapper_cmds;
	*n_fns = sizeof(api_epmapper_cmds) / sizeof(struct api_struct);
}

NTSTATUS rpc_epmapper_init(void)
{
	return rpc_pipe_register_commands(SMB_RPC_INTERFACE_VERSION, "epmapper", "epmapper", api_epmapper_cmds, sizeof(api_epmapper_cmds) / sizeof(struct api_struct));
}
