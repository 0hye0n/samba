/*
 * Unix SMB/CIFS implementation.
 * server auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "librpc/gen_ndr/srv_dfs.h"

static BOOL api_dfs_GetManagerVersion(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_GetManagerVersion r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_GetManagerVersion");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_GetManagerVersion(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_GetManagerVersion, &r);
	
	ZERO_STRUCT(r.out);
	r.out.exist_flag = talloc_zero_size(mem_ctx, sizeof(*r.out.exist_flag));
	if (r.out.exist_flag == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	_dfs_GetManagerVersion(p, r.out.exist_flag);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_GetManagerVersion, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_GetManagerVersion(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_Add(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_Add r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_Add");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_Add(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_Add, &r);
	
	r.out.result = _dfs_Add(p, r.in.path, r.in.server, r.in.share, r.in.comment, r.in.flags);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_Add, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_Add(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_Remove(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_Remove r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_Remove");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_Remove(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_Remove, &r);
	
	r.out.result = _dfs_Remove(p, r.in.path, r.in.server, r.in.share);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_Remove, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_Remove(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_SetInfo(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_SetInfo r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_SetInfo");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_SetInfo(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_SetInfo, &r);
	
	r.out.result = _dfs_SetInfo(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_SetInfo, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_SetInfo(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_GetInfo(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_GetInfo r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_GetInfo");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_GetInfo(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_GetInfo, &r);
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_zero_size(mem_ctx, sizeof(*r.out.info));
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _dfs_GetInfo(p, r.in.path, r.in.server, r.in.share, r.in.level, r.out.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_GetInfo, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_GetInfo(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_Enum(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_Enum r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_Enum");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_Enum(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_Enum, &r);
	
	ZERO_STRUCT(r.out);
	r.out.info = r.in.info;
	r.out.total = r.in.total;
	r.out.result = _dfs_Enum(p, r.in.level, r.in.bufsize, r.in.info, r.in.unknown, r.in.total);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_Enum, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_Enum(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_Rename(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_Rename r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_Rename");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_Rename(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_Rename, &r);
	
	r.out.result = _dfs_Rename(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_Rename, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_Rename(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_Move(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_Move r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_Move");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_Move(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_Move, &r);
	
	r.out.result = _dfs_Move(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_Move, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_Move(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_ManagerGetConfigInfo(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_ManagerGetConfigInfo r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_ManagerGetConfigInfo");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_ManagerGetConfigInfo(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_ManagerGetConfigInfo, &r);
	
	r.out.result = _dfs_ManagerGetConfigInfo(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_ManagerGetConfigInfo, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_ManagerGetConfigInfo(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_ManagerSendSiteInfo(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_ManagerSendSiteInfo r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_ManagerSendSiteInfo");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_ManagerSendSiteInfo(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_ManagerSendSiteInfo, &r);
	
	r.out.result = _dfs_ManagerSendSiteInfo(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_ManagerSendSiteInfo, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_ManagerSendSiteInfo(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_AddFtRoot(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_AddFtRoot r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_AddFtRoot");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_AddFtRoot(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_AddFtRoot, &r);
	
	r.out.result = _dfs_AddFtRoot(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_AddFtRoot, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_AddFtRoot(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_RemoveFtRoot(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_RemoveFtRoot r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_RemoveFtRoot");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_RemoveFtRoot(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_RemoveFtRoot, &r);
	
	r.out.result = _dfs_RemoveFtRoot(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_RemoveFtRoot, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_RemoveFtRoot(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_AddStdRoot(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_AddStdRoot r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_AddStdRoot");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_AddStdRoot(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_AddStdRoot, &r);
	
	r.out.result = _dfs_AddStdRoot(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_AddStdRoot, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_AddStdRoot(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_RemoveStdRoot(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_RemoveStdRoot r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_RemoveStdRoot");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_RemoveStdRoot(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_RemoveStdRoot, &r);
	
	r.out.result = _dfs_RemoveStdRoot(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_RemoveStdRoot, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_RemoveStdRoot(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_ManagerInitialize(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_ManagerInitialize r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_ManagerInitialize");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_ManagerInitialize(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_ManagerInitialize, &r);
	
	r.out.result = _dfs_ManagerInitialize(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_ManagerInitialize, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_ManagerInitialize(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_AddStdRootForced(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_AddStdRootForced r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_AddStdRootForced");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_AddStdRootForced(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_AddStdRootForced, &r);
	
	r.out.result = _dfs_AddStdRootForced(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_AddStdRootForced, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_AddStdRootForced(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_GetDcAddress(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_GetDcAddress r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_GetDcAddress");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_GetDcAddress(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_GetDcAddress, &r);
	
	r.out.result = _dfs_GetDcAddress(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_GetDcAddress, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_GetDcAddress(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_SetDcAddress(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_SetDcAddress r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_SetDcAddress");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_SetDcAddress(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_SetDcAddress, &r);
	
	r.out.result = _dfs_SetDcAddress(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_SetDcAddress, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_SetDcAddress(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_FlushFtTable(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_FlushFtTable r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_FlushFtTable");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_FlushFtTable(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_FlushFtTable, &r);
	
	r.out.result = _dfs_FlushFtTable(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_FlushFtTable, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_FlushFtTable(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_Add2(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_Add2 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_Add2");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_Add2(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_Add2, &r);
	
	r.out.result = _dfs_Add2(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_Add2, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_Add2(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_Remove2(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_Remove2 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_Remove2");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_Remove2(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_Remove2, &r);
	
	r.out.result = _dfs_Remove2(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_Remove2, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_Remove2(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_EnumEx(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_EnumEx r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_EnumEx");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_EnumEx(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_EnumEx, &r);
	
	ZERO_STRUCT(r.out);
	r.out.info = r.in.info;
	r.out.total = r.in.total;
	r.out.result = _dfs_EnumEx(p, r.in.name, r.in.level, r.in.bufsize, r.in.info, r.in.total);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_EnumEx, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_EnumEx(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_dfs_SetInfo2(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct dfs_SetInfo2 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_dfs_SetInfo2");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_dfs_SetInfo2(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(dfs_SetInfo2, &r);
	
	r.out.result = _dfs_SetInfo2(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(dfs_SetInfo2, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_dfs_SetInfo2(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}


/* Tables */
static struct api_struct api_netdfs_cmds[] = 
{
	{"DFS_GETMANAGERVERSION", DCERPC_DFS_GETMANAGERVERSION, api_dfs_GetManagerVersion},
	{"DFS_ADD", DCERPC_DFS_ADD, api_dfs_Add},
	{"DFS_REMOVE", DCERPC_DFS_REMOVE, api_dfs_Remove},
	{"DFS_SETINFO", DCERPC_DFS_SETINFO, api_dfs_SetInfo},
	{"DFS_GETINFO", DCERPC_DFS_GETINFO, api_dfs_GetInfo},
	{"DFS_ENUM", DCERPC_DFS_ENUM, api_dfs_Enum},
	{"DFS_RENAME", DCERPC_DFS_RENAME, api_dfs_Rename},
	{"DFS_MOVE", DCERPC_DFS_MOVE, api_dfs_Move},
	{"DFS_MANAGERGETCONFIGINFO", DCERPC_DFS_MANAGERGETCONFIGINFO, api_dfs_ManagerGetConfigInfo},
	{"DFS_MANAGERSENDSITEINFO", DCERPC_DFS_MANAGERSENDSITEINFO, api_dfs_ManagerSendSiteInfo},
	{"DFS_ADDFTROOT", DCERPC_DFS_ADDFTROOT, api_dfs_AddFtRoot},
	{"DFS_REMOVEFTROOT", DCERPC_DFS_REMOVEFTROOT, api_dfs_RemoveFtRoot},
	{"DFS_ADDSTDROOT", DCERPC_DFS_ADDSTDROOT, api_dfs_AddStdRoot},
	{"DFS_REMOVESTDROOT", DCERPC_DFS_REMOVESTDROOT, api_dfs_RemoveStdRoot},
	{"DFS_MANAGERINITIALIZE", DCERPC_DFS_MANAGERINITIALIZE, api_dfs_ManagerInitialize},
	{"DFS_ADDSTDROOTFORCED", DCERPC_DFS_ADDSTDROOTFORCED, api_dfs_AddStdRootForced},
	{"DFS_GETDCADDRESS", DCERPC_DFS_GETDCADDRESS, api_dfs_GetDcAddress},
	{"DFS_SETDCADDRESS", DCERPC_DFS_SETDCADDRESS, api_dfs_SetDcAddress},
	{"DFS_FLUSHFTTABLE", DCERPC_DFS_FLUSHFTTABLE, api_dfs_FlushFtTable},
	{"DFS_ADD2", DCERPC_DFS_ADD2, api_dfs_Add2},
	{"DFS_REMOVE2", DCERPC_DFS_REMOVE2, api_dfs_Remove2},
	{"DFS_ENUMEX", DCERPC_DFS_ENUMEX, api_dfs_EnumEx},
	{"DFS_SETINFO2", DCERPC_DFS_SETINFO2, api_dfs_SetInfo2},
};

void netdfs_get_pipe_fns(struct api_struct **fns, int *n_fns)
{
	*fns = api_netdfs_cmds;
	*n_fns = sizeof(api_netdfs_cmds) / sizeof(struct api_struct);
}

NTSTATUS rpc_netdfs_init(void)
{
	return rpc_pipe_register_commands(SMB_RPC_INTERFACE_VERSION, "netdfs", "netdfs", api_netdfs_cmds, sizeof(api_netdfs_cmds) / sizeof(struct api_struct));
}
