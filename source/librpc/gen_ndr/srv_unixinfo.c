/*
 * Unix SMB/CIFS implementation.
 * server auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "librpc/gen_ndr/srv_unixinfo.h"

static BOOL api_unixinfo_SidToUid(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct unixinfo_SidToUid r;
	TALLOC_CTX *mem_ctx = talloc_init("api_unixinfo_SidToUid");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_unixinfo_SidToUid(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(unixinfo_SidToUid, &r);
	
	ZERO_STRUCT(r.out);
	r.out.uid = talloc_zero_size(mem_ctx, sizeof(*r.out.uid));
	if (r.out.uid == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _unixinfo_SidToUid(p, r.in.sid, r.out.uid);
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(unixinfo_SidToUid, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_unixinfo_SidToUid(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_unixinfo_UidToSid(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct unixinfo_UidToSid r;
	TALLOC_CTX *mem_ctx = talloc_init("api_unixinfo_UidToSid");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_unixinfo_UidToSid(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(unixinfo_UidToSid, &r);
	
	ZERO_STRUCT(r.out);
	r.out.sid = talloc_zero_size(mem_ctx, sizeof(*r.out.sid));
	if (r.out.sid == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _unixinfo_UidToSid(p, r.in.uid, r.out.sid);
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(unixinfo_UidToSid, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_unixinfo_UidToSid(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_unixinfo_SidToGid(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct unixinfo_SidToGid r;
	TALLOC_CTX *mem_ctx = talloc_init("api_unixinfo_SidToGid");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_unixinfo_SidToGid(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(unixinfo_SidToGid, &r);
	
	ZERO_STRUCT(r.out);
	r.out.gid = talloc_zero_size(mem_ctx, sizeof(*r.out.gid));
	if (r.out.gid == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _unixinfo_SidToGid(p, r.in.sid, r.out.gid);
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(unixinfo_SidToGid, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_unixinfo_SidToGid(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_unixinfo_GidToSid(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct unixinfo_GidToSid r;
	TALLOC_CTX *mem_ctx = talloc_init("api_unixinfo_GidToSid");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_unixinfo_GidToSid(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(unixinfo_GidToSid, &r);
	
	ZERO_STRUCT(r.out);
	r.out.sid = talloc_zero_size(mem_ctx, sizeof(*r.out.sid));
	if (r.out.sid == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _unixinfo_GidToSid(p, r.in.gid, r.out.sid);
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(unixinfo_GidToSid, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_unixinfo_GidToSid(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_unixinfo_GetPWUid(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct unixinfo_GetPWUid r;
	TALLOC_CTX *mem_ctx = talloc_init("api_unixinfo_GetPWUid");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_unixinfo_GetPWUid(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(unixinfo_GetPWUid, &r);
	
	ZERO_STRUCT(r.out);
	r.out.count = r.in.count;
	r.out.infos = talloc_zero_size(mem_ctx, sizeof(*r.out.infos) * *r.in.count);
	if (r.out.infos == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _unixinfo_GetPWUid(p, r.in.count, r.in.uids, r.out.infos);
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(unixinfo_GetPWUid, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_unixinfo_GetPWUid(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}


/* Tables */
static struct api_struct api_unixinfo_cmds[] = 
{
	{"UNIXINFO_SIDTOUID", DCERPC_UNIXINFO_SIDTOUID, api_unixinfo_SidToUid},
	{"UNIXINFO_UIDTOSID", DCERPC_UNIXINFO_UIDTOSID, api_unixinfo_UidToSid},
	{"UNIXINFO_SIDTOGID", DCERPC_UNIXINFO_SIDTOGID, api_unixinfo_SidToGid},
	{"UNIXINFO_GIDTOSID", DCERPC_UNIXINFO_GIDTOSID, api_unixinfo_GidToSid},
	{"UNIXINFO_GETPWUID", DCERPC_UNIXINFO_GETPWUID, api_unixinfo_GetPWUid},
};

void unixinfo_get_pipe_fns(struct api_struct **fns, int *n_fns)
{
	*fns = api_unixinfo_cmds;
	*n_fns = sizeof(api_unixinfo_cmds) / sizeof(struct api_struct);
}

NTSTATUS rpc_unixinfo_init(void)
{
	return rpc_pipe_register_commands(SMB_RPC_INTERFACE_VERSION, "unixinfo", "unixinfo", api_unixinfo_cmds, sizeof(api_unixinfo_cmds) / sizeof(struct api_struct));
}
