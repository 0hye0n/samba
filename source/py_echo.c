
/* Python wrapper functions auto-generated by pidl */
#include "includes.h"
#include <Python.h>
#include "librpc/rpc/dcerpc.h"
#include "scripting/python/pytalloc.h"
#include "./ndr_echo.h"
#include "./ndr_echo_c.h"
#include "./py_echo.h"


staticforward PyTypeObject echo_info1_ObjectType;

static PyObject *py_echo_info1_getattr(PyObject *obj, char *name)
{
	struct echo_info1 *object = py_talloc_get_type(obj, struct echo_info1);
	if (!strcmp(name, "v")) {
		return PyInt_FromLong(object->v);
	}
	PyErr_SetString(PyExc_AttributeError, "no such attribute");
	return NULL;
}

static int py_echo_info1_setattr(PyObject *py_obj, char *name, PyObject *value)
{
	struct echo_info1 *object = py_talloc_get_type(py_obj, struct echo_info1);
	if (!strcmp(name, "v")) {
		/* FIXME: talloc_free(object->v) if necessary */
		object->v = PyInt_AsLong(value);
		return 0;
	}
	PyErr_SetString(PyExc_AttributeError, "no such attribute");
	return -1;
}

static PyTypeObject echo_info1_ObjectType = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "echo_info1",
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_dealloc = py_talloc_dealloc,
	.tp_getattr = py_echo_info1_getattr,
	.tp_setattr = py_echo_info1_setattr,
};

static PyObject *py_echo_info1(PyObject *self, PyObject *args)
{
	struct echo_info1 *ret = talloc_zero(NULL, struct echo_info1);
	return py_talloc_import(&echo_info1_ObjectType, ret);
}

staticforward PyTypeObject echo_info2_ObjectType;

static PyObject *py_echo_info2_getattr(PyObject *obj, char *name)
{
	struct echo_info2 *object = py_talloc_get_type(obj, struct echo_info2);
	if (!strcmp(name, "v")) {
		return PyInt_FromLong(object->v);
	}
	PyErr_SetString(PyExc_AttributeError, "no such attribute");
	return NULL;
}

static int py_echo_info2_setattr(PyObject *py_obj, char *name, PyObject *value)
{
	struct echo_info2 *object = py_talloc_get_type(py_obj, struct echo_info2);
	if (!strcmp(name, "v")) {
		/* FIXME: talloc_free(object->v) if necessary */
		object->v = PyInt_AsLong(value);
		return 0;
	}
	PyErr_SetString(PyExc_AttributeError, "no such attribute");
	return -1;
}

static PyTypeObject echo_info2_ObjectType = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "echo_info2",
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_dealloc = py_talloc_dealloc,
	.tp_getattr = py_echo_info2_getattr,
	.tp_setattr = py_echo_info2_setattr,
};

static PyObject *py_echo_info2(PyObject *self, PyObject *args)
{
	struct echo_info2 *ret = talloc_zero(NULL, struct echo_info2);
	return py_talloc_import(&echo_info2_ObjectType, ret);
}

staticforward PyTypeObject echo_info3_ObjectType;

static PyObject *py_echo_info3_getattr(PyObject *obj, char *name)
{
	struct echo_info3 *object = py_talloc_get_type(obj, struct echo_info3);
	if (!strcmp(name, "v")) {
		return PyInt_FromLong(object->v);
	}
	PyErr_SetString(PyExc_AttributeError, "no such attribute");
	return NULL;
}

static int py_echo_info3_setattr(PyObject *py_obj, char *name, PyObject *value)
{
	struct echo_info3 *object = py_talloc_get_type(py_obj, struct echo_info3);
	if (!strcmp(name, "v")) {
		/* FIXME: talloc_free(object->v) if necessary */
		object->v = PyInt_AsLong(value);
		return 0;
	}
	PyErr_SetString(PyExc_AttributeError, "no such attribute");
	return -1;
}

static PyTypeObject echo_info3_ObjectType = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "echo_info3",
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_dealloc = py_talloc_dealloc,
	.tp_getattr = py_echo_info3_getattr,
	.tp_setattr = py_echo_info3_setattr,
};

static PyObject *py_echo_info3(PyObject *self, PyObject *args)
{
	struct echo_info3 *ret = talloc_zero(NULL, struct echo_info3);
	return py_talloc_import(&echo_info3_ObjectType, ret);
}

staticforward PyTypeObject echo_info4_ObjectType;

static PyObject *py_echo_info4_getattr(PyObject *obj, char *name)
{
	struct echo_info4 *object = py_talloc_get_type(obj, struct echo_info4);
	if (!strcmp(name, "v")) {
		return PyInt_FromLong(object->v);
	}
	PyErr_SetString(PyExc_AttributeError, "no such attribute");
	return NULL;
}

static int py_echo_info4_setattr(PyObject *py_obj, char *name, PyObject *value)
{
	struct echo_info4 *object = py_talloc_get_type(py_obj, struct echo_info4);
	if (!strcmp(name, "v")) {
		/* FIXME: talloc_free(object->v) if necessary */
		object->v = PyInt_AsLong(value);
		return 0;
	}
	PyErr_SetString(PyExc_AttributeError, "no such attribute");
	return -1;
}

static PyTypeObject echo_info4_ObjectType = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "echo_info4",
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_dealloc = py_talloc_dealloc,
	.tp_getattr = py_echo_info4_getattr,
	.tp_setattr = py_echo_info4_setattr,
};

static PyObject *py_echo_info4(PyObject *self, PyObject *args)
{
	struct echo_info4 *ret = talloc_zero(NULL, struct echo_info4);
	return py_talloc_import(&echo_info4_ObjectType, ret);
}

staticforward PyTypeObject echo_info5_ObjectType;

static PyObject *py_echo_info5_getattr(PyObject *obj, char *name)
{
	struct echo_info5 *object = py_talloc_get_type(obj, struct echo_info5);
	if (!strcmp(name, "v1")) {
		return PyInt_FromLong(object->v1);
	}
	if (!strcmp(name, "v2")) {
		return PyInt_FromLong(object->v2);
	}
	PyErr_SetString(PyExc_AttributeError, "no such attribute");
	return NULL;
}

static int py_echo_info5_setattr(PyObject *py_obj, char *name, PyObject *value)
{
	struct echo_info5 *object = py_talloc_get_type(py_obj, struct echo_info5);
	if (!strcmp(name, "v1")) {
		/* FIXME: talloc_free(object->v1) if necessary */
		object->v1 = PyInt_AsLong(value);
		return 0;
	}
	if (!strcmp(name, "v2")) {
		/* FIXME: talloc_free(object->v2) if necessary */
		object->v2 = PyInt_AsLong(value);
		return 0;
	}
	PyErr_SetString(PyExc_AttributeError, "no such attribute");
	return -1;
}

static PyTypeObject echo_info5_ObjectType = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "echo_info5",
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_dealloc = py_talloc_dealloc,
	.tp_getattr = py_echo_info5_getattr,
	.tp_setattr = py_echo_info5_setattr,
};

static PyObject *py_echo_info5(PyObject *self, PyObject *args)
{
	struct echo_info5 *ret = talloc_zero(NULL, struct echo_info5);
	return py_talloc_import(&echo_info5_ObjectType, ret);
}

staticforward PyTypeObject echo_info6_ObjectType;

static PyObject *py_echo_info6_getattr(PyObject *obj, char *name)
{
	struct echo_info6 *object = py_talloc_get_type(obj, struct echo_info6);
	if (!strcmp(name, "v1")) {
		return PyInt_FromLong(object->v1);
	}
	if (!strcmp(name, "info1")) {
		return py_talloc_import(&echo_info1_ObjectType, object->info1);
	}
	PyErr_SetString(PyExc_AttributeError, "no such attribute");
	return NULL;
}

static int py_echo_info6_setattr(PyObject *py_obj, char *name, PyObject *value)
{
	struct echo_info6 *object = py_talloc_get_type(py_obj, struct echo_info6);
	if (!strcmp(name, "v1")) {
		/* FIXME: talloc_free(object->v1) if necessary */
		object->v1 = PyInt_AsLong(value);
		return 0;
	}
	if (!strcmp(name, "info1")) {
		/* FIXME: talloc_free(object->info1) if necessary */
		object->info1 = py_talloc_get_type(value, struct echo_info1);
		return 0;
	}
	PyErr_SetString(PyExc_AttributeError, "no such attribute");
	return -1;
}

static PyTypeObject echo_info6_ObjectType = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "echo_info6",
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_dealloc = py_talloc_dealloc,
	.tp_getattr = py_echo_info6_getattr,
	.tp_setattr = py_echo_info6_setattr,
};

static PyObject *py_echo_info6(PyObject *self, PyObject *args)
{
	struct echo_info6 *ret = talloc_zero(NULL, struct echo_info6);
	return py_talloc_import(&echo_info6_ObjectType, ret);
}

staticforward PyTypeObject echo_info7_ObjectType;

static PyObject *py_echo_info7_getattr(PyObject *obj, char *name)
{
	struct echo_info7 *object = py_talloc_get_type(obj, struct echo_info7);
	if (!strcmp(name, "v1")) {
		return PyInt_FromLong(object->v1);
	}
	if (!strcmp(name, "info4")) {
		return py_talloc_import(&echo_info4_ObjectType, object->info4);
	}
	PyErr_SetString(PyExc_AttributeError, "no such attribute");
	return NULL;
}

static int py_echo_info7_setattr(PyObject *py_obj, char *name, PyObject *value)
{
	struct echo_info7 *object = py_talloc_get_type(py_obj, struct echo_info7);
	if (!strcmp(name, "v1")) {
		/* FIXME: talloc_free(object->v1) if necessary */
		object->v1 = PyInt_AsLong(value);
		return 0;
	}
	if (!strcmp(name, "info4")) {
		/* FIXME: talloc_free(object->info4) if necessary */
		object->info4 = py_talloc_get_type(value, struct echo_info4);
		return 0;
	}
	PyErr_SetString(PyExc_AttributeError, "no such attribute");
	return -1;
}

static PyTypeObject echo_info7_ObjectType = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "echo_info7",
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_dealloc = py_talloc_dealloc,
	.tp_getattr = py_echo_info7_getattr,
	.tp_setattr = py_echo_info7_setattr,
};

static PyObject *py_echo_info7(PyObject *self, PyObject *args)
{
	struct echo_info7 *ret = talloc_zero(NULL, struct echo_info7);
	return py_talloc_import(&echo_info7_ObjectType, ret);
}

PyObject *py_import_echo_Info(int level, union echo_Info *in)
{
	switch (level) {
		case 1: return py_talloc_import(&echo_info1_ObjectType, in->info1);
		case 2: return py_talloc_import(&echo_info2_ObjectType, in->info2);
		case 3: return py_talloc_import(&echo_info3_ObjectType, in->info3);
		case 4: return py_talloc_import(&echo_info4_ObjectType, in->info4);
		case 5: return py_talloc_import(&echo_info5_ObjectType, in->info5);
		case 6: return py_talloc_import(&echo_info6_ObjectType, in->info6);
		case 7: return py_talloc_import(&echo_info7_ObjectType, in->info7);
	}
	PyErr_SetString(PyExc_TypeError, "unknown union level");
	return NULL;
}

union echo_Info *py_export_echo_Info(TALLOC_CTX *mem_ctx, int level, PyObject *in)
{
	union echo_Info *ret = talloc_zero(mem_ctx, union echo_Info);
	switch (level) {
		case 1:
			ret->info1 = py_talloc_get_type(in, struct echo_info1);
			break;

		case 2:
			ret->info2 = py_talloc_get_type(in, struct echo_info2);
			break;

		case 3:
			ret->info3 = py_talloc_get_type(in, struct echo_info3);
			break;

		case 4:
			ret->info4 = py_talloc_get_type(in, struct echo_info4);
			break;

		case 5:
			ret->info5 = py_talloc_get_type(in, struct echo_info5);
			break;

		case 6:
			ret->info6 = py_talloc_get_type(in, struct echo_info6);
			break;

		case 7:
			ret->info7 = py_talloc_get_type(in, struct echo_info7);
			break;

		default:
			PyErr_SetString(PyExc_TypeError, "invalid union level value");
			talloc_free(ret);
			ret = NULL;
	}

	return ret;
}

staticforward PyTypeObject echo_Enum2_ObjectType;

static PyObject *py_echo_Enum2_getattr(PyObject *obj, char *name)
{
	struct echo_Enum2 *object = py_talloc_get_type(obj, struct echo_Enum2);
	if (!strcmp(name, "e1")) {
		return PyInt_FromLong(object->e1);
	}
	if (!strcmp(name, "e2")) {
		return PyInt_FromLong(object->e2);
	}
	PyErr_SetString(PyExc_AttributeError, "no such attribute");
	return NULL;
}

static int py_echo_Enum2_setattr(PyObject *py_obj, char *name, PyObject *value)
{
	struct echo_Enum2 *object = py_talloc_get_type(py_obj, struct echo_Enum2);
	if (!strcmp(name, "e1")) {
		/* FIXME: talloc_free(object->e1) if necessary */
		object->e1 = PyInt_AsLong(value);
		return 0;
	}
	if (!strcmp(name, "e2")) {
		/* FIXME: talloc_free(object->e2) if necessary */
		object->e2 = PyInt_AsLong(value);
		return 0;
	}
	PyErr_SetString(PyExc_AttributeError, "no such attribute");
	return -1;
}

static PyTypeObject echo_Enum2_ObjectType = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "echo_Enum2",
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_dealloc = py_talloc_dealloc,
	.tp_getattr = py_echo_Enum2_getattr,
	.tp_setattr = py_echo_Enum2_setattr,
};

static PyObject *py_echo_Enum2(PyObject *self, PyObject *args)
{
	struct echo_Enum2 *ret = talloc_zero(NULL, struct echo_Enum2);
	return py_talloc_import(&echo_Enum2_ObjectType, ret);
}

PyObject *py_import_echo_Enum3(int level, union echo_Enum3 *in)
{
	switch (level) {
		case ECHO_ENUM1: return PyInt_FromLong(in->e1);
		case ECHO_ENUM2: return py_talloc_import(&echo_Enum2_ObjectType, in->e2);
	}
	PyErr_SetString(PyExc_TypeError, "unknown union level");
	return NULL;
}

union echo_Enum3 *py_export_echo_Enum3(TALLOC_CTX *mem_ctx, int level, PyObject *in)
{
	union echo_Enum3 *ret = talloc_zero(mem_ctx, union echo_Enum3);
	switch (level) {
		case ECHO_ENUM1:
			ret->e1 = PyInt_AsLong(in);
			break;

		case ECHO_ENUM2:
			ret->e2 = py_talloc_get_type(in, struct echo_Enum2);
			break;

		default:
			PyErr_SetString(PyExc_TypeError, "invalid union level value");
			talloc_free(ret);
			ret = NULL;
	}

	return ret;
}

staticforward PyTypeObject echo_Surrounding_ObjectType;

static PyObject *py_echo_Surrounding_getattr(PyObject *obj, char *name)
{
	struct echo_Surrounding *object = py_talloc_get_type(obj, struct echo_Surrounding);
	if (!strcmp(name, "x")) {
		return PyInt_FromLong(object->x);
	}
	if (!strcmp(name, "surrounding")) {
		return PyInt_FromLong(object->surrounding);
	}
	PyErr_SetString(PyExc_AttributeError, "no such attribute");
	return NULL;
}

static int py_echo_Surrounding_setattr(PyObject *py_obj, char *name, PyObject *value)
{
	struct echo_Surrounding *object = py_talloc_get_type(py_obj, struct echo_Surrounding);
	if (!strcmp(name, "x")) {
		/* FIXME: talloc_free(object->x) if necessary */
		object->x = PyInt_AsLong(value);
		return 0;
	}
	if (!strcmp(name, "surrounding")) {
		/* FIXME: talloc_free(object->surrounding) if necessary */
		object->surrounding = PyInt_AsLong(value);
		return 0;
	}
	PyErr_SetString(PyExc_AttributeError, "no such attribute");
	return -1;
}

static PyTypeObject echo_Surrounding_ObjectType = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "echo_Surrounding",
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_dealloc = py_talloc_dealloc,
	.tp_getattr = py_echo_Surrounding_getattr,
	.tp_setattr = py_echo_Surrounding_setattr,
};

static PyObject *py_echo_Surrounding(PyObject *self, PyObject *args)
{
	struct echo_Surrounding *ret = talloc_zero(NULL, struct echo_Surrounding);
	return py_talloc_import(&echo_Surrounding_ObjectType, ret);
}

staticforward PyTypeObject rpcecho_InterfaceType;
typedef struct {
	PyObject_HEAD
	struct dcerpc_pipe *pipe;
} rpcecho_InterfaceObject;

static PyObject *py_echo_AddOne(PyObject *self, PyObject *args)
{
	rpcecho_InterfaceObject *iface = (rpcecho_InterfaceObject *)self;
	NTSTATUS status;
	TALLOC_CTX *mem_ctx = talloc_new(NULL);
	struct echo_AddOne r;
	PyObject *result;
	PyObject *py_in_data;

	ZERO_STRUCT(r.out);
	r.in.in_data = PyInt_AsLong(py_in_data);
	status = dcerpc_echo_AddOne(iface->pipe, mem_ctx, &r);
	if (NT_STATUS_IS_ERR(status)) {
		PyErr_SetString(PyExc_RuntimeError, nt_errstr(status));
		talloc_free(mem_ctx);
		return NULL;
	}

	result = PyTuple_New(1);
	PyTuple_SetItem(result, 0, PyInt_FromLong(r.out.out_data));
	talloc_free(mem_ctx);
	return result;
}

static PyObject *py_echo_EchoData(PyObject *self, PyObject *args)
{
	rpcecho_InterfaceObject *iface = (rpcecho_InterfaceObject *)self;
	NTSTATUS status;
	TALLOC_CTX *mem_ctx = talloc_new(NULL);
	struct echo_EchoData r;
	PyObject *result;
	PyObject *py_len;
	PyObject *py_in_data;

	ZERO_STRUCT(r.out);
	r.in.len = PyInt_AsLong(py_len);
	r.in.in_data = PyInt_AsLong(py_in_data);
	status = dcerpc_echo_EchoData(iface->pipe, mem_ctx, &r);
	if (NT_STATUS_IS_ERR(status)) {
		PyErr_SetString(PyExc_RuntimeError, nt_errstr(status));
		talloc_free(mem_ctx);
		return NULL;
	}

	result = PyTuple_New(1);
	PyTuple_SetItem(result, 0, PyInt_FromLong(r.out.out_data));
	talloc_free(mem_ctx);
	return result;
}

static PyObject *py_echo_SinkData(PyObject *self, PyObject *args)
{
	rpcecho_InterfaceObject *iface = (rpcecho_InterfaceObject *)self;
	NTSTATUS status;
	TALLOC_CTX *mem_ctx = talloc_new(NULL);
	struct echo_SinkData r;
	PyObject *result;
	PyObject *py_len;
	PyObject *py_data;
	r.in.len = PyInt_AsLong(py_len);
	r.in.data = PyInt_AsLong(py_data);
	status = dcerpc_echo_SinkData(iface->pipe, mem_ctx, &r);
	if (NT_STATUS_IS_ERR(status)) {
		PyErr_SetString(PyExc_RuntimeError, nt_errstr(status));
		talloc_free(mem_ctx);
		return NULL;
	}

	result = PyTuple_New(0);
	talloc_free(mem_ctx);
	return result;
}

static PyObject *py_echo_SourceData(PyObject *self, PyObject *args)
{
	rpcecho_InterfaceObject *iface = (rpcecho_InterfaceObject *)self;
	NTSTATUS status;
	TALLOC_CTX *mem_ctx = talloc_new(NULL);
	struct echo_SourceData r;
	PyObject *result;
	PyObject *py_len;

	ZERO_STRUCT(r.out);
	r.in.len = PyInt_AsLong(py_len);
	status = dcerpc_echo_SourceData(iface->pipe, mem_ctx, &r);
	if (NT_STATUS_IS_ERR(status)) {
		PyErr_SetString(PyExc_RuntimeError, nt_errstr(status));
		talloc_free(mem_ctx);
		return NULL;
	}

	result = PyTuple_New(1);
	PyTuple_SetItem(result, 0, PyInt_FromLong(r.out.data));
	talloc_free(mem_ctx);
	return result;
}

static PyObject *py_echo_TestCall(PyObject *self, PyObject *args)
{
	rpcecho_InterfaceObject *iface = (rpcecho_InterfaceObject *)self;
	NTSTATUS status;
	TALLOC_CTX *mem_ctx = talloc_new(NULL);
	struct echo_TestCall r;
	PyObject *result;
	PyObject *py_s1;

	ZERO_STRUCT(r.out);
	r.in.s1 = PyInt_AsLong(py_s1);
	status = dcerpc_echo_TestCall(iface->pipe, mem_ctx, &r);
	if (NT_STATUS_IS_ERR(status)) {
		PyErr_SetString(PyExc_RuntimeError, nt_errstr(status));
		talloc_free(mem_ctx);
		return NULL;
	}

	result = PyTuple_New(1);
	PyTuple_SetItem(result, 0, PyInt_FromLong(r.out.s2));
	talloc_free(mem_ctx);
	return result;
}

static PyObject *py_echo_TestCall2(PyObject *self, PyObject *args)
{
	rpcecho_InterfaceObject *iface = (rpcecho_InterfaceObject *)self;
	NTSTATUS status;
	TALLOC_CTX *mem_ctx = talloc_new(NULL);
	struct echo_TestCall2 r;
	PyObject *result;
	PyObject *py_level;

	ZERO_STRUCT(r.out);
	r.in.level = PyInt_AsLong(py_level);
	status = dcerpc_echo_TestCall2(iface->pipe, mem_ctx, &r);
	if (NT_STATUS_IS_ERR(status)) {
		PyErr_SetString(PyExc_RuntimeError, nt_errstr(status));
		talloc_free(mem_ctx);
		return NULL;
	}

	result = PyTuple_New(2);
	PyTuple_SetItem(result, 0, py_import_echo_Info(r.out.info));
	PyTuple_SetItem(result, 1, PyInt_FromLong(NT_STATUS_V(r.out.result)));
	talloc_free(mem_ctx);
	return result;
}

static PyObject *py_echo_TestSleep(PyObject *self, PyObject *args)
{
	rpcecho_InterfaceObject *iface = (rpcecho_InterfaceObject *)self;
	NTSTATUS status;
	TALLOC_CTX *mem_ctx = talloc_new(NULL);
	struct echo_TestSleep r;
	PyObject *result;
	PyObject *py_seconds;
	r.in.seconds = PyInt_AsLong(py_seconds);
	status = dcerpc_echo_TestSleep(iface->pipe, mem_ctx, &r);
	if (NT_STATUS_IS_ERR(status)) {
		PyErr_SetString(PyExc_RuntimeError, nt_errstr(status));
		talloc_free(mem_ctx);
		return NULL;
	}

	result = PyTuple_New(1);
	PyTuple_SetItem(result, 0, PyInt_FromLong(r.out.result));
	talloc_free(mem_ctx);
	return result;
}

static PyObject *py_echo_TestEnum(PyObject *self, PyObject *args)
{
	rpcecho_InterfaceObject *iface = (rpcecho_InterfaceObject *)self;
	NTSTATUS status;
	TALLOC_CTX *mem_ctx = talloc_new(NULL);
	struct echo_TestEnum r;
	PyObject *result;
	PyObject *py_foo1;
	PyObject *py_foo2;
	PyObject *py_foo3;

	ZERO_STRUCT(r.out);
	r.in.foo1 = PyInt_AsLong(py_foo1);
	r.in.foo2 = py_talloc_get_type(py_foo2, struct echo_Enum2);
	r.in.foo3 = py_export_echo_Enum3(py_foo3);
	status = dcerpc_echo_TestEnum(iface->pipe, mem_ctx, &r);
	if (NT_STATUS_IS_ERR(status)) {
		PyErr_SetString(PyExc_RuntimeError, nt_errstr(status));
		talloc_free(mem_ctx);
		return NULL;
	}

	result = PyTuple_New(3);
	PyTuple_SetItem(result, 0, PyInt_FromLong(r.out.foo1));
	PyTuple_SetItem(result, 1, py_talloc_import(&echo_Enum2_ObjectType, r.out.foo2));
	PyTuple_SetItem(result, 2, py_import_echo_Enum3(r.out.foo3));
	talloc_free(mem_ctx);
	return result;
}

static PyObject *py_echo_TestSurrounding(PyObject *self, PyObject *args)
{
	rpcecho_InterfaceObject *iface = (rpcecho_InterfaceObject *)self;
	NTSTATUS status;
	TALLOC_CTX *mem_ctx = talloc_new(NULL);
	struct echo_TestSurrounding r;
	PyObject *result;
	PyObject *py_data;

	ZERO_STRUCT(r.out);
	r.in.data = py_talloc_get_type(py_data, struct echo_Surrounding);
	status = dcerpc_echo_TestSurrounding(iface->pipe, mem_ctx, &r);
	if (NT_STATUS_IS_ERR(status)) {
		PyErr_SetString(PyExc_RuntimeError, nt_errstr(status));
		talloc_free(mem_ctx);
		return NULL;
	}

	result = PyTuple_New(1);
	PyTuple_SetItem(result, 0, py_talloc_import(&echo_Surrounding_ObjectType, r.out.data));
	talloc_free(mem_ctx);
	return result;
}

static PyObject *py_echo_TestDoublePointer(PyObject *self, PyObject *args)
{
	rpcecho_InterfaceObject *iface = (rpcecho_InterfaceObject *)self;
	NTSTATUS status;
	TALLOC_CTX *mem_ctx = talloc_new(NULL);
	struct echo_TestDoublePointer r;
	PyObject *result;
	PyObject *py_data;
	r.in.data = PyInt_AsLong(py_data);
	status = dcerpc_echo_TestDoublePointer(iface->pipe, mem_ctx, &r);
	if (NT_STATUS_IS_ERR(status)) {
		PyErr_SetString(PyExc_RuntimeError, nt_errstr(status));
		talloc_free(mem_ctx);
		return NULL;
	}

	result = PyTuple_New(1);
	PyTuple_SetItem(result, 0, PyInt_FromLong(r.out.result));
	talloc_free(mem_ctx);
	return result;
}

static PyMethodDef interface_rpcecho_methods[] = {
	{ "echo_AddOne", (PyCFunction)py_echo_AddOne, METH_VARARGS|METH_KEYWORDS, NULL },
	{ "echo_EchoData", (PyCFunction)py_echo_EchoData, METH_VARARGS|METH_KEYWORDS, NULL },
	{ "echo_SinkData", (PyCFunction)py_echo_SinkData, METH_VARARGS|METH_KEYWORDS, NULL },
	{ "echo_SourceData", (PyCFunction)py_echo_SourceData, METH_VARARGS|METH_KEYWORDS, NULL },
	{ "echo_TestCall", (PyCFunction)py_echo_TestCall, METH_VARARGS|METH_KEYWORDS, NULL },
	{ "echo_TestCall2", (PyCFunction)py_echo_TestCall2, METH_VARARGS|METH_KEYWORDS, NULL },
	{ "echo_TestSleep", (PyCFunction)py_echo_TestSleep, METH_VARARGS|METH_KEYWORDS, NULL },
	{ "echo_TestEnum", (PyCFunction)py_echo_TestEnum, METH_VARARGS|METH_KEYWORDS, NULL },
	{ "echo_TestSurrounding", (PyCFunction)py_echo_TestSurrounding, METH_VARARGS|METH_KEYWORDS, NULL },
	{ "echo_TestDoublePointer", (PyCFunction)py_echo_TestDoublePointer, METH_VARARGS|METH_KEYWORDS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void interface_rpcecho_dealloc(PyObject* self)
{
	rpcecho_InterfaceObject *interface = (rpcecho_InterfaceObject *)self;
	talloc_free(interface->pipe);
	PyObject_Del(self);
}

static PyObject *interface_rpcecho_getattr(PyObject *obj, char *name)
{
	return Py_FindMethod(interface_rpcecho_methods, obj, name);
}

static PyTypeObject rpcecho_InterfaceType = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "rpcecho",
	.tp_basicsize = sizeof(rpcecho_InterfaceObject),
	.tp_dealloc = (destructor)interface_rpcecho_dealloc,
	.tp_getattr = (getattrfunc)interface_rpcecho_getattr,
};

static PyObject *interface_rpcecho(PyObject *self, PyObject *args)
{
	rpcecho_InterfaceObject *ret;
	const char *binding_string;
	struct cli_credentials *credentials;
	struct loadparm_context *lp_ctx;
	TALLOC_CTX *mem_ctx = NULL;
	NTSTATUS status;

	ret = PyObject_New(rpcecho_InterfaceObject, &rpcecho_InterfaceType);

	status = dcerpc_pipe_connect(NULL, &ret->pipe, binding_string, 
	             &ndr_table_rpcecho, credentials, NULL, lp_ctx);
	if (NT_STATUS_IS_ERR(status)) {
		PyErr_SetString(PyExc_RuntimeError, nt_errstr(status));
		talloc_free(mem_ctx);
		return NULL;
	}

	return (PyObject *)ret;
}

static PyMethodDef echo_methods[] = {
	{ "info1", (PyCFunction)py_echo_info1, METH_NOARGS, NULL },
	{ "info2", (PyCFunction)py_echo_info2, METH_NOARGS, NULL },
	{ "info3", (PyCFunction)py_echo_info3, METH_NOARGS, NULL },
	{ "info4", (PyCFunction)py_echo_info4, METH_NOARGS, NULL },
	{ "info5", (PyCFunction)py_echo_info5, METH_NOARGS, NULL },
	{ "info6", (PyCFunction)py_echo_info6, METH_NOARGS, NULL },
	{ "info7", (PyCFunction)py_echo_info7, METH_NOARGS, NULL },
	{ "Enum2", (PyCFunction)py_echo_Enum2, METH_NOARGS, NULL },
	{ "Surrounding", (PyCFunction)py_echo_Surrounding, METH_NOARGS, NULL },
	{ "rpcecho", (PyCFunction)interface_rpcecho, METH_VARARGS|METH_KEYWORDS, NULL },
	{ NULL, NULL, 0, NULL }
};

void initecho(void)
{
	PyObject *m;
	m = Py_InitModule("echo", echo_methods);
	PyModule_AddObject(m, "ECHO_ENUM1", PyInt_FromLong(ECHO_ENUM1));
	PyModule_AddObject(m, "ECHO_ENUM2_32", PyInt_FromLong(ECHO_ENUM2_32));
	PyModule_AddObject(m, "ECHO_ENUM2", PyInt_FromLong(ECHO_ENUM2));
	PyModule_AddObject(m, "ECHO_ENUM1_32", PyInt_FromLong(ECHO_ENUM1_32));
}
