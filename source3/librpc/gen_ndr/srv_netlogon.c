/*
 * Unix SMB/CIFS implementation.
 * server auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "librpc/gen_ndr/srv_netlogon.h"

static BOOL api_netr_LogonUasLogon(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_LogonUasLogon r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_LogonUasLogon");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_LogonUasLogon(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_size(mem_ctx, sizeof(*r.out.info));
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_LogonUasLogon(p, r.in.server_name, r.in.account_name, r.in.workstation, r.out.info);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_LogonUasLogon(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_LogonUasLogoff(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_LogonUasLogoff r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_LogonUasLogoff");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_LogonUasLogoff(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_size(mem_ctx, sizeof(*r.out.info));
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_LogonUasLogoff(p, r.in.server_name, r.in.account_name, r.in.workstation, r.out.info);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_LogonUasLogoff(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_LogonSamLogon(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_LogonSamLogon r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_LogonSamLogon");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_LogonSamLogon(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.return_authenticator = r.in.return_authenticator;
	r.out.validation = talloc_size(mem_ctx, sizeof(*r.out.validation));
	if (r.out.validation == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.authoritative = talloc_size(mem_ctx, sizeof(*r.out.authoritative));
	if (r.out.authoritative == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_LogonSamLogon(p, r.in.server_name, r.in.computer_name, r.in.credential, r.in.return_authenticator, r.in.logon_level, r.in.logon, r.in.validation_level, r.out.validation, r.out.authoritative);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_LogonSamLogon(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_LogonSamLogoff(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_LogonSamLogoff r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_LogonSamLogoff");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_LogonSamLogoff(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.return_authenticator = r.in.return_authenticator;
	r.out.result = _netr_LogonSamLogoff(p, r.in.server_name, r.in.computer_name, r.in.credential, r.in.return_authenticator, r.in.logon_level, r.in.logon);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_LogonSamLogoff(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_ServerReqChallenge(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_ServerReqChallenge r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_ServerReqChallenge");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_ServerReqChallenge(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.credentials = r.in.credentials;
	r.out.result = _netr_ServerReqChallenge(p, r.in.server_name, r.in.computer_name, r.in.credentials);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_ServerReqChallenge(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_ServerAuthenticate(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_ServerAuthenticate r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_ServerAuthenticate");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_ServerAuthenticate(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.credentials = r.in.credentials;
	r.out.result = _netr_ServerAuthenticate(p, r.in.server_name, r.in.account_name, r.in.secure_channel_type, r.in.computer_name, r.in.credentials);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_ServerAuthenticate(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_ServerPasswordSet(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_ServerPasswordSet r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_ServerPasswordSet");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_ServerPasswordSet(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.return_authenticator = talloc_size(mem_ctx, sizeof(*r.out.return_authenticator));
	if (r.out.return_authenticator == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_ServerPasswordSet(p, r.in.server_name, r.in.account_name, r.in.secure_channel_type, r.in.computer_name, r.in.credential, r.in.new_password, r.out.return_authenticator);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_ServerPasswordSet(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_DatabaseDeltas(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_DatabaseDeltas r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_DatabaseDeltas");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_DatabaseDeltas(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.return_authenticator = r.in.return_authenticator;
	r.out.sequence_num = r.in.sequence_num;
	r.out.delta_enum_array = talloc_size(mem_ctx, sizeof(*r.out.delta_enum_array));
	if (r.out.delta_enum_array == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_DatabaseDeltas(p, r.in.logon_server, r.in.computername, r.in.credential, r.in.return_authenticator, r.in.database_id, r.in.sequence_num, r.in.preferredmaximumlength, r.out.delta_enum_array);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_DatabaseDeltas(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_DatabaseSync(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_DatabaseSync r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_DatabaseSync");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_DatabaseSync(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.return_authenticator = r.in.return_authenticator;
	r.out.sync_context = r.in.sync_context;
	r.out.delta_enum_array = talloc_size(mem_ctx, sizeof(*r.out.delta_enum_array));
	if (r.out.delta_enum_array == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_DatabaseSync(p, r.in.logon_server, r.in.computername, r.in.credential, r.in.return_authenticator, r.in.database_id, r.in.sync_context, r.in.preferredmaximumlength, r.out.delta_enum_array);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_DatabaseSync(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_AccountDeltas(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_AccountDeltas r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_AccountDeltas");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_AccountDeltas(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.return_authenticator = r.in.return_authenticator;
	r.out.buffer = talloc_size(mem_ctx, sizeof(*r.out.buffer));
	if (r.out.buffer == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.count_returned = talloc_size(mem_ctx, sizeof(*r.out.count_returned));
	if (r.out.count_returned == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.total_entries = talloc_size(mem_ctx, sizeof(*r.out.total_entries));
	if (r.out.total_entries == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.recordid = talloc_size(mem_ctx, sizeof(*r.out.recordid));
	if (r.out.recordid == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_AccountDeltas(p, r.in.logon_server, r.in.computername, r.in.credential, r.in.return_authenticator, r.in.uas, r.in.count, r.in.level, r.in.buffersize, r.out.buffer, r.out.count_returned, r.out.total_entries, r.out.recordid);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_AccountDeltas(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_AccountSync(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_AccountSync r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_AccountSync");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_AccountSync(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.return_authenticator = r.in.return_authenticator;
	r.out.buffer = talloc_size(mem_ctx, sizeof(*r.out.buffer));
	if (r.out.buffer == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.count_returned = talloc_size(mem_ctx, sizeof(*r.out.count_returned));
	if (r.out.count_returned == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.total_entries = talloc_size(mem_ctx, sizeof(*r.out.total_entries));
	if (r.out.total_entries == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.next_reference = talloc_size(mem_ctx, sizeof(*r.out.next_reference));
	if (r.out.next_reference == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.recordid = r.in.recordid;
	r.out.result = _netr_AccountSync(p, r.in.logon_server, r.in.computername, r.in.credential, r.in.return_authenticator, r.in.reference, r.in.level, r.in.buffersize, r.out.buffer, r.out.count_returned, r.out.total_entries, r.out.next_reference, r.in.recordid);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_AccountSync(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_GetDcName(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_GetDcName r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_GetDcName");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_GetDcName(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.dcname = talloc_size(mem_ctx, sizeof(*r.out.dcname));
	if (r.out.dcname == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_GetDcName(p, r.in.logon_server, r.in.domainname, r.out.dcname);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_GetDcName(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_LogonControl(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_LogonControl r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_LogonControl");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_LogonControl(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_size(mem_ctx, sizeof(*r.out.info));
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_LogonControl(p, r.in.logon_server, r.in.function_code, r.in.level, r.out.info);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_LogonControl(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_GetAnyDCName(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_GetAnyDCName r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_GetAnyDCName");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_GetAnyDCName(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.dcname = talloc_size(mem_ctx, sizeof(*r.out.dcname));
	if (r.out.dcname == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_GetAnyDCName(p, r.in.logon_server, r.in.domainname, r.out.dcname);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_GetAnyDCName(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_LogonControl2(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_LogonControl2 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_LogonControl2");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_LogonControl2(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.query = talloc_size(mem_ctx, sizeof(*r.out.query));
	if (r.out.query == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_LogonControl2(p, r.in.logon_server, r.in.function_code, r.in.level, r.in.data, r.out.query);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_LogonControl2(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_ServerAuthenticate2(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_ServerAuthenticate2 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_ServerAuthenticate2");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_ServerAuthenticate2(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.credentials = r.in.credentials;
	r.out.negotiate_flags = r.in.negotiate_flags;
	r.out.result = _netr_ServerAuthenticate2(p, r.in.server_name, r.in.account_name, r.in.secure_channel_type, r.in.computer_name, r.in.credentials, r.in.negotiate_flags);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_ServerAuthenticate2(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_DatabaseSync2(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_DatabaseSync2 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_DatabaseSync2");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_DatabaseSync2(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.return_authenticator = r.in.return_authenticator;
	r.out.sync_context = r.in.sync_context;
	r.out.delta_enum_array = talloc_size(mem_ctx, sizeof(*r.out.delta_enum_array));
	if (r.out.delta_enum_array == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_DatabaseSync2(p, r.in.logon_server, r.in.computername, r.in.credential, r.in.return_authenticator, r.in.database_id, r.in.restart_state, r.in.sync_context, r.in.preferredmaximumlength, r.out.delta_enum_array);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_DatabaseSync2(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_DatabaseRedo(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_DatabaseRedo r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_DatabaseRedo");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_DatabaseRedo(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.return_authenticator = r.in.return_authenticator;
	r.out.delta_enum_array = talloc_size(mem_ctx, sizeof(*r.out.delta_enum_array));
	if (r.out.delta_enum_array == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_DatabaseRedo(p, r.in.logon_server, r.in.computername, r.in.credential, r.in.return_authenticator, r.in.change_log_entry, r.in.change_log_entry_size, r.out.delta_enum_array);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_DatabaseRedo(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_LogonControl2Ex(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_LogonControl2Ex r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_LogonControl2Ex");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_LogonControl2Ex(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.query = talloc_size(mem_ctx, sizeof(*r.out.query));
	if (r.out.query == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_LogonControl2Ex(p, r.in.logon_server, r.in.function_code, r.in.level, r.in.data, r.out.query);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_LogonControl2Ex(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_NETRENUMERATETRUSTEDDOMAINS(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_NETRENUMERATETRUSTEDDOMAINS r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_NETRENUMERATETRUSTEDDOMAINS");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_NETRENUMERATETRUSTEDDOMAINS(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_NETRENUMERATETRUSTEDDOMAINS(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_NETRENUMERATETRUSTEDDOMAINS(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_DsRGetDCName(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_DsRGetDCName r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_DsRGetDCName");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_DsRGetDCName(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_size(mem_ctx, sizeof(*r.out.info));
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_DsRGetDCName(p, r.in.server_unc, r.in.domain_name, r.in.domain_guid, r.in.site_guid, r.in.flags, r.out.info);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_DsRGetDCName(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_NETRLOGONDUMMYROUTINE1(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_NETRLOGONDUMMYROUTINE1 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_NETRLOGONDUMMYROUTINE1");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_NETRLOGONDUMMYROUTINE1(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_NETRLOGONDUMMYROUTINE1(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_NETRLOGONDUMMYROUTINE1(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_NETRLOGONSETSERVICEBITS(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_NETRLOGONSETSERVICEBITS r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_NETRLOGONSETSERVICEBITS");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_NETRLOGONSETSERVICEBITS(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_NETRLOGONSETSERVICEBITS(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_NETRLOGONSETSERVICEBITS(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_NETRLOGONGETTRUSTRID(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_NETRLOGONGETTRUSTRID r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_NETRLOGONGETTRUSTRID");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_NETRLOGONGETTRUSTRID(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_NETRLOGONGETTRUSTRID(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_NETRLOGONGETTRUSTRID(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_NETRLOGONCOMPUTESERVERDIGEST(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_NETRLOGONCOMPUTESERVERDIGEST r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_NETRLOGONCOMPUTESERVERDIGEST");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_NETRLOGONCOMPUTESERVERDIGEST(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_NETRLOGONCOMPUTESERVERDIGEST(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_NETRLOGONCOMPUTESERVERDIGEST(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_NETRLOGONCOMPUTECLIENTDIGEST(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_NETRLOGONCOMPUTECLIENTDIGEST r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_NETRLOGONCOMPUTECLIENTDIGEST");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_NETRLOGONCOMPUTECLIENTDIGEST(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_NETRLOGONCOMPUTECLIENTDIGEST(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_NETRLOGONCOMPUTECLIENTDIGEST(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_ServerAuthenticate3(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_ServerAuthenticate3 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_ServerAuthenticate3");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_ServerAuthenticate3(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.credentials = r.in.credentials;
	r.out.negotiate_flags = r.in.negotiate_flags;
	r.out.rid = talloc_size(mem_ctx, sizeof(*r.out.rid));
	if (r.out.rid == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_ServerAuthenticate3(p, r.in.server_name, r.in.account_name, r.in.secure_channel_type, r.in.computer_name, r.in.credentials, r.in.negotiate_flags, r.out.rid);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_ServerAuthenticate3(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_DsRGetDCNameEx(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_DsRGetDCNameEx r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_DsRGetDCNameEx");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_DsRGetDCNameEx(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_size(mem_ctx, sizeof(*r.out.info));
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_DsRGetDCNameEx(p, r.in.server_unc, r.in.domain_name, r.in.domain_guid, r.in.site_name, r.in.flags, r.out.info);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_DsRGetDCNameEx(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_DsRGetSiteName(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_DsRGetSiteName r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_DsRGetSiteName");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_DsRGetSiteName(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.site = talloc_size(mem_ctx, sizeof(*r.out.site));
	if (r.out.site == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_DsRGetSiteName(p, r.in.computer_name, r.out.site);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_DsRGetSiteName(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_LogonGetDomainInfo(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_LogonGetDomainInfo r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_LogonGetDomainInfo");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_LogonGetDomainInfo(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.return_authenticator = r.in.return_authenticator;
	r.out.info = talloc_size(mem_ctx, sizeof(*r.out.info));
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_LogonGetDomainInfo(p, r.in.server_name, r.in.computer_name, r.in.credential, r.in.return_authenticator, r.in.level, r.in.query, r.out.info);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_LogonGetDomainInfo(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_ServerPasswordSet2(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_ServerPasswordSet2 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_ServerPasswordSet2");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_ServerPasswordSet2(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.return_authenticator = talloc_size(mem_ctx, sizeof(*r.out.return_authenticator));
	if (r.out.return_authenticator == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_ServerPasswordSet2(p, r.in.server_name, r.in.account_name, r.in.secure_channel_type, r.in.computer_name, r.in.credential, r.in.new_password, r.out.return_authenticator);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_ServerPasswordSet2(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_NETRSERVERPASSWORDGET(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_NETRSERVERPASSWORDGET r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_NETRSERVERPASSWORDGET");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_NETRSERVERPASSWORDGET(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_NETRSERVERPASSWORDGET(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_NETRSERVERPASSWORDGET(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_NETRLOGONSENDTOSAM(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_NETRLOGONSENDTOSAM r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_NETRLOGONSENDTOSAM");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_NETRLOGONSENDTOSAM(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_NETRLOGONSENDTOSAM(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_NETRLOGONSENDTOSAM(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_DSRADDRESSTOSITENAMESW(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_DSRADDRESSTOSITENAMESW r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_DSRADDRESSTOSITENAMESW");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_DSRADDRESSTOSITENAMESW(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_DSRADDRESSTOSITENAMESW(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_DSRADDRESSTOSITENAMESW(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_DsRGetDCNameEx2(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_DsRGetDCNameEx2 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_DsRGetDCNameEx2");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_DsRGetDCNameEx2(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_size(mem_ctx, sizeof(*r.out.info));
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_DsRGetDCNameEx2(p, r.in.server_unc, r.in.client_account, r.in.mask, r.in.domain_name, r.in.domain_guid, r.in.site_name, r.in.flags, r.out.info);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_DsRGetDCNameEx2(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_NETRLOGONGETTIMESERVICEPARENTDOMAIN(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_NETRLOGONGETTIMESERVICEPARENTDOMAIN r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_NETRLOGONGETTIMESERVICEPARENTDOMAIN");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_NETRLOGONGETTIMESERVICEPARENTDOMAIN(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_NETRLOGONGETTIMESERVICEPARENTDOMAIN(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_NETRLOGONGETTIMESERVICEPARENTDOMAIN(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_NETRENUMERATETRUSTEDDOMAINSEX(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_NETRENUMERATETRUSTEDDOMAINSEX r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_NETRENUMERATETRUSTEDDOMAINSEX");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_NETRENUMERATETRUSTEDDOMAINSEX(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_NETRENUMERATETRUSTEDDOMAINSEX(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_NETRENUMERATETRUSTEDDOMAINSEX(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_DSRADDRESSTOSITENAMESEXW(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_DSRADDRESSTOSITENAMESEXW r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_DSRADDRESSTOSITENAMESEXW");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_DSRADDRESSTOSITENAMESEXW(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_DSRADDRESSTOSITENAMESEXW(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_DSRADDRESSTOSITENAMESEXW(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_DSRGETDCSITECOVERAGEW(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_DSRGETDCSITECOVERAGEW r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_DSRGETDCSITECOVERAGEW");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_DSRGETDCSITECOVERAGEW(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_DSRGETDCSITECOVERAGEW(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_DSRGETDCSITECOVERAGEW(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_LogonSamLogonEx(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_LogonSamLogonEx r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_LogonSamLogonEx");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_LogonSamLogonEx(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.validation = talloc_size(mem_ctx, sizeof(*r.out.validation));
	if (r.out.validation == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.authoritative = talloc_size(mem_ctx, sizeof(*r.out.authoritative));
	if (r.out.authoritative == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.flags = r.in.flags;
	r.out.result = _netr_LogonSamLogonEx(p, r.in.server_name, r.in.computer_name, r.in.logon_level, r.in.logon, r.in.validation_level, r.out.validation, r.out.authoritative, r.in.flags);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_LogonSamLogonEx(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_DsrEnumerateDomainTrusts(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_DsrEnumerateDomainTrusts r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_DsrEnumerateDomainTrusts");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_DsrEnumerateDomainTrusts(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.count = talloc_size(mem_ctx, sizeof(*r.out.count));
	if (r.out.count == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.trusts = talloc_array_size(mem_ctx, sizeof(*r.out.trusts), count);
	if (r.out.trusts == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_DsrEnumerateDomainTrusts(p, r.in.server_name, r.in.trust_flags, r.out.count, r.out.trusts);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_DsrEnumerateDomainTrusts(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_DSRDEREGISTERDNSHOSTRECORDS(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_DSRDEREGISTERDNSHOSTRECORDS r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_DSRDEREGISTERDNSHOSTRECORDS");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_DSRDEREGISTERDNSHOSTRECORDS(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_DSRDEREGISTERDNSHOSTRECORDS(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_DSRDEREGISTERDNSHOSTRECORDS(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_NETRSERVERTRUSTPASSWORDSGET(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_NETRSERVERTRUSTPASSWORDSGET r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_NETRSERVERTRUSTPASSWORDSGET");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_NETRSERVERTRUSTPASSWORDSGET(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_NETRSERVERTRUSTPASSWORDSGET(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_NETRSERVERTRUSTPASSWORDSGET(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_DSRGETFORESTTRUSTINFORMATION(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_DSRGETFORESTTRUSTINFORMATION r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_DSRGETFORESTTRUSTINFORMATION");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_DSRGETFORESTTRUSTINFORMATION(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_DSRGETFORESTTRUSTINFORMATION(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_DSRGETFORESTTRUSTINFORMATION(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_NETRGETFORESTTRUSTINFORMATION(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_NETRGETFORESTTRUSTINFORMATION r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_NETRGETFORESTTRUSTINFORMATION");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_NETRGETFORESTTRUSTINFORMATION(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_NETRGETFORESTTRUSTINFORMATION(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_NETRGETFORESTTRUSTINFORMATION(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_LogonSamLogonWithFlags(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_LogonSamLogonWithFlags r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_LogonSamLogonWithFlags");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_LogonSamLogonWithFlags(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	ZERO_STRUCT(r.out);
	r.out.return_authenticator = r.in.return_authenticator;
	r.out.validation = talloc_size(mem_ctx, sizeof(*r.out.validation));
	if (r.out.validation == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.authoritative = talloc_size(mem_ctx, sizeof(*r.out.authoritative));
	if (r.out.authoritative == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.flags = r.in.flags;
	r.out.result = _netr_LogonSamLogonWithFlags(p, r.in.server_name, r.in.computer_name, r.in.credential, r.in.return_authenticator, r.in.logon_level, r.in.logon, r.in.validation_level, r.out.validation, r.out.authoritative, r.in.flags);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_LogonSamLogonWithFlags(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_netr_NETRSERVERGETTRUSTINFO(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct netr_NETRSERVERGETTRUSTINFO r;
	TALLOC_CTX *mem_ctx = talloc_init("api_netr_NETRSERVERGETTRUSTINFO");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL)
		return False;
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_netr_NETRSERVERGETTRUSTINFO(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _netr_NETRSERVERGETTRUSTINFO(p);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_netr_NETRSERVERGETTRUSTINFO(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_init_data_blob(&p->out_data.rdata, &blob, p->mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}


/* Tables */
static struct api_struct api_netlogon_cmds[] = 
{
	{"NETR_LOGONUASLOGON", DCERPC_NETR_LOGONUASLOGON, api_netr_LogonUasLogon},
	{"NETR_LOGONUASLOGOFF", DCERPC_NETR_LOGONUASLOGOFF, api_netr_LogonUasLogoff},
	{"NETR_LOGONSAMLOGON", DCERPC_NETR_LOGONSAMLOGON, api_netr_LogonSamLogon},
	{"NETR_LOGONSAMLOGOFF", DCERPC_NETR_LOGONSAMLOGOFF, api_netr_LogonSamLogoff},
	{"NETR_SERVERREQCHALLENGE", DCERPC_NETR_SERVERREQCHALLENGE, api_netr_ServerReqChallenge},
	{"NETR_SERVERAUTHENTICATE", DCERPC_NETR_SERVERAUTHENTICATE, api_netr_ServerAuthenticate},
	{"NETR_SERVERPASSWORDSET", DCERPC_NETR_SERVERPASSWORDSET, api_netr_ServerPasswordSet},
	{"NETR_DATABASEDELTAS", DCERPC_NETR_DATABASEDELTAS, api_netr_DatabaseDeltas},
	{"NETR_DATABASESYNC", DCERPC_NETR_DATABASESYNC, api_netr_DatabaseSync},
	{"NETR_ACCOUNTDELTAS", DCERPC_NETR_ACCOUNTDELTAS, api_netr_AccountDeltas},
	{"NETR_ACCOUNTSYNC", DCERPC_NETR_ACCOUNTSYNC, api_netr_AccountSync},
	{"NETR_GETDCNAME", DCERPC_NETR_GETDCNAME, api_netr_GetDcName},
	{"NETR_LOGONCONTROL", DCERPC_NETR_LOGONCONTROL, api_netr_LogonControl},
	{"NETR_GETANYDCNAME", DCERPC_NETR_GETANYDCNAME, api_netr_GetAnyDCName},
	{"NETR_LOGONCONTROL2", DCERPC_NETR_LOGONCONTROL2, api_netr_LogonControl2},
	{"NETR_SERVERAUTHENTICATE2", DCERPC_NETR_SERVERAUTHENTICATE2, api_netr_ServerAuthenticate2},
	{"NETR_DATABASESYNC2", DCERPC_NETR_DATABASESYNC2, api_netr_DatabaseSync2},
	{"NETR_DATABASEREDO", DCERPC_NETR_DATABASEREDO, api_netr_DatabaseRedo},
	{"NETR_LOGONCONTROL2EX", DCERPC_NETR_LOGONCONTROL2EX, api_netr_LogonControl2Ex},
	{"NETR_NETRENUMERATETRUSTEDDOMAINS", DCERPC_NETR_NETRENUMERATETRUSTEDDOMAINS, api_netr_NETRENUMERATETRUSTEDDOMAINS},
	{"NETR_DSRGETDCNAME", DCERPC_NETR_DSRGETDCNAME, api_netr_DsRGetDCName},
	{"NETR_NETRLOGONDUMMYROUTINE1", DCERPC_NETR_NETRLOGONDUMMYROUTINE1, api_netr_NETRLOGONDUMMYROUTINE1},
	{"NETR_NETRLOGONSETSERVICEBITS", DCERPC_NETR_NETRLOGONSETSERVICEBITS, api_netr_NETRLOGONSETSERVICEBITS},
	{"NETR_NETRLOGONGETTRUSTRID", DCERPC_NETR_NETRLOGONGETTRUSTRID, api_netr_NETRLOGONGETTRUSTRID},
	{"NETR_NETRLOGONCOMPUTESERVERDIGEST", DCERPC_NETR_NETRLOGONCOMPUTESERVERDIGEST, api_netr_NETRLOGONCOMPUTESERVERDIGEST},
	{"NETR_NETRLOGONCOMPUTECLIENTDIGEST", DCERPC_NETR_NETRLOGONCOMPUTECLIENTDIGEST, api_netr_NETRLOGONCOMPUTECLIENTDIGEST},
	{"NETR_SERVERAUTHENTICATE3", DCERPC_NETR_SERVERAUTHENTICATE3, api_netr_ServerAuthenticate3},
	{"NETR_DSRGETDCNAMEEX", DCERPC_NETR_DSRGETDCNAMEEX, api_netr_DsRGetDCNameEx},
	{"NETR_DSRGETSITENAME", DCERPC_NETR_DSRGETSITENAME, api_netr_DsRGetSiteName},
	{"NETR_LOGONGETDOMAININFO", DCERPC_NETR_LOGONGETDOMAININFO, api_netr_LogonGetDomainInfo},
	{"NETR_SERVERPASSWORDSET2", DCERPC_NETR_SERVERPASSWORDSET2, api_netr_ServerPasswordSet2},
	{"NETR_NETRSERVERPASSWORDGET", DCERPC_NETR_NETRSERVERPASSWORDGET, api_netr_NETRSERVERPASSWORDGET},
	{"NETR_NETRLOGONSENDTOSAM", DCERPC_NETR_NETRLOGONSENDTOSAM, api_netr_NETRLOGONSENDTOSAM},
	{"NETR_DSRADDRESSTOSITENAMESW", DCERPC_NETR_DSRADDRESSTOSITENAMESW, api_netr_DSRADDRESSTOSITENAMESW},
	{"NETR_DSRGETDCNAMEEX2", DCERPC_NETR_DSRGETDCNAMEEX2, api_netr_DsRGetDCNameEx2},
	{"NETR_NETRLOGONGETTIMESERVICEPARENTDOMAIN", DCERPC_NETR_NETRLOGONGETTIMESERVICEPARENTDOMAIN, api_netr_NETRLOGONGETTIMESERVICEPARENTDOMAIN},
	{"NETR_NETRENUMERATETRUSTEDDOMAINSEX", DCERPC_NETR_NETRENUMERATETRUSTEDDOMAINSEX, api_netr_NETRENUMERATETRUSTEDDOMAINSEX},
	{"NETR_DSRADDRESSTOSITENAMESEXW", DCERPC_NETR_DSRADDRESSTOSITENAMESEXW, api_netr_DSRADDRESSTOSITENAMESEXW},
	{"NETR_DSRGETDCSITECOVERAGEW", DCERPC_NETR_DSRGETDCSITECOVERAGEW, api_netr_DSRGETDCSITECOVERAGEW},
	{"NETR_LOGONSAMLOGONEX", DCERPC_NETR_LOGONSAMLOGONEX, api_netr_LogonSamLogonEx},
	{"NETR_DSRENUMERATEDOMAINTRUSTS", DCERPC_NETR_DSRENUMERATEDOMAINTRUSTS, api_netr_DsrEnumerateDomainTrusts},
	{"NETR_DSRDEREGISTERDNSHOSTRECORDS", DCERPC_NETR_DSRDEREGISTERDNSHOSTRECORDS, api_netr_DSRDEREGISTERDNSHOSTRECORDS},
	{"NETR_NETRSERVERTRUSTPASSWORDSGET", DCERPC_NETR_NETRSERVERTRUSTPASSWORDSGET, api_netr_NETRSERVERTRUSTPASSWORDSGET},
	{"NETR_DSRGETFORESTTRUSTINFORMATION", DCERPC_NETR_DSRGETFORESTTRUSTINFORMATION, api_netr_DSRGETFORESTTRUSTINFORMATION},
	{"NETR_NETRGETFORESTTRUSTINFORMATION", DCERPC_NETR_NETRGETFORESTTRUSTINFORMATION, api_netr_NETRGETFORESTTRUSTINFORMATION},
	{"NETR_LOGONSAMLOGONWITHFLAGS", DCERPC_NETR_LOGONSAMLOGONWITHFLAGS, api_netr_LogonSamLogonWithFlags},
	{"NETR_NETRSERVERGETTRUSTINFO", DCERPC_NETR_NETRSERVERGETTRUSTINFO, api_netr_NETRSERVERGETTRUSTINFO},
};

void netlogon_get_pipe_fns(struct api_struct **fns, int *n_fns)
{
	*fns = api_netlogon_cmds;
	*n_fns = sizeof(api_netlogon_cmds) / sizeof(struct api_struct);
}

NTSTATUS rpc_netlogon_init(void)
{
	return rpc_pipe_register_commands(SMB_RPC_INTERFACE_VERSION, "netlogon", "netlogon", api_netlogon_cmds, sizeof(api_netlogon_cmds) / sizeof(struct api_struct));
}
