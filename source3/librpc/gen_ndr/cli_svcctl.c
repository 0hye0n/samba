/*
 * Unix SMB/CIFS implementation.
 * client auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "librpc/gen_ndr/cli_svcctl.h"

NTSTATUS rpccli_svcctl_CloseServiceHandle(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle)
{
	struct svcctl_CloseServiceHandle r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_CloseServiceHandle, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_CLOSESERVICEHANDLE, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_CloseServiceHandle, (ndr_push_flags_fn_t)ndr_push_svcctl_CloseServiceHandle);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_CloseServiceHandle, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*handle = *r.out.handle;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_ControlService(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t control, struct SERVICE_STATUS *status)
{
	struct svcctl_ControlService r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.control = control;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_ControlService, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_CONTROLSERVICE, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_ControlService, (ndr_push_flags_fn_t)ndr_push_svcctl_ControlService);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_ControlService, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*status = *r.out.status;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_DeleteService(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle)
{
	struct svcctl_DeleteService r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_DeleteService, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_DELETESERVICE, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_DeleteService, (ndr_push_flags_fn_t)ndr_push_svcctl_DeleteService);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_DeleteService, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_LockServiceDatabase(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, struct policy_handle *lock)
{
	struct svcctl_LockServiceDatabase r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_LockServiceDatabase, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_LOCKSERVICEDATABASE, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_LockServiceDatabase, (ndr_push_flags_fn_t)ndr_push_svcctl_LockServiceDatabase);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_LockServiceDatabase, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*lock = *r.out.lock;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_QueryServiceObjectSecurity(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx)
{
	struct svcctl_QueryServiceObjectSecurity r;
	NTSTATUS status;
	
	/* In parameters */
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceObjectSecurity, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_QUERYSERVICEOBJECTSECURITY, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_QueryServiceObjectSecurity, (ndr_push_flags_fn_t)ndr_push_svcctl_QueryServiceObjectSecurity);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceObjectSecurity, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_SetServiceObjectSecurity(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx)
{
	struct svcctl_SetServiceObjectSecurity r;
	NTSTATUS status;
	
	/* In parameters */
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_SetServiceObjectSecurity, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_SETSERVICEOBJECTSECURITY, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_SetServiceObjectSecurity, (ndr_push_flags_fn_t)ndr_push_svcctl_SetServiceObjectSecurity);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_SetServiceObjectSecurity, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_QueryServiceStatus(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, struct SERVICE_STATUS *status)
{
	struct svcctl_QueryServiceStatus r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceStatus, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_QUERYSERVICESTATUS, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_QueryServiceStatus, (ndr_push_flags_fn_t)ndr_push_svcctl_QueryServiceStatus);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceStatus, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*status = *r.out.status;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_SetServiceStatus(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx)
{
	struct svcctl_SetServiceStatus r;
	NTSTATUS status;
	
	/* In parameters */
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_SetServiceStatus, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_SETSERVICESTATUS, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_SetServiceStatus, (ndr_push_flags_fn_t)ndr_push_svcctl_SetServiceStatus);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_SetServiceStatus, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_UnlockServiceDatabase(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *lock)
{
	struct svcctl_UnlockServiceDatabase r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.lock = lock;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_UnlockServiceDatabase, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_UNLOCKSERVICEDATABASE, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_UnlockServiceDatabase, (ndr_push_flags_fn_t)ndr_push_svcctl_UnlockServiceDatabase);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_UnlockServiceDatabase, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*lock = *r.out.lock;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_NotifyBootConfigStatus(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx)
{
	struct svcctl_NotifyBootConfigStatus r;
	NTSTATUS status;
	
	/* In parameters */
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_NotifyBootConfigStatus, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_NOTIFYBOOTCONFIGSTATUS, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_NotifyBootConfigStatus, (ndr_push_flags_fn_t)ndr_push_svcctl_NotifyBootConfigStatus);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_NotifyBootConfigStatus, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_SCSetServiceBitsW(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t bits, uint32_t bitson, uint32_t immediate)
{
	struct svcctl_SCSetServiceBitsW r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.bits = bits;
	r.in.bitson = bitson;
	r.in.immediate = immediate;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_SCSetServiceBitsW, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_SCSETSERVICEBITSW, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_SCSetServiceBitsW, (ndr_push_flags_fn_t)ndr_push_svcctl_SCSetServiceBitsW);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_SCSetServiceBitsW, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_ChangeServiceConfigW(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t type, uint32_t start, uint32_t error, const char *binary_path, const char *load_order_group, uint32_t *tag_id, const char *dependencies, const char *service_start_name, const char *password, const char *display_name)
{
	struct svcctl_ChangeServiceConfigW r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.type = type;
	r.in.start = start;
	r.in.error = error;
	r.in.binary_path = binary_path;
	r.in.load_order_group = load_order_group;
	r.in.dependencies = dependencies;
	r.in.service_start_name = service_start_name;
	r.in.password = password;
	r.in.display_name = display_name;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_ChangeServiceConfigW, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_CHANGESERVICECONFIGW, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_ChangeServiceConfigW, (ndr_push_flags_fn_t)ndr_push_svcctl_ChangeServiceConfigW);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_ChangeServiceConfigW, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*tag_id = *r.out.tag_id;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_CreateServiceW(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *scmanager_handle, const char *ServiceName, const char *DisplayName, uint32_t desired_access, uint32_t type, uint32_t start_type, uint32_t error_control, const char *binary_path, const char *LoadOrderGroupKey, uint32_t *TagId, uint8_t *dependencies, uint32_t dependencies_size, const char *service_start_name, uint8_t *password, uint32_t password_size, struct policy_handle *handle)
{
	struct svcctl_CreateServiceW r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.scmanager_handle = scmanager_handle;
	r.in.ServiceName = ServiceName;
	r.in.DisplayName = DisplayName;
	r.in.desired_access = desired_access;
	r.in.type = type;
	r.in.start_type = start_type;
	r.in.error_control = error_control;
	r.in.binary_path = binary_path;
	r.in.LoadOrderGroupKey = LoadOrderGroupKey;
	r.in.TagId = TagId;
	r.in.dependencies = dependencies;
	r.in.dependencies_size = dependencies_size;
	r.in.service_start_name = service_start_name;
	r.in.password = password;
	r.in.password_size = password_size;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_CreateServiceW, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_CREATESERVICEW, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_CreateServiceW, (ndr_push_flags_fn_t)ndr_push_svcctl_CreateServiceW);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_CreateServiceW, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	if ( TagId ) {
		*TagId = *r.out.TagId;
	}
	*handle = *r.out.handle;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_EnumDependentServicesW(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *service, uint32_t state, struct ENUM_SERVICE_STATUS *status, uint32_t buf_size, uint32_t *bytes_needed, uint32_t *services_returned)
{
	struct svcctl_EnumDependentServicesW r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.service = service;
	r.in.state = state;
	r.in.buf_size = buf_size;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_EnumDependentServicesW, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_ENUMDEPENDENTSERVICESW, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_EnumDependentServicesW, (ndr_push_flags_fn_t)ndr_push_svcctl_EnumDependentServicesW);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_EnumDependentServicesW, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	if ( status ) {
		*status = *r.out.status;
	}
	*bytes_needed = *r.out.bytes_needed;
	*services_returned = *r.out.services_returned;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_EnumServicesStatusW(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t type, uint32_t state, uint32_t buf_size, uint8_t *service, uint32_t *bytes_needed, uint32_t *services_returned, uint32_t *resume_handle)
{
	struct svcctl_EnumServicesStatusW r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.type = type;
	r.in.state = state;
	r.in.buf_size = buf_size;
	r.in.resume_handle = resume_handle;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_EnumServicesStatusW, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_ENUMSERVICESSTATUSW, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_EnumServicesStatusW, (ndr_push_flags_fn_t)ndr_push_svcctl_EnumServicesStatusW);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_EnumServicesStatusW, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*service = *r.out.service;
	*bytes_needed = *r.out.bytes_needed;
	*services_returned = *r.out.services_returned;
	if ( resume_handle ) {
		*resume_handle = *r.out.resume_handle;
	}
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_OpenSCManagerW(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, const char *MachineName, const char *DatabaseName, uint32_t access_mask, struct policy_handle *handle)
{
	struct svcctl_OpenSCManagerW r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.MachineName = MachineName;
	r.in.DatabaseName = DatabaseName;
	r.in.access_mask = access_mask;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_OpenSCManagerW, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_OPENSCMANAGERW, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_OpenSCManagerW, (ndr_push_flags_fn_t)ndr_push_svcctl_OpenSCManagerW);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_OpenSCManagerW, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*handle = *r.out.handle;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_OpenServiceW(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *scmanager_handle, const char *ServiceName, uint32_t access_mask, struct policy_handle *handle)
{
	struct svcctl_OpenServiceW r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.scmanager_handle = scmanager_handle;
	r.in.ServiceName = ServiceName;
	r.in.access_mask = access_mask;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_OpenServiceW, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_OPENSERVICEW, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_OpenServiceW, (ndr_push_flags_fn_t)ndr_push_svcctl_OpenServiceW);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_OpenServiceW, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*handle = *r.out.handle;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_QueryServiceConfigW(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint8_t *query, uint32_t buf_size, uint32_t *bytes_needed)
{
	struct svcctl_QueryServiceConfigW r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.buf_size = buf_size;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceConfigW, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_QUERYSERVICECONFIGW, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_QueryServiceConfigW, (ndr_push_flags_fn_t)ndr_push_svcctl_QueryServiceConfigW);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceConfigW, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*query = *r.out.query;
	*bytes_needed = *r.out.bytes_needed;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_QueryServiceLockStatusW(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t buf_size, struct SERVICE_LOCK_STATUS *status, uint32_t *required_buf_size)
{
	struct svcctl_QueryServiceLockStatusW r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.buf_size = buf_size;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceLockStatusW, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_QUERYSERVICELOCKSTATUSW, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_QueryServiceLockStatusW, (ndr_push_flags_fn_t)ndr_push_svcctl_QueryServiceLockStatusW);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceLockStatusW, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*status = *r.out.status;
	*required_buf_size = *r.out.required_buf_size;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_StartServiceW(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t NumArgs, const char *Arguments)
{
	struct svcctl_StartServiceW r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.NumArgs = NumArgs;
	r.in.Arguments = Arguments;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_StartServiceW, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_STARTSERVICEW, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_StartServiceW, (ndr_push_flags_fn_t)ndr_push_svcctl_StartServiceW);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_StartServiceW, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_GetServiceDisplayNameW(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, const char *service_name, const char **display_name, uint32_t *display_name_length)
{
	struct svcctl_GetServiceDisplayNameW r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.service_name = service_name;
	r.in.display_name_length = display_name_length;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_GetServiceDisplayNameW, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_GETSERVICEDISPLAYNAMEW, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_GetServiceDisplayNameW, (ndr_push_flags_fn_t)ndr_push_svcctl_GetServiceDisplayNameW);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_GetServiceDisplayNameW, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*display_name = *r.out.display_name;
	if ( display_name_length ) {
		*display_name_length = *r.out.display_name_length;
	}
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_GetServiceKeyNameW(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, const char *service_name, const char **key_name, uint32_t *display_name_length)
{
	struct svcctl_GetServiceKeyNameW r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.service_name = service_name;
	r.in.display_name_length = display_name_length;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_GetServiceKeyNameW, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_GETSERVICEKEYNAMEW, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_GetServiceKeyNameW, (ndr_push_flags_fn_t)ndr_push_svcctl_GetServiceKeyNameW);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_GetServiceKeyNameW, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*key_name = *r.out.key_name;
	if ( display_name_length ) {
		*display_name_length = *r.out.display_name_length;
	}
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_SCSetServiceBitsA(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t bits, uint32_t bitson, uint32_t immediate)
{
	struct svcctl_SCSetServiceBitsA r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.bits = bits;
	r.in.bitson = bitson;
	r.in.immediate = immediate;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_SCSetServiceBitsA, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_SCSETSERVICEBITSA, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_SCSetServiceBitsA, (ndr_push_flags_fn_t)ndr_push_svcctl_SCSetServiceBitsA);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_SCSetServiceBitsA, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_ChangeServiceConfigA(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t type, uint32_t start, uint32_t error, const char *binary_path, const char *load_order_group, uint32_t *tag_id, const char *dependencies, const char *service_start_name, const char *password, const char *display_name)
{
	struct svcctl_ChangeServiceConfigA r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.type = type;
	r.in.start = start;
	r.in.error = error;
	r.in.binary_path = binary_path;
	r.in.load_order_group = load_order_group;
	r.in.dependencies = dependencies;
	r.in.service_start_name = service_start_name;
	r.in.password = password;
	r.in.display_name = display_name;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_ChangeServiceConfigA, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_CHANGESERVICECONFIGA, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_ChangeServiceConfigA, (ndr_push_flags_fn_t)ndr_push_svcctl_ChangeServiceConfigA);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_ChangeServiceConfigA, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*tag_id = *r.out.tag_id;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_CreateServiceA(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, const char *ServiceName, const char *DisplayName, uint32_t desired_access, uint32_t type, uint32_t start_type, uint32_t error_control, const char *binary_path, const char *LoadOrderGroupKey, uint32_t *TagId, const char *dependencies, const char *service_start_name, const char *password)
{
	struct svcctl_CreateServiceA r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.ServiceName = ServiceName;
	r.in.DisplayName = DisplayName;
	r.in.desired_access = desired_access;
	r.in.type = type;
	r.in.start_type = start_type;
	r.in.error_control = error_control;
	r.in.binary_path = binary_path;
	r.in.LoadOrderGroupKey = LoadOrderGroupKey;
	r.in.dependencies = dependencies;
	r.in.service_start_name = service_start_name;
	r.in.password = password;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_CreateServiceA, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_CREATESERVICEA, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_CreateServiceA, (ndr_push_flags_fn_t)ndr_push_svcctl_CreateServiceA);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_CreateServiceA, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	if ( TagId ) {
		*TagId = *r.out.TagId;
	}
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_EnumDependentServicesA(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *service, uint32_t state, struct ENUM_SERVICE_STATUS *status, uint32_t buf_size, uint32_t *bytes_needed, uint32_t *services_returned)
{
	struct svcctl_EnumDependentServicesA r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.service = service;
	r.in.state = state;
	r.in.buf_size = buf_size;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_EnumDependentServicesA, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_ENUMDEPENDENTSERVICESA, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_EnumDependentServicesA, (ndr_push_flags_fn_t)ndr_push_svcctl_EnumDependentServicesA);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_EnumDependentServicesA, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	if ( status ) {
		*status = *r.out.status;
	}
	*bytes_needed = *r.out.bytes_needed;
	*services_returned = *r.out.services_returned;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_EnumServicesStatusA(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t type, uint32_t state, uint32_t buf_size, uint8_t *service, uint32_t *bytes_needed, uint32_t *services_returned, uint32_t *resume_handle)
{
	struct svcctl_EnumServicesStatusA r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.type = type;
	r.in.state = state;
	r.in.buf_size = buf_size;
	r.in.resume_handle = resume_handle;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_EnumServicesStatusA, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_ENUMSERVICESSTATUSA, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_EnumServicesStatusA, (ndr_push_flags_fn_t)ndr_push_svcctl_EnumServicesStatusA);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_EnumServicesStatusA, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*service = *r.out.service;
	*bytes_needed = *r.out.bytes_needed;
	*services_returned = *r.out.services_returned;
	if ( resume_handle ) {
		*resume_handle = *r.out.resume_handle;
	}
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_OpenSCManagerA(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, const char *MachineName, const char *DatabaseName, uint32_t access_mask, struct policy_handle *handle)
{
	struct svcctl_OpenSCManagerA r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.MachineName = MachineName;
	r.in.DatabaseName = DatabaseName;
	r.in.access_mask = access_mask;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_OpenSCManagerA, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_OPENSCMANAGERA, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_OpenSCManagerA, (ndr_push_flags_fn_t)ndr_push_svcctl_OpenSCManagerA);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_OpenSCManagerA, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*handle = *r.out.handle;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_OpenServiceA(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *scmanager_handle, const char *ServiceName, uint32_t access_mask)
{
	struct svcctl_OpenServiceA r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.scmanager_handle = scmanager_handle;
	r.in.ServiceName = ServiceName;
	r.in.access_mask = access_mask;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_OpenServiceA, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_OPENSERVICEA, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_OpenServiceA, (ndr_push_flags_fn_t)ndr_push_svcctl_OpenServiceA);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_OpenServiceA, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_QueryServiceConfigA(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint8_t *query, uint32_t buf_size, uint32_t *bytes_needed)
{
	struct svcctl_QueryServiceConfigA r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.buf_size = buf_size;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceConfigA, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_QUERYSERVICECONFIGA, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_QueryServiceConfigA, (ndr_push_flags_fn_t)ndr_push_svcctl_QueryServiceConfigA);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceConfigA, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*query = *r.out.query;
	*bytes_needed = *r.out.bytes_needed;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_QueryServiceLockStatusA(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t buf_size, struct SERVICE_LOCK_STATUS *status, uint32_t *required_buf_size)
{
	struct svcctl_QueryServiceLockStatusA r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.buf_size = buf_size;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceLockStatusA, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_QUERYSERVICELOCKSTATUSA, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_QueryServiceLockStatusA, (ndr_push_flags_fn_t)ndr_push_svcctl_QueryServiceLockStatusA);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceLockStatusA, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*status = *r.out.status;
	*required_buf_size = *r.out.required_buf_size;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_StartServiceA(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t NumArgs, const char *Arguments)
{
	struct svcctl_StartServiceA r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.NumArgs = NumArgs;
	r.in.Arguments = Arguments;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_StartServiceA, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_STARTSERVICEA, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_StartServiceA, (ndr_push_flags_fn_t)ndr_push_svcctl_StartServiceA);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_StartServiceA, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_GetServiceDisplayNameA(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, const char *service_name, const char **display_name, uint32_t *display_name_length)
{
	struct svcctl_GetServiceDisplayNameA r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.service_name = service_name;
	r.in.display_name_length = display_name_length;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_GetServiceDisplayNameA, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_GETSERVICEDISPLAYNAMEA, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_GetServiceDisplayNameA, (ndr_push_flags_fn_t)ndr_push_svcctl_GetServiceDisplayNameA);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_GetServiceDisplayNameA, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*display_name = *r.out.display_name;
	if ( display_name_length ) {
		*display_name_length = *r.out.display_name_length;
	}
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_GetServiceKeyNameA(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, const char *service_name, const char **key_name, uint32_t *display_name_length)
{
	struct svcctl_GetServiceKeyNameA r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.service_name = service_name;
	r.in.display_name_length = display_name_length;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_GetServiceKeyNameA, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_GETSERVICEKEYNAMEA, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_GetServiceKeyNameA, (ndr_push_flags_fn_t)ndr_push_svcctl_GetServiceKeyNameA);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_GetServiceKeyNameA, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*key_name = *r.out.key_name;
	if ( display_name_length ) {
		*display_name_length = *r.out.display_name_length;
	}
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_GetCurrentGroupeStateW(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx)
{
	struct svcctl_GetCurrentGroupeStateW r;
	NTSTATUS status;
	
	/* In parameters */
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_GetCurrentGroupeStateW, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_GETCURRENTGROUPESTATEW, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_GetCurrentGroupeStateW, (ndr_push_flags_fn_t)ndr_push_svcctl_GetCurrentGroupeStateW);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_GetCurrentGroupeStateW, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_EnumServiceGroupW(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx)
{
	struct svcctl_EnumServiceGroupW r;
	NTSTATUS status;
	
	/* In parameters */
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_EnumServiceGroupW, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_ENUMSERVICEGROUPW, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_EnumServiceGroupW, (ndr_push_flags_fn_t)ndr_push_svcctl_EnumServiceGroupW);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_EnumServiceGroupW, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_ChangeServiceConfig2A(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t info_level, uint8_t *info)
{
	struct svcctl_ChangeServiceConfig2A r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.info_level = info_level;
	r.in.info = info;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_ChangeServiceConfig2A, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_CHANGESERVICECONFIG2A, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_ChangeServiceConfig2A, (ndr_push_flags_fn_t)ndr_push_svcctl_ChangeServiceConfig2A);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_ChangeServiceConfig2A, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_ChangeServiceConfig2W(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t info_level, uint8_t *info)
{
	struct svcctl_ChangeServiceConfig2W r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.info_level = info_level;
	r.in.info = info;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_ChangeServiceConfig2W, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_CHANGESERVICECONFIG2W, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_ChangeServiceConfig2W, (ndr_push_flags_fn_t)ndr_push_svcctl_ChangeServiceConfig2W);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_ChangeServiceConfig2W, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_QueryServiceConfig2A(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t info_level, uint8_t *buffer, uint32_t buf_size, uint32_t *bytes_needed)
{
	struct svcctl_QueryServiceConfig2A r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.info_level = info_level;
	r.in.buf_size = buf_size;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceConfig2A, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_QUERYSERVICECONFIG2A, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_QueryServiceConfig2A, (ndr_push_flags_fn_t)ndr_push_svcctl_QueryServiceConfig2A);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceConfig2A, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*buffer = *r.out.buffer;
	*bytes_needed = *r.out.bytes_needed;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_QueryServiceConfig2W(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t info_level, uint8_t *buffer, uint32_t buf_size, uint32_t *bytes_needed)
{
	struct svcctl_QueryServiceConfig2W r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.info_level = info_level;
	r.in.buf_size = buf_size;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceConfig2W, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_QUERYSERVICECONFIG2W, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_QueryServiceConfig2W, (ndr_push_flags_fn_t)ndr_push_svcctl_QueryServiceConfig2W);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceConfig2W, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*buffer = *r.out.buffer;
	*bytes_needed = *r.out.bytes_needed;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_QueryServiceStatusEx(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *handle, uint32_t info_level, uint8_t *buffer, uint32_t buf_size, uint32_t *bytes_needed)
{
	struct svcctl_QueryServiceStatusEx r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.handle = handle;
	r.in.info_level = info_level;
	r.in.buf_size = buf_size;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceStatusEx, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_QUERYSERVICESTATUSEX, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_QueryServiceStatusEx, (ndr_push_flags_fn_t)ndr_push_svcctl_QueryServiceStatusEx);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceStatusEx, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*buffer = *r.out.buffer;
	*bytes_needed = *r.out.bytes_needed;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_EnumServicesStatusExA(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *scmanager, uint32_t info_level, uint32_t type, uint32_t state, uint8_t *services, uint32_t buf_size, uint32_t *bytes_needed, uint32_t *service_returned, uint32_t *resume_handle, const char **group_name)
{
	struct EnumServicesStatusExA r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.scmanager = scmanager;
	r.in.info_level = info_level;
	r.in.type = type;
	r.in.state = state;
	r.in.buf_size = buf_size;
	r.in.resume_handle = resume_handle;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(EnumServicesStatusExA, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_ENUMSERVICESSTATUSEXA, &r, (ndr_pull_flags_fn_t)ndr_pull_EnumServicesStatusExA, (ndr_push_flags_fn_t)ndr_push_EnumServicesStatusExA);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(EnumServicesStatusExA, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*services = *r.out.services;
	*bytes_needed = *r.out.bytes_needed;
	*service_returned = *r.out.service_returned;
	if ( resume_handle ) {
		*resume_handle = *r.out.resume_handle;
	}
	*group_name = *r.out.group_name;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_EnumServicesStatusExW(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, struct policy_handle *scmanager, uint32_t info_level, uint32_t type, uint32_t state, uint8_t *services, uint32_t buf_size, uint32_t *bytes_needed, uint32_t *service_returned, uint32_t *resume_handle, const char **group_name)
{
	struct EnumServicesStatusExW r;
	NTSTATUS status;
	
	/* In parameters */
	r.in.scmanager = scmanager;
	r.in.info_level = info_level;
	r.in.type = type;
	r.in.state = state;
	r.in.buf_size = buf_size;
	r.in.resume_handle = resume_handle;
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(EnumServicesStatusExW, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_ENUMSERVICESSTATUSEXW, &r, (ndr_pull_flags_fn_t)ndr_pull_EnumServicesStatusExW, (ndr_push_flags_fn_t)ndr_push_EnumServicesStatusExW);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(EnumServicesStatusExW, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	*services = *r.out.services;
	*bytes_needed = *r.out.bytes_needed;
	*service_returned = *r.out.service_returned;
	if ( resume_handle ) {
		*resume_handle = *r.out.resume_handle;
	}
	*group_name = *r.out.group_name;
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

NTSTATUS rpccli_svcctl_SCSendTSMessage(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx)
{
	struct svcctl_SCSendTSMessage r;
	NTSTATUS status;
	
	/* In parameters */
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_SCSendTSMessage, &r);
	
	status = cli_do_rpc_ndr(cli, mem_ctx, PI_SVCCTL, DCERPC_SVCCTL_SCSENDTSMESSAGE, &r, (ndr_pull_flags_fn_t)ndr_pull_svcctl_SCSendTSMessage, (ndr_push_flags_fn_t)ndr_push_svcctl_SCSendTSMessage);
	
	if ( !NT_STATUS_IS_OK(status) ) {
		return status;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_SCSendTSMessage, &r);
	
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}
	
	/* Return variables */
	
	/* Return result */
	return werror_to_ntstatus(r.out.result);
}

