/*
 * Unix SMB/CIFS implementation.
 * server auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "librpc/gen_ndr/srv_lsa.h"

static BOOL api_lsa_Close(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_Close r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_Close");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_Close(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_Close, &r);
	
	ZERO_STRUCT(r.out);
	r.out.handle = r.in.handle;
	r.out.result = _lsa_Close(p, r.in.handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_Close, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_Close(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_Delete(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_Delete r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_Delete");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_Delete(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_Delete, &r);
	
	r.out.result = _lsa_Delete(p, r.in.handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_Delete, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_Delete(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_EnumPrivs(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_EnumPrivs r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_EnumPrivs");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_EnumPrivs(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_EnumPrivs, &r);
	
	ZERO_STRUCT(r.out);
	r.out.resume_handle = r.in.resume_handle;
	r.out.privs = talloc_zero(mem_ctx, struct lsa_PrivArray);
	if (r.out.privs == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_EnumPrivs(p, r.in.handle, r.in.resume_handle, r.in.max_count, r.out.privs);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_EnumPrivs, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_EnumPrivs(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_QuerySecurity(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_QuerySecurity r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_QuerySecurity");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_QuerySecurity(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_QuerySecurity, &r);
	
	ZERO_STRUCT(r.out);
	r.out.sdbuf = talloc_zero(mem_ctx, struct sec_desc_buf);
	if (r.out.sdbuf == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_QuerySecurity(p, r.in.handle, r.in.sec_info, r.out.sdbuf);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_QuerySecurity, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_QuerySecurity(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_SetSecObj(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_SetSecObj r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_SetSecObj");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_SetSecObj(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_SetSecObj, &r);
	
	r.out.result = _lsa_SetSecObj(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_SetSecObj, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_SetSecObj(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_ChangePassword(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_ChangePassword r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_ChangePassword");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_ChangePassword(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_ChangePassword, &r);
	
	r.out.result = _lsa_ChangePassword(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_ChangePassword, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_ChangePassword(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_OpenPolicy(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_OpenPolicy r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_OpenPolicy");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_OpenPolicy(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_OpenPolicy, &r);
	
	ZERO_STRUCT(r.out);
	r.out.handle = talloc_zero(mem_ctx, struct policy_handle);
	if (r.out.handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_OpenPolicy(p, r.in.system_name, r.in.attr, r.in.access_mask, r.out.handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_OpenPolicy, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_OpenPolicy(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_QueryInfoPolicy(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_QueryInfoPolicy r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_QueryInfoPolicy");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_QueryInfoPolicy(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_QueryInfoPolicy, &r);
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_zero(mem_ctx, union lsa_PolicyInformation);
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_QueryInfoPolicy(p, r.in.handle, r.in.level, r.out.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_QueryInfoPolicy, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_QueryInfoPolicy(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_SetInfoPolicy(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_SetInfoPolicy r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_SetInfoPolicy");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_SetInfoPolicy(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_SetInfoPolicy, &r);
	
	r.out.result = _lsa_SetInfoPolicy(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_SetInfoPolicy, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_SetInfoPolicy(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_ClearAuditLog(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_ClearAuditLog r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_ClearAuditLog");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_ClearAuditLog(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_ClearAuditLog, &r);
	
	r.out.result = _lsa_ClearAuditLog(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_ClearAuditLog, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_ClearAuditLog(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_CreateAccount(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_CreateAccount r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_CreateAccount");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_CreateAccount(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_CreateAccount, &r);
	
	ZERO_STRUCT(r.out);
	r.out.acct_handle = talloc_zero(mem_ctx, struct policy_handle);
	if (r.out.acct_handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_CreateAccount(p, r.in.handle, r.in.sid, r.in.access_mask, r.out.acct_handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_CreateAccount, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_CreateAccount(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_EnumAccounts(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_EnumAccounts r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_EnumAccounts");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_EnumAccounts(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_EnumAccounts, &r);
	
	ZERO_STRUCT(r.out);
	r.out.resume_handle = r.in.resume_handle;
	r.out.sids = talloc_zero(mem_ctx, struct lsa_SidArray);
	if (r.out.sids == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_EnumAccounts(p, r.in.handle, r.in.resume_handle, r.in.num_entries, r.out.sids);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_EnumAccounts, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_EnumAccounts(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_CreateTrustedDomain(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_CreateTrustedDomain r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_CreateTrustedDomain");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_CreateTrustedDomain(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_CreateTrustedDomain, &r);
	
	ZERO_STRUCT(r.out);
	r.out.trustdom_handle = talloc_zero(mem_ctx, struct policy_handle);
	if (r.out.trustdom_handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_CreateTrustedDomain(p, r.in.handle, r.in.info, r.in.access_mask, r.out.trustdom_handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_CreateTrustedDomain, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_CreateTrustedDomain(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_EnumTrustDom(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_EnumTrustDom r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_EnumTrustDom");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_EnumTrustDom(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_EnumTrustDom, &r);
	
	ZERO_STRUCT(r.out);
	r.out.resume_handle = r.in.resume_handle;
	r.out.domains = talloc_zero(mem_ctx, struct lsa_DomainList);
	if (r.out.domains == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_EnumTrustDom(p, r.in.handle, r.in.resume_handle, r.in.max_size, r.out.domains);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_EnumTrustDom, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_EnumTrustDom(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LookupNames(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LookupNames r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LookupNames");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LookupNames(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LookupNames, &r);
	
	ZERO_STRUCT(r.out);
	r.out.domains = talloc_zero(mem_ctx, struct lsa_RefDomainList);
	if (r.out.domains == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.sids = r.in.sids;
	r.out.count = r.in.count;
	r.out.result = _lsa_LookupNames(p, r.in.handle, r.in.num_names, r.in.names, r.out.domains, r.in.sids, r.in.level, r.in.count);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LookupNames, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LookupNames(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LookupSids(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LookupSids r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LookupSids");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LookupSids(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LookupSids, &r);
	
	ZERO_STRUCT(r.out);
	r.out.domains = talloc_zero(mem_ctx, struct lsa_RefDomainList);
	if (r.out.domains == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.names = r.in.names;
	r.out.count = r.in.count;
	r.out.result = _lsa_LookupSids(p, r.in.handle, r.in.sids, r.out.domains, r.in.names, r.in.level, r.in.count);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LookupSids, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LookupSids(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_CreateSecret(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_CreateSecret r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_CreateSecret");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_CreateSecret(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_CreateSecret, &r);
	
	ZERO_STRUCT(r.out);
	r.out.sec_handle = talloc_zero(mem_ctx, struct policy_handle);
	if (r.out.sec_handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_CreateSecret(p, r.in.handle, r.in.name, r.in.access_mask, r.out.sec_handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_CreateSecret, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_CreateSecret(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_OpenAccount(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_OpenAccount r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_OpenAccount");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_OpenAccount(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_OpenAccount, &r);
	
	ZERO_STRUCT(r.out);
	r.out.acct_handle = talloc_zero(mem_ctx, struct policy_handle);
	if (r.out.acct_handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_OpenAccount(p, r.in.handle, r.in.sid, r.in.access_mask, r.out.acct_handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_OpenAccount, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_OpenAccount(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_EnumPrivsAccount(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_EnumPrivsAccount r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_EnumPrivsAccount");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_EnumPrivsAccount(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_EnumPrivsAccount, &r);
	
	ZERO_STRUCT(r.out);
	r.out.privs = talloc_zero(mem_ctx, struct lsa_PrivilegeSet);
	if (r.out.privs == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_EnumPrivsAccount(p, r.in.handle, r.out.privs);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_EnumPrivsAccount, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_EnumPrivsAccount(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_AddPrivilegesToAccount(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_AddPrivilegesToAccount r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_AddPrivilegesToAccount");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_AddPrivilegesToAccount(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_AddPrivilegesToAccount, &r);
	
	r.out.result = _lsa_AddPrivilegesToAccount(p, r.in.handle, r.in.privs);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_AddPrivilegesToAccount, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_AddPrivilegesToAccount(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_RemovePrivilegesFromAccount(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_RemovePrivilegesFromAccount r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_RemovePrivilegesFromAccount");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_RemovePrivilegesFromAccount(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_RemovePrivilegesFromAccount, &r);
	
	r.out.result = _lsa_RemovePrivilegesFromAccount(p, r.in.handle, r.in.remove_all, r.in.privs);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_RemovePrivilegesFromAccount, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_RemovePrivilegesFromAccount(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_GetQuotasForAccount(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_GetQuotasForAccount r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_GetQuotasForAccount");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_GetQuotasForAccount(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_GetQuotasForAccount, &r);
	
	r.out.result = _lsa_GetQuotasForAccount(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_GetQuotasForAccount, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_GetQuotasForAccount(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_SetQuotasForAccount(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_SetQuotasForAccount r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_SetQuotasForAccount");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_SetQuotasForAccount(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_SetQuotasForAccount, &r);
	
	r.out.result = _lsa_SetQuotasForAccount(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_SetQuotasForAccount, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_SetQuotasForAccount(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_GetSystemAccessAccount(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_GetSystemAccessAccount r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_GetSystemAccessAccount");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_GetSystemAccessAccount(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_GetSystemAccessAccount, &r);
	
	r.out.result = _lsa_GetSystemAccessAccount(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_GetSystemAccessAccount, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_GetSystemAccessAccount(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_SetSystemAccessAccount(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_SetSystemAccessAccount r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_SetSystemAccessAccount");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_SetSystemAccessAccount(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_SetSystemAccessAccount, &r);
	
	r.out.result = _lsa_SetSystemAccessAccount(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_SetSystemAccessAccount, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_SetSystemAccessAccount(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_OpenTrustedDomain(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_OpenTrustedDomain r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_OpenTrustedDomain");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_OpenTrustedDomain(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_OpenTrustedDomain, &r);
	
	ZERO_STRUCT(r.out);
	r.out.trustdom_handle = talloc_zero(mem_ctx, struct policy_handle);
	if (r.out.trustdom_handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_OpenTrustedDomain(p, r.in.handle, r.in.sid, r.in.access_mask, r.out.trustdom_handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_OpenTrustedDomain, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_OpenTrustedDomain(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_QueryTrustedDomainInfo(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_QueryTrustedDomainInfo r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_QueryTrustedDomainInfo");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_QueryTrustedDomainInfo(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_QueryTrustedDomainInfo, &r);
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_zero(mem_ctx, union lsa_TrustedDomainInfo);
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_QueryTrustedDomainInfo(p, r.in.trustdom_handle, r.in.level, r.out.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_QueryTrustedDomainInfo, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_QueryTrustedDomainInfo(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_SetInformationTrustedDomain(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_SetInformationTrustedDomain r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_SetInformationTrustedDomain");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_SetInformationTrustedDomain(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_SetInformationTrustedDomain, &r);
	
	r.out.result = _lsa_SetInformationTrustedDomain(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_SetInformationTrustedDomain, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_SetInformationTrustedDomain(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_OpenSecret(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_OpenSecret r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_OpenSecret");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_OpenSecret(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_OpenSecret, &r);
	
	ZERO_STRUCT(r.out);
	r.out.sec_handle = talloc_zero(mem_ctx, struct policy_handle);
	if (r.out.sec_handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_OpenSecret(p, r.in.handle, r.in.name, r.in.access_mask, r.out.sec_handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_OpenSecret, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_OpenSecret(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_SetSecret(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_SetSecret r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_SetSecret");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_SetSecret(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_SetSecret, &r);
	
	r.out.result = _lsa_SetSecret(p, r.in.sec_handle, r.in.new_val, r.in.old_val);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_SetSecret, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_SetSecret(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_QuerySecret(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_QuerySecret r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_QuerySecret");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_QuerySecret(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_QuerySecret, &r);
	
	ZERO_STRUCT(r.out);
	r.out.new_val = r.in.new_val;
	r.out.new_mtime = r.in.new_mtime;
	r.out.old_val = r.in.old_val;
	r.out.old_mtime = r.in.old_mtime;
	r.out.result = _lsa_QuerySecret(p, r.in.sec_handle, r.in.new_val, r.in.new_mtime, r.in.old_val, r.in.old_mtime);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_QuerySecret, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_QuerySecret(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LookupPrivValue(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LookupPrivValue r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LookupPrivValue");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LookupPrivValue(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LookupPrivValue, &r);
	
	ZERO_STRUCT(r.out);
	r.out.luid = talloc_zero(mem_ctx, struct lsa_LUID);
	if (r.out.luid == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_LookupPrivValue(p, r.in.handle, r.in.name, r.out.luid);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LookupPrivValue, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LookupPrivValue(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LookupPrivName(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LookupPrivName r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LookupPrivName");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LookupPrivName(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LookupPrivName, &r);
	
	ZERO_STRUCT(r.out);
	r.out.name = talloc_zero(mem_ctx, struct lsa_StringLarge);
	if (r.out.name == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_LookupPrivName(p, r.in.handle, r.in.luid, r.out.name);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LookupPrivName, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LookupPrivName(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LookupPrivDisplayName(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LookupPrivDisplayName r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LookupPrivDisplayName");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LookupPrivDisplayName(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LookupPrivDisplayName, &r);
	
	ZERO_STRUCT(r.out);
	r.out.disp_name = talloc_zero(mem_ctx, struct lsa_StringLarge);
	if (r.out.disp_name == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.language_id = r.in.language_id;
	r.out.result = _lsa_LookupPrivDisplayName(p, r.in.handle, r.in.name, r.out.disp_name, r.in.language_id, r.in.unknown);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LookupPrivDisplayName, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LookupPrivDisplayName(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_DeleteObject(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_DeleteObject r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_DeleteObject");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_DeleteObject(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_DeleteObject, &r);
	
	r.out.result = _lsa_DeleteObject(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_DeleteObject, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_DeleteObject(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_EnumAccountsWithUserRight(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_EnumAccountsWithUserRight r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_EnumAccountsWithUserRight");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_EnumAccountsWithUserRight(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_EnumAccountsWithUserRight, &r);
	
	ZERO_STRUCT(r.out);
	r.out.sids = talloc_zero(mem_ctx, struct lsa_SidArray);
	if (r.out.sids == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_EnumAccountsWithUserRight(p, r.in.handle, r.in.name, r.out.sids);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_EnumAccountsWithUserRight, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_EnumAccountsWithUserRight(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_EnumAccountRights(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_EnumAccountRights r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_EnumAccountRights");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_EnumAccountRights(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_EnumAccountRights, &r);
	
	ZERO_STRUCT(r.out);
	r.out.rights = talloc_zero(mem_ctx, struct lsa_RightSet);
	if (r.out.rights == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_EnumAccountRights(p, r.in.handle, r.in.sid, r.out.rights);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_EnumAccountRights, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_EnumAccountRights(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_AddAccountRights(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_AddAccountRights r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_AddAccountRights");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_AddAccountRights(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_AddAccountRights, &r);
	
	r.out.result = _lsa_AddAccountRights(p, r.in.handle, r.in.sid, r.in.rights);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_AddAccountRights, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_AddAccountRights(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_RemoveAccountRights(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_RemoveAccountRights r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_RemoveAccountRights");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_RemoveAccountRights(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_RemoveAccountRights, &r);
	
	r.out.result = _lsa_RemoveAccountRights(p, r.in.handle, r.in.sid, r.in.unknown, r.in.rights);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_RemoveAccountRights, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_RemoveAccountRights(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_QueryTrustedDomainInfoBySid(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_QueryTrustedDomainInfoBySid r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_QueryTrustedDomainInfoBySid");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_QueryTrustedDomainInfoBySid(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_QueryTrustedDomainInfoBySid, &r);
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_zero(mem_ctx, union lsa_TrustedDomainInfo);
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_QueryTrustedDomainInfoBySid(p, r.in.handle, r.in.dom_sid, r.in.level, r.out.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_QueryTrustedDomainInfoBySid, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_QueryTrustedDomainInfoBySid(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_SetTrustedDomainInfo(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_SetTrustedDomainInfo r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_SetTrustedDomainInfo");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_SetTrustedDomainInfo(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_SetTrustedDomainInfo, &r);
	
	r.out.result = _lsa_SetTrustedDomainInfo(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_SetTrustedDomainInfo, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_SetTrustedDomainInfo(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_DeleteTrustedDomain(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_DeleteTrustedDomain r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_DeleteTrustedDomain");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_DeleteTrustedDomain(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_DeleteTrustedDomain, &r);
	
	r.out.result = _lsa_DeleteTrustedDomain(p, r.in.handle, r.in.dom_sid);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_DeleteTrustedDomain, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_DeleteTrustedDomain(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_StorePrivateData(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_StorePrivateData r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_StorePrivateData");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_StorePrivateData(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_StorePrivateData, &r);
	
	r.out.result = _lsa_StorePrivateData(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_StorePrivateData, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_StorePrivateData(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_RetrievePrivateData(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_RetrievePrivateData r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_RetrievePrivateData");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_RetrievePrivateData(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_RetrievePrivateData, &r);
	
	r.out.result = _lsa_RetrievePrivateData(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_RetrievePrivateData, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_RetrievePrivateData(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_OpenPolicy2(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_OpenPolicy2 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_OpenPolicy2");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_OpenPolicy2(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_OpenPolicy2, &r);
	
	ZERO_STRUCT(r.out);
	r.out.handle = talloc_zero(mem_ctx, struct policy_handle);
	if (r.out.handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_OpenPolicy2(p, r.in.system_name, r.in.attr, r.in.access_mask, r.out.handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_OpenPolicy2, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_OpenPolicy2(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_GetUserName(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_GetUserName r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_GetUserName");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_GetUserName(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_GetUserName, &r);
	
	ZERO_STRUCT(r.out);
	r.out.account_name = r.in.account_name;
	r.out.authority_name = r.in.authority_name;
	r.out.result = _lsa_GetUserName(p, r.in.system_name, r.in.account_name, r.in.authority_name);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_GetUserName, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_GetUserName(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_QueryInfoPolicy2(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_QueryInfoPolicy2 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_QueryInfoPolicy2");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_QueryInfoPolicy2(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_QueryInfoPolicy2, &r);
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_zero(mem_ctx, union lsa_PolicyInformation);
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_QueryInfoPolicy2(p, r.in.handle, r.in.level, r.out.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_QueryInfoPolicy2, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_QueryInfoPolicy2(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_SetInfoPolicy2(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_SetInfoPolicy2 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_SetInfoPolicy2");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_SetInfoPolicy2(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_SetInfoPolicy2, &r);
	
	r.out.result = _lsa_SetInfoPolicy2(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_SetInfoPolicy2, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_SetInfoPolicy2(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_QueryTrustedDomainInfoByName(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_QueryTrustedDomainInfoByName r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_QueryTrustedDomainInfoByName");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_QueryTrustedDomainInfoByName(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_QueryTrustedDomainInfoByName, &r);
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_zero(mem_ctx, union lsa_TrustedDomainInfo);
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_QueryTrustedDomainInfoByName(p, r.in.handle, r.in.trusted_domain, r.in.level, r.out.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_QueryTrustedDomainInfoByName, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_QueryTrustedDomainInfoByName(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_SetTrustedDomainInfoByName(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_SetTrustedDomainInfoByName r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_SetTrustedDomainInfoByName");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_SetTrustedDomainInfoByName(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_SetTrustedDomainInfoByName, &r);
	
	r.out.result = _lsa_SetTrustedDomainInfoByName(p, r.in.handle, r.in.trusted_domain, r.in.level, r.in.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_SetTrustedDomainInfoByName, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_SetTrustedDomainInfoByName(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_EnumTrustedDomainsEx(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_EnumTrustedDomainsEx r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_EnumTrustedDomainsEx");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_EnumTrustedDomainsEx(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_EnumTrustedDomainsEx, &r);
	
	ZERO_STRUCT(r.out);
	r.out.resume_handle = r.in.resume_handle;
	r.out.domains = talloc_zero(mem_ctx, struct lsa_DomainListEx);
	if (r.out.domains == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_EnumTrustedDomainsEx(p, r.in.handle, r.in.resume_handle, r.out.domains, r.in.max_size);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_EnumTrustedDomainsEx, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_EnumTrustedDomainsEx(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_CreateTrustedDomainEx(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_CreateTrustedDomainEx r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_CreateTrustedDomainEx");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_CreateTrustedDomainEx(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_CreateTrustedDomainEx, &r);
	
	r.out.result = _lsa_CreateTrustedDomainEx(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_CreateTrustedDomainEx, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_CreateTrustedDomainEx(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_CloseTrustedDomainEx(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_CloseTrustedDomainEx r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_CloseTrustedDomainEx");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_CloseTrustedDomainEx(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_CloseTrustedDomainEx, &r);
	
	ZERO_STRUCT(r.out);
	r.out.handle = r.in.handle;
	r.out.result = _lsa_CloseTrustedDomainEx(p, r.in.handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_CloseTrustedDomainEx, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_CloseTrustedDomainEx(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_QueryDomainInformationPolicy(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_QueryDomainInformationPolicy r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_QueryDomainInformationPolicy");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_QueryDomainInformationPolicy(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_QueryDomainInformationPolicy, &r);
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_zero(mem_ctx, union lsa_DomainInformationPolicy);
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_QueryDomainInformationPolicy(p, r.in.handle, r.in.level, r.out.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_QueryDomainInformationPolicy, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_QueryDomainInformationPolicy(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_SetDomainInformationPolicy(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_SetDomainInformationPolicy r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_SetDomainInformationPolicy");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_SetDomainInformationPolicy(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_SetDomainInformationPolicy, &r);
	
	r.out.result = _lsa_SetDomainInformationPolicy(p, r.in.handle, r.in.level, r.in.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_SetDomainInformationPolicy, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_SetDomainInformationPolicy(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_OpenTrustedDomainByName(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_OpenTrustedDomainByName r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_OpenTrustedDomainByName");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_OpenTrustedDomainByName(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_OpenTrustedDomainByName, &r);
	
	ZERO_STRUCT(r.out);
	r.out.trustdom_handle = talloc_zero(mem_ctx, struct policy_handle);
	if (r.out.trustdom_handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _lsa_OpenTrustedDomainByName(p, r.in.handle, r.in.name, r.in.access_mask, r.out.trustdom_handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_OpenTrustedDomainByName, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_OpenTrustedDomainByName(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_TestCall(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_TestCall r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_TestCall");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_TestCall(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_TestCall, &r);
	
	r.out.result = _lsa_TestCall(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_TestCall, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_TestCall(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LookupSids2(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LookupSids2 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LookupSids2");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LookupSids2(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LookupSids2, &r);
	
	ZERO_STRUCT(r.out);
	r.out.domains = talloc_zero(mem_ctx, struct lsa_RefDomainList);
	if (r.out.domains == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.names = r.in.names;
	r.out.count = r.in.count;
	r.out.result = _lsa_LookupSids2(p, r.in.handle, r.in.sids, r.out.domains, r.in.names, r.in.level, r.in.count, r.in.unknown1, r.in.unknown2);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LookupSids2, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LookupSids2(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LookupNames2(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LookupNames2 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LookupNames2");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LookupNames2(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LookupNames2, &r);
	
	ZERO_STRUCT(r.out);
	r.out.domains = talloc_zero(mem_ctx, struct lsa_RefDomainList);
	if (r.out.domains == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.sids = r.in.sids;
	r.out.count = r.in.count;
	r.out.result = _lsa_LookupNames2(p, r.in.handle, r.in.num_names, r.in.names, r.out.domains, r.in.sids, r.in.level, r.in.count, r.in.unknown1, r.in.unknown2);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LookupNames2, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LookupNames2(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_CreateTrustedDomainEx2(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_CreateTrustedDomainEx2 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_CreateTrustedDomainEx2");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_CreateTrustedDomainEx2(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_CreateTrustedDomainEx2, &r);
	
	r.out.result = _lsa_CreateTrustedDomainEx2(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_CreateTrustedDomainEx2, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_CreateTrustedDomainEx2(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_CREDRWRITE(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_CREDRWRITE r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_CREDRWRITE");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_CREDRWRITE(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_CREDRWRITE, &r);
	
	r.out.result = _lsa_CREDRWRITE(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_CREDRWRITE, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_CREDRWRITE(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_CREDRREAD(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_CREDRREAD r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_CREDRREAD");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_CREDRREAD(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_CREDRREAD, &r);
	
	r.out.result = _lsa_CREDRREAD(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_CREDRREAD, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_CREDRREAD(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_CREDRENUMERATE(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_CREDRENUMERATE r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_CREDRENUMERATE");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_CREDRENUMERATE(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_CREDRENUMERATE, &r);
	
	r.out.result = _lsa_CREDRENUMERATE(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_CREDRENUMERATE, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_CREDRENUMERATE(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_CREDRWRITEDOMAINCREDENTIALS(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_CREDRWRITEDOMAINCREDENTIALS r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_CREDRWRITEDOMAINCREDENTIALS");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_CREDRWRITEDOMAINCREDENTIALS(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_CREDRWRITEDOMAINCREDENTIALS, &r);
	
	r.out.result = _lsa_CREDRWRITEDOMAINCREDENTIALS(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_CREDRWRITEDOMAINCREDENTIALS, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_CREDRWRITEDOMAINCREDENTIALS(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_CREDRREADDOMAINCREDENTIALS(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_CREDRREADDOMAINCREDENTIALS r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_CREDRREADDOMAINCREDENTIALS");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_CREDRREADDOMAINCREDENTIALS(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_CREDRREADDOMAINCREDENTIALS, &r);
	
	r.out.result = _lsa_CREDRREADDOMAINCREDENTIALS(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_CREDRREADDOMAINCREDENTIALS, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_CREDRREADDOMAINCREDENTIALS(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_CREDRDELETE(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_CREDRDELETE r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_CREDRDELETE");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_CREDRDELETE(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_CREDRDELETE, &r);
	
	r.out.result = _lsa_CREDRDELETE(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_CREDRDELETE, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_CREDRDELETE(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_CREDRGETTARGETINFO(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_CREDRGETTARGETINFO r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_CREDRGETTARGETINFO");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_CREDRGETTARGETINFO(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_CREDRGETTARGETINFO, &r);
	
	r.out.result = _lsa_CREDRGETTARGETINFO(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_CREDRGETTARGETINFO, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_CREDRGETTARGETINFO(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_CREDRPROFILELOADED(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_CREDRPROFILELOADED r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_CREDRPROFILELOADED");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_CREDRPROFILELOADED(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_CREDRPROFILELOADED, &r);
	
	r.out.result = _lsa_CREDRPROFILELOADED(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_CREDRPROFILELOADED, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_CREDRPROFILELOADED(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LookupNames3(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LookupNames3 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LookupNames3");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LookupNames3(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LookupNames3, &r);
	
	ZERO_STRUCT(r.out);
	r.out.domains = talloc_zero(mem_ctx, struct lsa_RefDomainList);
	if (r.out.domains == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.sids = r.in.sids;
	r.out.count = r.in.count;
	r.out.result = _lsa_LookupNames3(p, r.in.handle, r.in.num_names, r.in.names, r.out.domains, r.in.sids, r.in.level, r.in.count, r.in.unknown1, r.in.unknown2);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LookupNames3, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LookupNames3(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_CREDRGETSESSIONTYPES(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_CREDRGETSESSIONTYPES r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_CREDRGETSESSIONTYPES");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_CREDRGETSESSIONTYPES(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_CREDRGETSESSIONTYPES, &r);
	
	r.out.result = _lsa_CREDRGETSESSIONTYPES(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_CREDRGETSESSIONTYPES, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_CREDRGETSESSIONTYPES(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LSARREGISTERAUDITEVENT(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LSARREGISTERAUDITEVENT r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LSARREGISTERAUDITEVENT");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LSARREGISTERAUDITEVENT(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LSARREGISTERAUDITEVENT, &r);
	
	r.out.result = _lsa_LSARREGISTERAUDITEVENT(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LSARREGISTERAUDITEVENT, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LSARREGISTERAUDITEVENT(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LSARGENAUDITEVENT(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LSARGENAUDITEVENT r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LSARGENAUDITEVENT");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LSARGENAUDITEVENT(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LSARGENAUDITEVENT, &r);
	
	r.out.result = _lsa_LSARGENAUDITEVENT(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LSARGENAUDITEVENT, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LSARGENAUDITEVENT(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LSARUNREGISTERAUDITEVENT(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LSARUNREGISTERAUDITEVENT r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LSARUNREGISTERAUDITEVENT");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LSARUNREGISTERAUDITEVENT(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LSARUNREGISTERAUDITEVENT, &r);
	
	r.out.result = _lsa_LSARUNREGISTERAUDITEVENT(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LSARUNREGISTERAUDITEVENT, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LSARUNREGISTERAUDITEVENT(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LSARQUERYFORESTTRUSTINFORMATION(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LSARQUERYFORESTTRUSTINFORMATION r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LSARQUERYFORESTTRUSTINFORMATION");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LSARQUERYFORESTTRUSTINFORMATION(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LSARQUERYFORESTTRUSTINFORMATION, &r);
	
	r.out.result = _lsa_LSARQUERYFORESTTRUSTINFORMATION(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LSARQUERYFORESTTRUSTINFORMATION, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LSARQUERYFORESTTRUSTINFORMATION(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LSARSETFORESTTRUSTINFORMATION(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LSARSETFORESTTRUSTINFORMATION r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LSARSETFORESTTRUSTINFORMATION");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LSARSETFORESTTRUSTINFORMATION(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LSARSETFORESTTRUSTINFORMATION, &r);
	
	r.out.result = _lsa_LSARSETFORESTTRUSTINFORMATION(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LSARSETFORESTTRUSTINFORMATION, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LSARSETFORESTTRUSTINFORMATION(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_CREDRRENAME(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_CREDRRENAME r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_CREDRRENAME");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_CREDRRENAME(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_CREDRRENAME, &r);
	
	r.out.result = _lsa_CREDRRENAME(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_CREDRRENAME, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_CREDRRENAME(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LookupSids3(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LookupSids3 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LookupSids3");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LookupSids3(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LookupSids3, &r);
	
	ZERO_STRUCT(r.out);
	r.out.domains = talloc_zero(mem_ctx, struct lsa_RefDomainList);
	if (r.out.domains == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.names = r.in.names;
	r.out.count = r.in.count;
	r.out.result = _lsa_LookupSids3(p, r.in.sids, r.out.domains, r.in.names, r.in.level, r.in.count, r.in.unknown1, r.in.unknown2);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LookupSids3, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LookupSids3(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LookupNames4(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LookupNames4 r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LookupNames4");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LookupNames4(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LookupNames4, &r);
	
	ZERO_STRUCT(r.out);
	r.out.domains = talloc_zero(mem_ctx, struct lsa_RefDomainList);
	if (r.out.domains == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.sids = r.in.sids;
	r.out.count = r.in.count;
	r.out.result = _lsa_LookupNames4(p, r.in.num_names, r.in.names, r.out.domains, r.in.sids, r.in.level, r.in.count, r.in.unknown1, r.in.unknown2);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LookupNames4, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LookupNames4(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LSAROPENPOLICYSCE(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LSAROPENPOLICYSCE r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LSAROPENPOLICYSCE");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LSAROPENPOLICYSCE(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LSAROPENPOLICYSCE, &r);
	
	r.out.result = _lsa_LSAROPENPOLICYSCE(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LSAROPENPOLICYSCE, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LSAROPENPOLICYSCE(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LSARADTREGISTERSECURITYEVENTSOURCE(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LSARADTREGISTERSECURITYEVENTSOURCE r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LSARADTREGISTERSECURITYEVENTSOURCE");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LSARADTREGISTERSECURITYEVENTSOURCE(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LSARADTREGISTERSECURITYEVENTSOURCE, &r);
	
	r.out.result = _lsa_LSARADTREGISTERSECURITYEVENTSOURCE(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LSARADTREGISTERSECURITYEVENTSOURCE, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LSARADTREGISTERSECURITYEVENTSOURCE(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE, &r);
	
	r.out.result = _lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_lsa_LSARADTREPORTSECURITYEVENT(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct lsa_LSARADTREPORTSECURITYEVENT r;
	TALLOC_CTX *mem_ctx = talloc_init("api_lsa_LSARADTREPORTSECURITYEVENT");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_lsa_LSARADTREPORTSECURITYEVENT(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(lsa_LSARADTREPORTSECURITYEVENT, &r);
	
	r.out.result = _lsa_LSARADTREPORTSECURITYEVENT(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(lsa_LSARADTREPORTSECURITYEVENT, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_lsa_LSARADTREPORTSECURITYEVENT(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}


/* Tables */
static struct api_struct api_lsarpc_cmds[] = 
{
	{"LSA_CLOSE", DCERPC_LSA_CLOSE, api_lsa_Close},
	{"LSA_DELETE", DCERPC_LSA_DELETE, api_lsa_Delete},
	{"LSA_ENUMPRIVS", DCERPC_LSA_ENUMPRIVS, api_lsa_EnumPrivs},
	{"LSA_QUERYSECURITY", DCERPC_LSA_QUERYSECURITY, api_lsa_QuerySecurity},
	{"LSA_SETSECOBJ", DCERPC_LSA_SETSECOBJ, api_lsa_SetSecObj},
	{"LSA_CHANGEPASSWORD", DCERPC_LSA_CHANGEPASSWORD, api_lsa_ChangePassword},
	{"LSA_OPENPOLICY", DCERPC_LSA_OPENPOLICY, api_lsa_OpenPolicy},
	{"LSA_QUERYINFOPOLICY", DCERPC_LSA_QUERYINFOPOLICY, api_lsa_QueryInfoPolicy},
	{"LSA_SETINFOPOLICY", DCERPC_LSA_SETINFOPOLICY, api_lsa_SetInfoPolicy},
	{"LSA_CLEARAUDITLOG", DCERPC_LSA_CLEARAUDITLOG, api_lsa_ClearAuditLog},
	{"LSA_CREATEACCOUNT", DCERPC_LSA_CREATEACCOUNT, api_lsa_CreateAccount},
	{"LSA_ENUMACCOUNTS", DCERPC_LSA_ENUMACCOUNTS, api_lsa_EnumAccounts},
	{"LSA_CREATETRUSTEDDOMAIN", DCERPC_LSA_CREATETRUSTEDDOMAIN, api_lsa_CreateTrustedDomain},
	{"LSA_ENUMTRUSTDOM", DCERPC_LSA_ENUMTRUSTDOM, api_lsa_EnumTrustDom},
	{"LSA_LOOKUPNAMES", DCERPC_LSA_LOOKUPNAMES, api_lsa_LookupNames},
	{"LSA_LOOKUPSIDS", DCERPC_LSA_LOOKUPSIDS, api_lsa_LookupSids},
	{"LSA_CREATESECRET", DCERPC_LSA_CREATESECRET, api_lsa_CreateSecret},
	{"LSA_OPENACCOUNT", DCERPC_LSA_OPENACCOUNT, api_lsa_OpenAccount},
	{"LSA_ENUMPRIVSACCOUNT", DCERPC_LSA_ENUMPRIVSACCOUNT, api_lsa_EnumPrivsAccount},
	{"LSA_ADDPRIVILEGESTOACCOUNT", DCERPC_LSA_ADDPRIVILEGESTOACCOUNT, api_lsa_AddPrivilegesToAccount},
	{"LSA_REMOVEPRIVILEGESFROMACCOUNT", DCERPC_LSA_REMOVEPRIVILEGESFROMACCOUNT, api_lsa_RemovePrivilegesFromAccount},
	{"LSA_GETQUOTASFORACCOUNT", DCERPC_LSA_GETQUOTASFORACCOUNT, api_lsa_GetQuotasForAccount},
	{"LSA_SETQUOTASFORACCOUNT", DCERPC_LSA_SETQUOTASFORACCOUNT, api_lsa_SetQuotasForAccount},
	{"LSA_GETSYSTEMACCESSACCOUNT", DCERPC_LSA_GETSYSTEMACCESSACCOUNT, api_lsa_GetSystemAccessAccount},
	{"LSA_SETSYSTEMACCESSACCOUNT", DCERPC_LSA_SETSYSTEMACCESSACCOUNT, api_lsa_SetSystemAccessAccount},
	{"LSA_OPENTRUSTEDDOMAIN", DCERPC_LSA_OPENTRUSTEDDOMAIN, api_lsa_OpenTrustedDomain},
	{"LSA_QUERYTRUSTEDDOMAININFO", DCERPC_LSA_QUERYTRUSTEDDOMAININFO, api_lsa_QueryTrustedDomainInfo},
	{"LSA_SETINFORMATIONTRUSTEDDOMAIN", DCERPC_LSA_SETINFORMATIONTRUSTEDDOMAIN, api_lsa_SetInformationTrustedDomain},
	{"LSA_OPENSECRET", DCERPC_LSA_OPENSECRET, api_lsa_OpenSecret},
	{"LSA_SETSECRET", DCERPC_LSA_SETSECRET, api_lsa_SetSecret},
	{"LSA_QUERYSECRET", DCERPC_LSA_QUERYSECRET, api_lsa_QuerySecret},
	{"LSA_LOOKUPPRIVVALUE", DCERPC_LSA_LOOKUPPRIVVALUE, api_lsa_LookupPrivValue},
	{"LSA_LOOKUPPRIVNAME", DCERPC_LSA_LOOKUPPRIVNAME, api_lsa_LookupPrivName},
	{"LSA_LOOKUPPRIVDISPLAYNAME", DCERPC_LSA_LOOKUPPRIVDISPLAYNAME, api_lsa_LookupPrivDisplayName},
	{"LSA_DELETEOBJECT", DCERPC_LSA_DELETEOBJECT, api_lsa_DeleteObject},
	{"LSA_ENUMACCOUNTSWITHUSERRIGHT", DCERPC_LSA_ENUMACCOUNTSWITHUSERRIGHT, api_lsa_EnumAccountsWithUserRight},
	{"LSA_ENUMACCOUNTRIGHTS", DCERPC_LSA_ENUMACCOUNTRIGHTS, api_lsa_EnumAccountRights},
	{"LSA_ADDACCOUNTRIGHTS", DCERPC_LSA_ADDACCOUNTRIGHTS, api_lsa_AddAccountRights},
	{"LSA_REMOVEACCOUNTRIGHTS", DCERPC_LSA_REMOVEACCOUNTRIGHTS, api_lsa_RemoveAccountRights},
	{"LSA_QUERYTRUSTEDDOMAININFOBYSID", DCERPC_LSA_QUERYTRUSTEDDOMAININFOBYSID, api_lsa_QueryTrustedDomainInfoBySid},
	{"LSA_SETTRUSTEDDOMAININFO", DCERPC_LSA_SETTRUSTEDDOMAININFO, api_lsa_SetTrustedDomainInfo},
	{"LSA_DELETETRUSTEDDOMAIN", DCERPC_LSA_DELETETRUSTEDDOMAIN, api_lsa_DeleteTrustedDomain},
	{"LSA_STOREPRIVATEDATA", DCERPC_LSA_STOREPRIVATEDATA, api_lsa_StorePrivateData},
	{"LSA_RETRIEVEPRIVATEDATA", DCERPC_LSA_RETRIEVEPRIVATEDATA, api_lsa_RetrievePrivateData},
	{"LSA_OPENPOLICY2", DCERPC_LSA_OPENPOLICY2, api_lsa_OpenPolicy2},
	{"LSA_GETUSERNAME", DCERPC_LSA_GETUSERNAME, api_lsa_GetUserName},
	{"LSA_QUERYINFOPOLICY2", DCERPC_LSA_QUERYINFOPOLICY2, api_lsa_QueryInfoPolicy2},
	{"LSA_SETINFOPOLICY2", DCERPC_LSA_SETINFOPOLICY2, api_lsa_SetInfoPolicy2},
	{"LSA_QUERYTRUSTEDDOMAININFOBYNAME", DCERPC_LSA_QUERYTRUSTEDDOMAININFOBYNAME, api_lsa_QueryTrustedDomainInfoByName},
	{"LSA_SETTRUSTEDDOMAININFOBYNAME", DCERPC_LSA_SETTRUSTEDDOMAININFOBYNAME, api_lsa_SetTrustedDomainInfoByName},
	{"LSA_ENUMTRUSTEDDOMAINSEX", DCERPC_LSA_ENUMTRUSTEDDOMAINSEX, api_lsa_EnumTrustedDomainsEx},
	{"LSA_CREATETRUSTEDDOMAINEX", DCERPC_LSA_CREATETRUSTEDDOMAINEX, api_lsa_CreateTrustedDomainEx},
	{"LSA_CLOSETRUSTEDDOMAINEX", DCERPC_LSA_CLOSETRUSTEDDOMAINEX, api_lsa_CloseTrustedDomainEx},
	{"LSA_QUERYDOMAININFORMATIONPOLICY", DCERPC_LSA_QUERYDOMAININFORMATIONPOLICY, api_lsa_QueryDomainInformationPolicy},
	{"LSA_SETDOMAININFORMATIONPOLICY", DCERPC_LSA_SETDOMAININFORMATIONPOLICY, api_lsa_SetDomainInformationPolicy},
	{"LSA_OPENTRUSTEDDOMAINBYNAME", DCERPC_LSA_OPENTRUSTEDDOMAINBYNAME, api_lsa_OpenTrustedDomainByName},
	{"LSA_TESTCALL", DCERPC_LSA_TESTCALL, api_lsa_TestCall},
	{"LSA_LOOKUPSIDS2", DCERPC_LSA_LOOKUPSIDS2, api_lsa_LookupSids2},
	{"LSA_LOOKUPNAMES2", DCERPC_LSA_LOOKUPNAMES2, api_lsa_LookupNames2},
	{"LSA_CREATETRUSTEDDOMAINEX2", DCERPC_LSA_CREATETRUSTEDDOMAINEX2, api_lsa_CreateTrustedDomainEx2},
	{"LSA_CREDRWRITE", DCERPC_LSA_CREDRWRITE, api_lsa_CREDRWRITE},
	{"LSA_CREDRREAD", DCERPC_LSA_CREDRREAD, api_lsa_CREDRREAD},
	{"LSA_CREDRENUMERATE", DCERPC_LSA_CREDRENUMERATE, api_lsa_CREDRENUMERATE},
	{"LSA_CREDRWRITEDOMAINCREDENTIALS", DCERPC_LSA_CREDRWRITEDOMAINCREDENTIALS, api_lsa_CREDRWRITEDOMAINCREDENTIALS},
	{"LSA_CREDRREADDOMAINCREDENTIALS", DCERPC_LSA_CREDRREADDOMAINCREDENTIALS, api_lsa_CREDRREADDOMAINCREDENTIALS},
	{"LSA_CREDRDELETE", DCERPC_LSA_CREDRDELETE, api_lsa_CREDRDELETE},
	{"LSA_CREDRGETTARGETINFO", DCERPC_LSA_CREDRGETTARGETINFO, api_lsa_CREDRGETTARGETINFO},
	{"LSA_CREDRPROFILELOADED", DCERPC_LSA_CREDRPROFILELOADED, api_lsa_CREDRPROFILELOADED},
	{"LSA_LOOKUPNAMES3", DCERPC_LSA_LOOKUPNAMES3, api_lsa_LookupNames3},
	{"LSA_CREDRGETSESSIONTYPES", DCERPC_LSA_CREDRGETSESSIONTYPES, api_lsa_CREDRGETSESSIONTYPES},
	{"LSA_LSARREGISTERAUDITEVENT", DCERPC_LSA_LSARREGISTERAUDITEVENT, api_lsa_LSARREGISTERAUDITEVENT},
	{"LSA_LSARGENAUDITEVENT", DCERPC_LSA_LSARGENAUDITEVENT, api_lsa_LSARGENAUDITEVENT},
	{"LSA_LSARUNREGISTERAUDITEVENT", DCERPC_LSA_LSARUNREGISTERAUDITEVENT, api_lsa_LSARUNREGISTERAUDITEVENT},
	{"LSA_LSARQUERYFORESTTRUSTINFORMATION", DCERPC_LSA_LSARQUERYFORESTTRUSTINFORMATION, api_lsa_LSARQUERYFORESTTRUSTINFORMATION},
	{"LSA_LSARSETFORESTTRUSTINFORMATION", DCERPC_LSA_LSARSETFORESTTRUSTINFORMATION, api_lsa_LSARSETFORESTTRUSTINFORMATION},
	{"LSA_CREDRRENAME", DCERPC_LSA_CREDRRENAME, api_lsa_CREDRRENAME},
	{"LSA_LOOKUPSIDS3", DCERPC_LSA_LOOKUPSIDS3, api_lsa_LookupSids3},
	{"LSA_LOOKUPNAMES4", DCERPC_LSA_LOOKUPNAMES4, api_lsa_LookupNames4},
	{"LSA_LSAROPENPOLICYSCE", DCERPC_LSA_LSAROPENPOLICYSCE, api_lsa_LSAROPENPOLICYSCE},
	{"LSA_LSARADTREGISTERSECURITYEVENTSOURCE", DCERPC_LSA_LSARADTREGISTERSECURITYEVENTSOURCE, api_lsa_LSARADTREGISTERSECURITYEVENTSOURCE},
	{"LSA_LSARADTUNREGISTERSECURITYEVENTSOURCE", DCERPC_LSA_LSARADTUNREGISTERSECURITYEVENTSOURCE, api_lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE},
	{"LSA_LSARADTREPORTSECURITYEVENT", DCERPC_LSA_LSARADTREPORTSECURITYEVENT, api_lsa_LSARADTREPORTSECURITYEVENT},
};

void lsarpc_get_pipe_fns(struct api_struct **fns, int *n_fns)
{
	*fns = api_lsarpc_cmds;
	*n_fns = sizeof(api_lsarpc_cmds) / sizeof(struct api_struct);
}

NTSTATUS rpc_lsarpc_init(void)
{
	return rpc_pipe_register_commands(SMB_RPC_INTERFACE_VERSION, "lsarpc", "lsarpc", api_lsarpc_cmds, sizeof(api_lsarpc_cmds) / sizeof(struct api_struct));
}
