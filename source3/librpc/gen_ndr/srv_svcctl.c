/*
 * Unix SMB/CIFS implementation.
 * server auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "librpc/gen_ndr/srv_svcctl.h"

static BOOL api_svcctl_CloseServiceHandle(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_CloseServiceHandle r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_CloseServiceHandle");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_CloseServiceHandle(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_CloseServiceHandle, &r);
	
	ZERO_STRUCT(r.out);
	r.out.handle = r.in.handle;
	r.out.result = _svcctl_CloseServiceHandle(p, r.in.handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_CloseServiceHandle, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_CloseServiceHandle(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_ControlService(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_ControlService r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_ControlService");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_ControlService(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_ControlService, &r);
	
	ZERO_STRUCT(r.out);
	r.out.status = talloc_zero(mem_ctx, struct SERVICE_STATUS);
	if (r.out.status == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_ControlService(p, r.in.handle, r.in.control, r.out.status);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_ControlService, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_ControlService(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_DeleteService(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_DeleteService r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_DeleteService");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_DeleteService(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_DeleteService, &r);
	
	r.out.result = _svcctl_DeleteService(p, r.in.handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_DeleteService, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_DeleteService(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_LockServiceDatabase(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_LockServiceDatabase r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_LockServiceDatabase");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_LockServiceDatabase(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_LockServiceDatabase, &r);
	
	ZERO_STRUCT(r.out);
	r.out.lock = talloc_zero(mem_ctx, struct policy_handle);
	if (r.out.lock == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_LockServiceDatabase(p, r.in.handle, r.out.lock);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_LockServiceDatabase, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_LockServiceDatabase(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_QueryServiceObjectSecurity(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_QueryServiceObjectSecurity r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_QueryServiceObjectSecurity");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_QueryServiceObjectSecurity(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceObjectSecurity, &r);
	
	r.out.result = _svcctl_QueryServiceObjectSecurity(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceObjectSecurity, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_QueryServiceObjectSecurity(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_SetServiceObjectSecurity(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_SetServiceObjectSecurity r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_SetServiceObjectSecurity");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_SetServiceObjectSecurity(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_SetServiceObjectSecurity, &r);
	
	r.out.result = _svcctl_SetServiceObjectSecurity(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_SetServiceObjectSecurity, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_SetServiceObjectSecurity(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_QueryServiceStatus(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_QueryServiceStatus r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_QueryServiceStatus");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_QueryServiceStatus(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceStatus, &r);
	
	ZERO_STRUCT(r.out);
	r.out.status = talloc_zero(mem_ctx, struct SERVICE_STATUS);
	if (r.out.status == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_QueryServiceStatus(p, r.in.handle, r.out.status);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceStatus, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_QueryServiceStatus(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_SetServiceStatus(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_SetServiceStatus r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_SetServiceStatus");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_SetServiceStatus(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_SetServiceStatus, &r);
	
	r.out.result = _svcctl_SetServiceStatus(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_SetServiceStatus, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_SetServiceStatus(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_UnlockServiceDatabase(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_UnlockServiceDatabase r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_UnlockServiceDatabase");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_UnlockServiceDatabase(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_UnlockServiceDatabase, &r);
	
	ZERO_STRUCT(r.out);
	r.out.lock = r.in.lock;
	r.out.result = _svcctl_UnlockServiceDatabase(p, r.in.lock);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_UnlockServiceDatabase, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_UnlockServiceDatabase(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_NotifyBootConfigStatus(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_NotifyBootConfigStatus r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_NotifyBootConfigStatus");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_NotifyBootConfigStatus(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_NotifyBootConfigStatus, &r);
	
	r.out.result = _svcctl_NotifyBootConfigStatus(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_NotifyBootConfigStatus, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_NotifyBootConfigStatus(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_SCSetServiceBitsW(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_SCSetServiceBitsW r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_SCSetServiceBitsW");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_SCSetServiceBitsW(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_SCSetServiceBitsW, &r);
	
	r.out.result = _svcctl_SCSetServiceBitsW(p, r.in.handle, r.in.bits, r.in.bitson, r.in.immediate);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_SCSetServiceBitsW, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_SCSetServiceBitsW(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_ChangeServiceConfigW(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_ChangeServiceConfigW r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_ChangeServiceConfigW");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_ChangeServiceConfigW(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_ChangeServiceConfigW, &r);
	
	ZERO_STRUCT(r.out);
	r.out.tag_id = talloc_zero(mem_ctx, uint32_t);
	if (r.out.tag_id == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_ChangeServiceConfigW(p, r.in.handle, r.in.type, r.in.start, r.in.error, r.in.binary_path, r.in.load_order_group, r.out.tag_id, r.in.dependencies, r.in.service_start_name, r.in.password, r.in.display_name);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_ChangeServiceConfigW, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_ChangeServiceConfigW(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_CreateServiceW(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_CreateServiceW r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_CreateServiceW");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_CreateServiceW(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_CreateServiceW, &r);
	
	ZERO_STRUCT(r.out);
	r.out.TagId = r.in.TagId;
	r.out.handle = talloc_zero(mem_ctx, struct policy_handle);
	if (r.out.handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_CreateServiceW(p, r.in.scmanager_handle, r.in.ServiceName, r.in.DisplayName, r.in.desired_access, r.in.type, r.in.start_type, r.in.error_control, r.in.binary_path, r.in.LoadOrderGroupKey, r.in.TagId, r.in.dependencies, r.in.dependencies_size, r.in.service_start_name, r.in.password, r.in.password_size, r.out.handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_CreateServiceW, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_CreateServiceW(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_EnumDependentServicesW(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_EnumDependentServicesW r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_EnumDependentServicesW");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_EnumDependentServicesW(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_EnumDependentServicesW, &r);
	
	ZERO_STRUCT(r.out);
	r.out.status = talloc_zero(mem_ctx, struct ENUM_SERVICE_STATUS);
	if (r.out.status == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.bytes_needed = talloc_zero(mem_ctx, uint32_t);
	if (r.out.bytes_needed == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.services_returned = talloc_zero(mem_ctx, uint32_t);
	if (r.out.services_returned == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_EnumDependentServicesW(p, r.in.service, r.in.state, r.out.status, r.in.buf_size, r.out.bytes_needed, r.out.services_returned);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_EnumDependentServicesW, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_EnumDependentServicesW(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_EnumServicesStatusW(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_EnumServicesStatusW r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_EnumServicesStatusW");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_EnumServicesStatusW(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_EnumServicesStatusW, &r);
	
	ZERO_STRUCT(r.out);
	r.out.service = talloc_zero_array(mem_ctx, uint8_t, r.in.buf_size);
	if (r.out.service == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.bytes_needed = talloc_zero(mem_ctx, uint32_t);
	if (r.out.bytes_needed == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.services_returned = talloc_zero(mem_ctx, uint32_t);
	if (r.out.services_returned == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.resume_handle = r.in.resume_handle;
	r.out.result = _svcctl_EnumServicesStatusW(p, r.in.handle, r.in.type, r.in.state, r.in.buf_size, r.out.service, r.out.bytes_needed, r.out.services_returned, r.in.resume_handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_EnumServicesStatusW, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_EnumServicesStatusW(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_OpenSCManagerW(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_OpenSCManagerW r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_OpenSCManagerW");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_OpenSCManagerW(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_OpenSCManagerW, &r);
	
	ZERO_STRUCT(r.out);
	r.out.handle = talloc_zero(mem_ctx, struct policy_handle);
	if (r.out.handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_OpenSCManagerW(p, r.in.MachineName, r.in.DatabaseName, r.in.access_mask, r.out.handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_OpenSCManagerW, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_OpenSCManagerW(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_OpenServiceW(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_OpenServiceW r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_OpenServiceW");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_OpenServiceW(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_OpenServiceW, &r);
	
	ZERO_STRUCT(r.out);
	r.out.handle = talloc_zero(mem_ctx, struct policy_handle);
	if (r.out.handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_OpenServiceW(p, r.in.scmanager_handle, r.in.ServiceName, r.in.access_mask, r.out.handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_OpenServiceW, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_OpenServiceW(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_QueryServiceConfigW(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_QueryServiceConfigW r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_QueryServiceConfigW");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_QueryServiceConfigW(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceConfigW, &r);
	
	ZERO_STRUCT(r.out);
	r.out.query = talloc_zero_array(mem_ctx, uint8_t, r.in.buf_size);
	if (r.out.query == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.bytes_needed = talloc_zero(mem_ctx, uint32_t);
	if (r.out.bytes_needed == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_QueryServiceConfigW(p, r.in.handle, r.out.query, r.in.buf_size, r.out.bytes_needed);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceConfigW, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_QueryServiceConfigW(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_QueryServiceLockStatusW(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_QueryServiceLockStatusW r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_QueryServiceLockStatusW");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_QueryServiceLockStatusW(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceLockStatusW, &r);
	
	ZERO_STRUCT(r.out);
	r.out.status = talloc_zero(mem_ctx, struct SERVICE_LOCK_STATUS);
	if (r.out.status == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.required_buf_size = talloc_zero(mem_ctx, uint32_t);
	if (r.out.required_buf_size == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_QueryServiceLockStatusW(p, r.in.handle, r.in.buf_size, r.out.status, r.out.required_buf_size);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceLockStatusW, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_QueryServiceLockStatusW(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_StartServiceW(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_StartServiceW r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_StartServiceW");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_StartServiceW(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_StartServiceW, &r);
	
	r.out.result = _svcctl_StartServiceW(p, r.in.handle, r.in.NumArgs, r.in.Arguments);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_StartServiceW, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_StartServiceW(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_GetServiceDisplayNameW(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_GetServiceDisplayNameW r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_GetServiceDisplayNameW");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_GetServiceDisplayNameW(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_GetServiceDisplayNameW, &r);
	
	ZERO_STRUCT(r.out);
	r.out.display_name = talloc_zero(mem_ctx, const char *);
	if (r.out.display_name == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.display_name_length = r.in.display_name_length;
	r.out.result = _svcctl_GetServiceDisplayNameW(p, r.in.handle, r.in.service_name, r.out.display_name, r.in.display_name_length);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_GetServiceDisplayNameW, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_GetServiceDisplayNameW(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_GetServiceKeyNameW(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_GetServiceKeyNameW r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_GetServiceKeyNameW");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_GetServiceKeyNameW(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_GetServiceKeyNameW, &r);
	
	ZERO_STRUCT(r.out);
	r.out.key_name = talloc_zero(mem_ctx, const char *);
	if (r.out.key_name == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.display_name_length = r.in.display_name_length;
	r.out.result = _svcctl_GetServiceKeyNameW(p, r.in.handle, r.in.service_name, r.out.key_name, r.in.display_name_length);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_GetServiceKeyNameW, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_GetServiceKeyNameW(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_SCSetServiceBitsA(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_SCSetServiceBitsA r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_SCSetServiceBitsA");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_SCSetServiceBitsA(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_SCSetServiceBitsA, &r);
	
	r.out.result = _svcctl_SCSetServiceBitsA(p, r.in.handle, r.in.bits, r.in.bitson, r.in.immediate);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_SCSetServiceBitsA, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_SCSetServiceBitsA(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_ChangeServiceConfigA(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_ChangeServiceConfigA r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_ChangeServiceConfigA");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_ChangeServiceConfigA(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_ChangeServiceConfigA, &r);
	
	ZERO_STRUCT(r.out);
	r.out.tag_id = talloc_zero(mem_ctx, uint32_t);
	if (r.out.tag_id == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_ChangeServiceConfigA(p, r.in.handle, r.in.type, r.in.start, r.in.error, r.in.binary_path, r.in.load_order_group, r.out.tag_id, r.in.dependencies, r.in.service_start_name, r.in.password, r.in.display_name);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_ChangeServiceConfigA, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_ChangeServiceConfigA(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_CreateServiceA(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_CreateServiceA r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_CreateServiceA");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_CreateServiceA(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_CreateServiceA, &r);
	
	ZERO_STRUCT(r.out);
	r.out.TagId = talloc_zero(mem_ctx, uint32_t);
	if (r.out.TagId == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_CreateServiceA(p, r.in.handle, r.in.ServiceName, r.in.DisplayName, r.in.desired_access, r.in.type, r.in.start_type, r.in.error_control, r.in.binary_path, r.in.LoadOrderGroupKey, r.out.TagId, r.in.dependencies, r.in.service_start_name, r.in.password);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_CreateServiceA, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_CreateServiceA(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_EnumDependentServicesA(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_EnumDependentServicesA r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_EnumDependentServicesA");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_EnumDependentServicesA(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_EnumDependentServicesA, &r);
	
	ZERO_STRUCT(r.out);
	r.out.status = talloc_zero(mem_ctx, struct ENUM_SERVICE_STATUS);
	if (r.out.status == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.bytes_needed = talloc_zero(mem_ctx, uint32_t);
	if (r.out.bytes_needed == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.services_returned = talloc_zero(mem_ctx, uint32_t);
	if (r.out.services_returned == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_EnumDependentServicesA(p, r.in.service, r.in.state, r.out.status, r.in.buf_size, r.out.bytes_needed, r.out.services_returned);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_EnumDependentServicesA, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_EnumDependentServicesA(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_EnumServicesStatusA(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_EnumServicesStatusA r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_EnumServicesStatusA");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_EnumServicesStatusA(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_EnumServicesStatusA, &r);
	
	ZERO_STRUCT(r.out);
	r.out.service = talloc_zero_array(mem_ctx, uint8_t, r.in.buf_size);
	if (r.out.service == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.bytes_needed = talloc_zero(mem_ctx, uint32_t);
	if (r.out.bytes_needed == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.services_returned = talloc_zero(mem_ctx, uint32_t);
	if (r.out.services_returned == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.resume_handle = r.in.resume_handle;
	r.out.result = _svcctl_EnumServicesStatusA(p, r.in.handle, r.in.type, r.in.state, r.in.buf_size, r.out.service, r.out.bytes_needed, r.out.services_returned, r.in.resume_handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_EnumServicesStatusA, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_EnumServicesStatusA(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_OpenSCManagerA(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_OpenSCManagerA r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_OpenSCManagerA");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_OpenSCManagerA(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_OpenSCManagerA, &r);
	
	ZERO_STRUCT(r.out);
	r.out.handle = talloc_zero(mem_ctx, struct policy_handle);
	if (r.out.handle == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_OpenSCManagerA(p, r.in.MachineName, r.in.DatabaseName, r.in.access_mask, r.out.handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_OpenSCManagerA, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_OpenSCManagerA(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_OpenServiceA(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_OpenServiceA r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_OpenServiceA");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_OpenServiceA(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_OpenServiceA, &r);
	
	r.out.result = _svcctl_OpenServiceA(p, r.in.scmanager_handle, r.in.ServiceName, r.in.access_mask);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_OpenServiceA, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_OpenServiceA(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_QueryServiceConfigA(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_QueryServiceConfigA r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_QueryServiceConfigA");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_QueryServiceConfigA(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceConfigA, &r);
	
	ZERO_STRUCT(r.out);
	r.out.query = talloc_zero_array(mem_ctx, uint8_t, r.in.buf_size);
	if (r.out.query == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.bytes_needed = talloc_zero(mem_ctx, uint32_t);
	if (r.out.bytes_needed == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_QueryServiceConfigA(p, r.in.handle, r.out.query, r.in.buf_size, r.out.bytes_needed);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceConfigA, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_QueryServiceConfigA(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_QueryServiceLockStatusA(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_QueryServiceLockStatusA r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_QueryServiceLockStatusA");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_QueryServiceLockStatusA(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceLockStatusA, &r);
	
	ZERO_STRUCT(r.out);
	r.out.status = talloc_zero(mem_ctx, struct SERVICE_LOCK_STATUS);
	if (r.out.status == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.required_buf_size = talloc_zero(mem_ctx, uint32_t);
	if (r.out.required_buf_size == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_QueryServiceLockStatusA(p, r.in.handle, r.in.buf_size, r.out.status, r.out.required_buf_size);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceLockStatusA, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_QueryServiceLockStatusA(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_StartServiceA(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_StartServiceA r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_StartServiceA");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_StartServiceA(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_StartServiceA, &r);
	
	r.out.result = _svcctl_StartServiceA(p, r.in.handle, r.in.NumArgs, r.in.Arguments);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_StartServiceA, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_StartServiceA(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_GetServiceDisplayNameA(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_GetServiceDisplayNameA r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_GetServiceDisplayNameA");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_GetServiceDisplayNameA(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_GetServiceDisplayNameA, &r);
	
	ZERO_STRUCT(r.out);
	r.out.display_name = talloc_zero(mem_ctx, const char *);
	if (r.out.display_name == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.display_name_length = r.in.display_name_length;
	r.out.result = _svcctl_GetServiceDisplayNameA(p, r.in.handle, r.in.service_name, r.out.display_name, r.in.display_name_length);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_GetServiceDisplayNameA, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_GetServiceDisplayNameA(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_GetServiceKeyNameA(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_GetServiceKeyNameA r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_GetServiceKeyNameA");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_GetServiceKeyNameA(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_GetServiceKeyNameA, &r);
	
	ZERO_STRUCT(r.out);
	r.out.key_name = talloc_zero(mem_ctx, const char *);
	if (r.out.key_name == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.display_name_length = r.in.display_name_length;
	r.out.result = _svcctl_GetServiceKeyNameA(p, r.in.handle, r.in.service_name, r.out.key_name, r.in.display_name_length);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_GetServiceKeyNameA, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_GetServiceKeyNameA(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_GetCurrentGroupeStateW(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_GetCurrentGroupeStateW r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_GetCurrentGroupeStateW");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_GetCurrentGroupeStateW(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_GetCurrentGroupeStateW, &r);
	
	r.out.result = _svcctl_GetCurrentGroupeStateW(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_GetCurrentGroupeStateW, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_GetCurrentGroupeStateW(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_EnumServiceGroupW(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_EnumServiceGroupW r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_EnumServiceGroupW");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_EnumServiceGroupW(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_EnumServiceGroupW, &r);
	
	r.out.result = _svcctl_EnumServiceGroupW(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_EnumServiceGroupW, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_EnumServiceGroupW(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_ChangeServiceConfig2A(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_ChangeServiceConfig2A r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_ChangeServiceConfig2A");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_ChangeServiceConfig2A(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_ChangeServiceConfig2A, &r);
	
	r.out.result = _svcctl_ChangeServiceConfig2A(p, r.in.handle, r.in.info_level, r.in.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_ChangeServiceConfig2A, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_ChangeServiceConfig2A(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_ChangeServiceConfig2W(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_ChangeServiceConfig2W r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_ChangeServiceConfig2W");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_ChangeServiceConfig2W(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_ChangeServiceConfig2W, &r);
	
	r.out.result = _svcctl_ChangeServiceConfig2W(p, r.in.handle, r.in.info_level, r.in.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_ChangeServiceConfig2W, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_ChangeServiceConfig2W(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_QueryServiceConfig2A(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_QueryServiceConfig2A r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_QueryServiceConfig2A");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_QueryServiceConfig2A(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceConfig2A, &r);
	
	ZERO_STRUCT(r.out);
	r.out.buffer = talloc_zero_array(mem_ctx, uint8_t, r.in.buf_size);
	if (r.out.buffer == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.bytes_needed = talloc_zero(mem_ctx, uint32_t);
	if (r.out.bytes_needed == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_QueryServiceConfig2A(p, r.in.handle, r.in.info_level, r.out.buffer, r.in.buf_size, r.out.bytes_needed);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceConfig2A, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_QueryServiceConfig2A(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_QueryServiceConfig2W(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_QueryServiceConfig2W r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_QueryServiceConfig2W");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_QueryServiceConfig2W(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceConfig2W, &r);
	
	ZERO_STRUCT(r.out);
	r.out.buffer = talloc_zero_array(mem_ctx, uint8_t, r.in.buf_size);
	if (r.out.buffer == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.bytes_needed = talloc_zero(mem_ctx, uint32_t);
	if (r.out.bytes_needed == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_QueryServiceConfig2W(p, r.in.handle, r.in.info_level, r.out.buffer, r.in.buf_size, r.out.bytes_needed);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceConfig2W, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_QueryServiceConfig2W(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_QueryServiceStatusEx(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_QueryServiceStatusEx r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_QueryServiceStatusEx");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_QueryServiceStatusEx(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceStatusEx, &r);
	
	ZERO_STRUCT(r.out);
	r.out.buffer = talloc_zero_array(mem_ctx, uint8_t, r.in.buf_size);
	if (r.out.buffer == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.bytes_needed = talloc_zero(mem_ctx, uint32_t);
	if (r.out.bytes_needed == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _svcctl_QueryServiceStatusEx(p, r.in.handle, r.in.info_level, r.out.buffer, r.in.buf_size, r.out.bytes_needed);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceStatusEx, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_QueryServiceStatusEx(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_EnumServicesStatusExA(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct EnumServicesStatusExA r;
	TALLOC_CTX *mem_ctx = talloc_init("api_EnumServicesStatusExA");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_EnumServicesStatusExA(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(EnumServicesStatusExA, &r);
	
	ZERO_STRUCT(r.out);
	r.out.services = talloc_zero_array(mem_ctx, uint8_t, r.in.buf_size);
	if (r.out.services == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.bytes_needed = talloc_zero(mem_ctx, uint32_t);
	if (r.out.bytes_needed == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.service_returned = talloc_zero(mem_ctx, uint32_t);
	if (r.out.service_returned == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.resume_handle = r.in.resume_handle;
	r.out.group_name = talloc_zero(mem_ctx, const char *);
	if (r.out.group_name == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _EnumServicesStatusExA(p, r.in.scmanager, r.in.info_level, r.in.type, r.in.state, r.out.services, r.in.buf_size, r.out.bytes_needed, r.out.service_returned, r.in.resume_handle, r.out.group_name);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(EnumServicesStatusExA, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_EnumServicesStatusExA(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_EnumServicesStatusExW(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct EnumServicesStatusExW r;
	TALLOC_CTX *mem_ctx = talloc_init("api_EnumServicesStatusExW");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_EnumServicesStatusExW(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(EnumServicesStatusExW, &r);
	
	ZERO_STRUCT(r.out);
	r.out.services = talloc_zero_array(mem_ctx, uint8_t, r.in.buf_size);
	if (r.out.services == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.bytes_needed = talloc_zero(mem_ctx, uint32_t);
	if (r.out.bytes_needed == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.service_returned = talloc_zero(mem_ctx, uint32_t);
	if (r.out.service_returned == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.resume_handle = r.in.resume_handle;
	r.out.group_name = talloc_zero(mem_ctx, const char *);
	if (r.out.group_name == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _EnumServicesStatusExW(p, r.in.scmanager, r.in.info_level, r.in.type, r.in.state, r.out.services, r.in.buf_size, r.out.bytes_needed, r.out.service_returned, r.in.resume_handle, r.out.group_name);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(EnumServicesStatusExW, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_EnumServicesStatusExW(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_svcctl_SCSendTSMessage(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct svcctl_SCSendTSMessage r;
	TALLOC_CTX *mem_ctx = talloc_init("api_svcctl_SCSendTSMessage");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_svcctl_SCSendTSMessage(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(svcctl_SCSendTSMessage, &r);
	
	r.out.result = _svcctl_SCSendTSMessage(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(svcctl_SCSendTSMessage, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_svcctl_SCSendTSMessage(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}


/* Tables */
static struct api_struct api_svcctl_cmds[] = 
{
	{"SVCCTL_CLOSESERVICEHANDLE", DCERPC_SVCCTL_CLOSESERVICEHANDLE, api_svcctl_CloseServiceHandle},
	{"SVCCTL_CONTROLSERVICE", DCERPC_SVCCTL_CONTROLSERVICE, api_svcctl_ControlService},
	{"SVCCTL_DELETESERVICE", DCERPC_SVCCTL_DELETESERVICE, api_svcctl_DeleteService},
	{"SVCCTL_LOCKSERVICEDATABASE", DCERPC_SVCCTL_LOCKSERVICEDATABASE, api_svcctl_LockServiceDatabase},
	{"SVCCTL_QUERYSERVICEOBJECTSECURITY", DCERPC_SVCCTL_QUERYSERVICEOBJECTSECURITY, api_svcctl_QueryServiceObjectSecurity},
	{"SVCCTL_SETSERVICEOBJECTSECURITY", DCERPC_SVCCTL_SETSERVICEOBJECTSECURITY, api_svcctl_SetServiceObjectSecurity},
	{"SVCCTL_QUERYSERVICESTATUS", DCERPC_SVCCTL_QUERYSERVICESTATUS, api_svcctl_QueryServiceStatus},
	{"SVCCTL_SETSERVICESTATUS", DCERPC_SVCCTL_SETSERVICESTATUS, api_svcctl_SetServiceStatus},
	{"SVCCTL_UNLOCKSERVICEDATABASE", DCERPC_SVCCTL_UNLOCKSERVICEDATABASE, api_svcctl_UnlockServiceDatabase},
	{"SVCCTL_NOTIFYBOOTCONFIGSTATUS", DCERPC_SVCCTL_NOTIFYBOOTCONFIGSTATUS, api_svcctl_NotifyBootConfigStatus},
	{"SVCCTL_SCSETSERVICEBITSW", DCERPC_SVCCTL_SCSETSERVICEBITSW, api_svcctl_SCSetServiceBitsW},
	{"SVCCTL_CHANGESERVICECONFIGW", DCERPC_SVCCTL_CHANGESERVICECONFIGW, api_svcctl_ChangeServiceConfigW},
	{"SVCCTL_CREATESERVICEW", DCERPC_SVCCTL_CREATESERVICEW, api_svcctl_CreateServiceW},
	{"SVCCTL_ENUMDEPENDENTSERVICESW", DCERPC_SVCCTL_ENUMDEPENDENTSERVICESW, api_svcctl_EnumDependentServicesW},
	{"SVCCTL_ENUMSERVICESSTATUSW", DCERPC_SVCCTL_ENUMSERVICESSTATUSW, api_svcctl_EnumServicesStatusW},
	{"SVCCTL_OPENSCMANAGERW", DCERPC_SVCCTL_OPENSCMANAGERW, api_svcctl_OpenSCManagerW},
	{"SVCCTL_OPENSERVICEW", DCERPC_SVCCTL_OPENSERVICEW, api_svcctl_OpenServiceW},
	{"SVCCTL_QUERYSERVICECONFIGW", DCERPC_SVCCTL_QUERYSERVICECONFIGW, api_svcctl_QueryServiceConfigW},
	{"SVCCTL_QUERYSERVICELOCKSTATUSW", DCERPC_SVCCTL_QUERYSERVICELOCKSTATUSW, api_svcctl_QueryServiceLockStatusW},
	{"SVCCTL_STARTSERVICEW", DCERPC_SVCCTL_STARTSERVICEW, api_svcctl_StartServiceW},
	{"SVCCTL_GETSERVICEDISPLAYNAMEW", DCERPC_SVCCTL_GETSERVICEDISPLAYNAMEW, api_svcctl_GetServiceDisplayNameW},
	{"SVCCTL_GETSERVICEKEYNAMEW", DCERPC_SVCCTL_GETSERVICEKEYNAMEW, api_svcctl_GetServiceKeyNameW},
	{"SVCCTL_SCSETSERVICEBITSA", DCERPC_SVCCTL_SCSETSERVICEBITSA, api_svcctl_SCSetServiceBitsA},
	{"SVCCTL_CHANGESERVICECONFIGA", DCERPC_SVCCTL_CHANGESERVICECONFIGA, api_svcctl_ChangeServiceConfigA},
	{"SVCCTL_CREATESERVICEA", DCERPC_SVCCTL_CREATESERVICEA, api_svcctl_CreateServiceA},
	{"SVCCTL_ENUMDEPENDENTSERVICESA", DCERPC_SVCCTL_ENUMDEPENDENTSERVICESA, api_svcctl_EnumDependentServicesA},
	{"SVCCTL_ENUMSERVICESSTATUSA", DCERPC_SVCCTL_ENUMSERVICESSTATUSA, api_svcctl_EnumServicesStatusA},
	{"SVCCTL_OPENSCMANAGERA", DCERPC_SVCCTL_OPENSCMANAGERA, api_svcctl_OpenSCManagerA},
	{"SVCCTL_OPENSERVICEA", DCERPC_SVCCTL_OPENSERVICEA, api_svcctl_OpenServiceA},
	{"SVCCTL_QUERYSERVICECONFIGA", DCERPC_SVCCTL_QUERYSERVICECONFIGA, api_svcctl_QueryServiceConfigA},
	{"SVCCTL_QUERYSERVICELOCKSTATUSA", DCERPC_SVCCTL_QUERYSERVICELOCKSTATUSA, api_svcctl_QueryServiceLockStatusA},
	{"SVCCTL_STARTSERVICEA", DCERPC_SVCCTL_STARTSERVICEA, api_svcctl_StartServiceA},
	{"SVCCTL_GETSERVICEDISPLAYNAMEA", DCERPC_SVCCTL_GETSERVICEDISPLAYNAMEA, api_svcctl_GetServiceDisplayNameA},
	{"SVCCTL_GETSERVICEKEYNAMEA", DCERPC_SVCCTL_GETSERVICEKEYNAMEA, api_svcctl_GetServiceKeyNameA},
	{"SVCCTL_GETCURRENTGROUPESTATEW", DCERPC_SVCCTL_GETCURRENTGROUPESTATEW, api_svcctl_GetCurrentGroupeStateW},
	{"SVCCTL_ENUMSERVICEGROUPW", DCERPC_SVCCTL_ENUMSERVICEGROUPW, api_svcctl_EnumServiceGroupW},
	{"SVCCTL_CHANGESERVICECONFIG2A", DCERPC_SVCCTL_CHANGESERVICECONFIG2A, api_svcctl_ChangeServiceConfig2A},
	{"SVCCTL_CHANGESERVICECONFIG2W", DCERPC_SVCCTL_CHANGESERVICECONFIG2W, api_svcctl_ChangeServiceConfig2W},
	{"SVCCTL_QUERYSERVICECONFIG2A", DCERPC_SVCCTL_QUERYSERVICECONFIG2A, api_svcctl_QueryServiceConfig2A},
	{"SVCCTL_QUERYSERVICECONFIG2W", DCERPC_SVCCTL_QUERYSERVICECONFIG2W, api_svcctl_QueryServiceConfig2W},
	{"SVCCTL_QUERYSERVICESTATUSEX", DCERPC_SVCCTL_QUERYSERVICESTATUSEX, api_svcctl_QueryServiceStatusEx},
	{"ENUMSERVICESSTATUSEXA", DCERPC_ENUMSERVICESSTATUSEXA, api_EnumServicesStatusExA},
	{"ENUMSERVICESSTATUSEXW", DCERPC_ENUMSERVICESSTATUSEXW, api_EnumServicesStatusExW},
	{"SVCCTL_SCSENDTSMESSAGE", DCERPC_SVCCTL_SCSENDTSMESSAGE, api_svcctl_SCSendTSMessage},
};

void svcctl_get_pipe_fns(struct api_struct **fns, int *n_fns)
{
	*fns = api_svcctl_cmds;
	*n_fns = sizeof(api_svcctl_cmds) / sizeof(struct api_struct);
}

NTSTATUS rpc_svcctl_init(void)
{
	return rpc_pipe_register_commands(SMB_RPC_INTERFACE_VERSION, "svcctl", "svcctl", api_svcctl_cmds, sizeof(api_svcctl_cmds) / sizeof(struct api_struct));
}
