/*
 * Unix SMB/CIFS implementation.
 * client auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "librpc/gen_ndr/cli_wbint.h"

struct rpccli_wbint_Ping_state {
	struct wbint_Ping orig;
	struct wbint_Ping tmp;
	TALLOC_CTX *out_mem_ctx;
	NTSTATUS (*dispatch_recv)(struct tevent_req *req, TALLOC_CTX *mem_ctx);
};

static void rpccli_wbint_Ping_done(struct tevent_req *subreq);

struct tevent_req *rpccli_wbint_Ping_send(TALLOC_CTX *mem_ctx,
					  struct tevent_context *ev,
					  struct rpc_pipe_client *cli,
					  uint32_t _in_data /* [in]  */,
					  uint32_t *_out_data /* [out] [ref] */)
{
	struct tevent_req *req;
	struct rpccli_wbint_Ping_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct rpccli_wbint_Ping_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;
	state->dispatch_recv = cli->dispatch_recv;

	/* In parameters */
	state->orig.in.in_data = _in_data;

	/* Out parameters */
	state->orig.out.out_data = _out_data;

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(wbint_Ping, &state->orig);
	}

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "rpccli_wbint_Ping_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = cli->dispatch_send(state, ev, cli,
				    &ndr_table_wbint,
				    NDR_WBINT_PING,
				    &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, rpccli_wbint_Ping_done, req);
	return req;
}

static void rpccli_wbint_Ping_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct rpccli_wbint_Ping_state *state = tevent_req_data(
		req, struct rpccli_wbint_Ping_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = state->dispatch_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.out_data = *state->tmp.out.out_data;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(wbint_Ping, &state->orig);
	}

	tevent_req_done(req);
}

NTSTATUS rpccli_wbint_Ping_recv(struct tevent_req *req,
				TALLOC_CTX *mem_ctx)
{
	struct rpccli_wbint_Ping_state *state = tevent_req_data(
		req, struct rpccli_wbint_Ping_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possbile out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS rpccli_wbint_Ping(struct rpc_pipe_client *cli,
			   TALLOC_CTX *mem_ctx,
			   uint32_t in_data /* [in]  */,
			   uint32_t *out_data /* [out] [ref] */)
{
	struct wbint_Ping r;
	NTSTATUS status;

	/* In parameters */
	r.in.in_data = in_data;

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(wbint_Ping, &r);
	}

	status = cli->dispatch(cli,
				mem_ctx,
				&ndr_table_wbint,
				NDR_WBINT_PING,
				&r);

	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(wbint_Ping, &r);
	}

	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}

	/* Return variables */
	*out_data = *r.out.out_data;

	/* Return result */
	return NT_STATUS_OK;
}

struct rpccli_wbint_LookupSid_state {
	struct wbint_LookupSid orig;
	struct wbint_LookupSid tmp;
	TALLOC_CTX *out_mem_ctx;
	NTSTATUS (*dispatch_recv)(struct tevent_req *req, TALLOC_CTX *mem_ctx);
};

static void rpccli_wbint_LookupSid_done(struct tevent_req *subreq);

struct tevent_req *rpccli_wbint_LookupSid_send(TALLOC_CTX *mem_ctx,
					       struct tevent_context *ev,
					       struct rpc_pipe_client *cli,
					       struct dom_sid *_sid /* [in] [ref] */,
					       enum lsa_SidType *_type /* [out] [ref] */,
					       const char **_domain /* [out] [ref,charset(UTF8)] */,
					       const char **_name /* [out] [ref,charset(UTF8)] */)
{
	struct tevent_req *req;
	struct rpccli_wbint_LookupSid_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct rpccli_wbint_LookupSid_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;
	state->dispatch_recv = cli->dispatch_recv;

	/* In parameters */
	state->orig.in.sid = _sid;

	/* Out parameters */
	state->orig.out.type = _type;
	state->orig.out.domain = _domain;
	state->orig.out.name = _name;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(wbint_LookupSid, &state->orig);
	}

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "rpccli_wbint_LookupSid_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = cli->dispatch_send(state, ev, cli,
				    &ndr_table_wbint,
				    NDR_WBINT_LOOKUPSID,
				    &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, rpccli_wbint_LookupSid_done, req);
	return req;
}

static void rpccli_wbint_LookupSid_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct rpccli_wbint_LookupSid_state *state = tevent_req_data(
		req, struct rpccli_wbint_LookupSid_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = state->dispatch_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.type = *state->tmp.out.type;
	*state->orig.out.domain = *state->tmp.out.domain;
	*state->orig.out.name = *state->tmp.out.name;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(wbint_LookupSid, &state->orig);
	}

	tevent_req_done(req);
}

NTSTATUS rpccli_wbint_LookupSid_recv(struct tevent_req *req,
				     TALLOC_CTX *mem_ctx,
				     NTSTATUS *result)
{
	struct rpccli_wbint_LookupSid_state *state = tevent_req_data(
		req, struct rpccli_wbint_LookupSid_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possbile out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS rpccli_wbint_LookupSid(struct rpc_pipe_client *cli,
				TALLOC_CTX *mem_ctx,
				struct dom_sid *sid /* [in] [ref] */,
				enum lsa_SidType *type /* [out] [ref] */,
				const char **domain /* [out] [ref,charset(UTF8)] */,
				const char **name /* [out] [ref,charset(UTF8)] */)
{
	struct wbint_LookupSid r;
	NTSTATUS status;

	/* In parameters */
	r.in.sid = sid;

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(wbint_LookupSid, &r);
	}

	status = cli->dispatch(cli,
				mem_ctx,
				&ndr_table_wbint,
				NDR_WBINT_LOOKUPSID,
				&r);

	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(wbint_LookupSid, &r);
	}

	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}

	/* Return variables */
	*type = *r.out.type;
	*domain = *r.out.domain;
	*name = *r.out.name;

	/* Return result */
	return r.out.result;
}

