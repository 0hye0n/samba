#! /usr/bin/env python

srcdir = '..'
blddir = 'bin'

import sys, os
sys.path.insert(0, srcdir+"/buildtools/wafsamba")
import wafsamba, Options

def set_options(opt):
    opt.recurse('../lib/replace')
    opt.recurse('build')
    opt.recurse('../lib/nss_wrapper')
    opt.recurse('../lib/socket_wrapper')
    opt.recurse('../lib/uid_wrapper')

def configure(conf):
    conf.define('PACKAGE_NAME', 'Samba')
    conf.define('PACKAGE_STRING', 'Samba 3')
    conf.define('PACKAGE_TARNAME', 'samba')
    conf.define('PACKAGE_URL', '')
    conf.define('PACKAGE_VERSION', '3')
    conf.define('PACKAGE_BUGREPORT', 'samba-technical@samba.org')

    conf.DEFINE('CONFIG_H_IS_FROM_SAMBA', 1)
    conf.DEFINE('_SAMBA_BUILD_', 3, add_to_cflags=True)
    conf.DEFINE('HAVE_CONFIG_H', 1, add_to_cflags=True)
    if Options.options.developer:
        conf.ADD_CFLAGS('-DDEVELOPER -DDEBUG_PASSWORD')

    # set a limit on recursing in the waf preprocessor
    conf.env.preprocessor_recursion_limit = 10

    conf.ADD_EXTRA_INCLUDES('#source3 #source3/include #lib/replace #lib/talloc #lib/tevent #source3/libaddns #source3/librpc')

    conf.sub_config('../lib/replace')
    conf.sub_config('build')
    conf.sub_config('../lib/tdb')
    conf.sub_config('../lib/talloc')
    conf.sub_config('../lib/tevent')
    conf.sub_config('../lib/nss_wrapper')
    conf.sub_config('../lib/socket_wrapper')
    conf.sub_config('../lib/uid_wrapper')

    conf.CHECK_HEADERS('execinfo.h libexc.h libunwind.h')

    conf.CHECK_FUNCS('getcwd fchown chmod fchmod mknod mknod64')
    conf.CHECK_FUNCS('strtol strchr strupr chflags')
    conf.CHECK_FUNCS('getrlimit fsync fdatasync setpgid')
    conf.CHECK_FUNCS('setsid glob strpbrk crypt16 getauthuid')
    conf.CHECK_FUNCS('sigprocmask sigblock sigaction sigset innetgr setnetgrent getnetgrent endnetgrent')
    conf.CHECK_FUNCS('initgroups select poll rdchk getgrnam getgrent pathconf')
    conf.CHECK_FUNCS('setpriv setgidx setuidx setgroups sysconf stat64 fstat64')
    conf.CHECK_FUNCS('lstat64 fopen64 atexit grantpt lseek64 ftruncate64 posix_fallocate posix_fallocate64')
    conf.CHECK_FUNCS('fseek64 fseeko64 ftell64 ftello64 setluid')
    conf.CHECK_FUNCS('getpwanam', headers='sys/types.h pwd.h')
    conf.CHECK_FUNCS('opendir64 readdir64 seekdir64 telldir64 rewinddir64 closedir64')
    conf.CHECK_FUNCS('getpwent_r getdents64 setenv strcasecmp fcvt fcvtl')
    conf.CHECK_FUNCS('syslog vsyslog timegm setlocale nl_langinfo')
    conf.CHECK_FUNCS_IN('nanosleep', 'rt')
    conf.CHECK_FUNCS('lutimes futimes utimensat futimens')
    conf.CHECK_FUNCS('mlock munlock mlockall munlockall')
    conf.CHECK_FUNCS('memalign posix_memalign hstrerror')
    conf.CHECK_FUNCS('shmget')
    conf.CHECK_FUNCS_IN('shm_open', 'rt', checklibc=True)
    conf.CHECK_FUNCS('gettext dgettext bindtextdomain textdomain')

    # Check for inotify support
    conf.CHECK_HEADERS('linux/inotify.h asm/unistd.h sys/inotify.h')
    conf.CHECK_FUNCS('inotify_init')
    if "HAVE_LINUX_INOTIFY_H" in conf.env and "HAVE_INOTIFY_INIT" in conf.env:
        conf.DEFINE('HAVE_INOTIFY', 1)

    # Check for kernel change notify support
    conf.CHECK_CODE('''
#include <sys/types.h>
#include <fcntl.h>
#include <signal.h>
#ifndef F_NOTIFY
#define F_NOTIFY 1026
#endif
main() {
        exit(fcntl(open("/tmp", O_RDONLY), F_NOTIFY, 0) == -1 ?  1 : 0);
}''', 'HAVE_KERNEL_CHANGE_NOTIFY', addmain=False, execute=True,
        msg="Checking for kernel change notify support")

    # Check for Linux kernel oplocks
    conf.CHECK_CODE('''
#include <sys/types.h>
#include <fcntl.h>
#include <signal.h>
#ifndef F_NOTIFY
#define F_NOTIFY 1026
#endif
main() {
        exit(fcntl(open("/tmp", O_RDONLY), F_NOTIFY, 0) == -1 ?  1 : 0);
}''', 'HAVE_KERNEL_OPLOCKS_LINUX', addmain=False, execute=True,
        msg="Checking for Linux kernel oplocks")

    # Check for IRIX kernel oplock types
    conf.CHECK_CODE('oplock_stat_t t; t.os_state = OP_REVOKE; t.os_dev = 1; t.os_ino = 1;',
                    'HAVE_KERNEL_OPLOCKS_IRIX', headers='sys/types.h fcntl.h',
                    msg="Checking for IRIX kernel oplock types")

    # Check for krenel share modes
    conf.CHECK_CODE('''
#include <sys/types.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/file.h>
#ifndef LOCK_MAND
#define LOCK_MAND	32
#define LOCK_READ	64
#endif
main() {
        exit(flock(open("/dev/null", O_RDWR), LOCK_MAND|LOCK_READ) != 0);
}''', 'HAVE_KERNEL_SHARE_MODES', addmain=False, execute=True,
        msg="Checking for krenel share modes")

    # Check for various members of the stat structure
    conf.CHECK_TYPES('blksize_t blkcnt_t')
    conf.CHECK_STRUCTURE_MEMBER('struct stat', 'st_blocks', define='HAVE_STAT_ST_BLOCKS',
                                headers='sys/types.h sys/stat.h unistd.h',)
    conf.CHECK_STRUCTURE_MEMBER('struct stat', 'st_blksize', define='HAVE_STAT_ST_BLKSIZE',
                                headers='sys/types.h sys/stat.h unistd.h')

    # Check for POSIX capability support
    if "HAVE_SYS_CAPABILITY_H" in conf.env:
        conf.CHECK_FUNCS_IN('cap_get_proc', 'cap')
        conf.CHECK_CODE('''
#include <sys/types.h>
#include <sys/capability.h>
main() {
 cap_t cap;
 cap_value_t vals[1];
 if (!(cap = cap_get_proc()))
   exit(1);
 vals[0] = CAP_CHOWN;
 cap_set_flag(cap, CAP_INHERITABLE, 1, vals, CAP_CLEAR);
 cap_set_proc(cap);
 exit(0);
 }''', 'HAVE_POSIX_CAPABILITIES', addmain=False, execute=True, lib="cap",
            msg="Checking whether POSIX capabilities are available")

    # Check for int16, uint16, int32 and uint32 in rpc/types.h included from
    # rpc/rpc.h. This is *really* broken but some systems (DEC OSF1) do this.
    # -- JRA.
    if "HAVE_RPC_RPC_H" in conf.env:
        conf.CHECK_CODE('int16 testvar;', 'HAVE_INT16_FROM_RPC_RPC_H',
                        headers='sys/types.h rpc/rpc.h',
                        msg="Checking for int16 typedef included by rpc/rpc.h")
        conf.CHECK_CODE('uint16 testvar;', 'HAVE_INT16_FROM_RPC_RPC_H',
                        headers='sys/types.h rpc/rpc.h',
                        msg="Checking for uint16 typedef included by rpc/rpc.h")
        conf.CHECK_CODE('int32 testvar;', 'HAVE_INT16_FROM_RPC_RPC_H',
                        headers='sys/types.h rpc/rpc.h',
                        msg="Checking for int32 typedef included by rpc/rpc.h")
        conf.CHECK_CODE('uint32 testvar;', 'HAVE_INT16_FROM_RPC_RPC_H',
                        headers='sys/types.h rpc/rpc.h',
                        msg="Checking for uint32 typedef included by rpc/rpc.h")

    # Check if the compiler will optimize out functions
    conf.CHECK_CODE('''
if (0) {
    this_function_does_not_exist();
} else {
    return 1;
}''', 'HAVE_COMPILER_WILL_OPTIMIZE_OUT_FNS',
        msg="Checking if the compiler will optimize out functions")

    # Look for CUPS
    conf.find_program('cups-config', var='CUPS_CONFIG')
    if conf.env.CUPS_CONFIG:
        conf.check_cfg(path="cups-config", args="--cflags --ldflags --libs", package="", uselib_store="CUPS")
        conf.CHECK_HEADERS('cups/cups.h cups/language.h')

    # Check for LDAP
    conf.CHECK_HEADERS('ldap.h lber.h')
    conf.CHECK_TYPE('ber_tag_t', 'unsigned int', headers='ldap.h lber.h')

    # Check for kerberos
    conf.find_program('krb5-config', var='KRB5_CONFIG')
    if conf.env.KRB5_CONFIG:
        conf.check_cfg(path="krb5-config", args="--cflags --libs",
                       package="gssapi", uselib_store="KRB5")
        conf.CHECK_HEADERS('krb5.h krb5/locate_plugin.h')
        conf.CHECK_HEADERS('gssapi.h gssapi/gssapi_generic.h gssapi/gssapi.h com_err.h')

    conf.SAMBA_CONFIG_H('include/config.h')
