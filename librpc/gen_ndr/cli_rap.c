/*
 * Unix SMB/CIFS implementation.
 * client auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "../librpc/gen_ndr/cli_rap.h"

struct rpccli_rap_NetShareEnum_state {
	struct rap_NetShareEnum orig;
	struct rap_NetShareEnum tmp;
	TALLOC_CTX *out_mem_ctx;
	NTSTATUS (*dispatch_recv)(struct tevent_req *req, TALLOC_CTX *mem_ctx);
};

static void rpccli_rap_NetShareEnum_done(struct tevent_req *subreq);

struct tevent_req *rpccli_rap_NetShareEnum_send(TALLOC_CTX *mem_ctx,
						struct tevent_context *ev,
						struct rpc_pipe_client *cli,
						uint16_t _level /* [in]  */,
						uint16_t _bufsize /* [in]  */,
						uint16_t _status /* [out]  */,
						uint16_t _convert /* [out]  */,
						uint16_t _count /* [out]  */,
						uint16_t _available /* [out]  */,
						union rap_share_info *_info /* [out] [ref,switch_is(level)] */)
{
	struct tevent_req *req;
	struct rpccli_rap_NetShareEnum_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct rpccli_rap_NetShareEnum_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;
	state->dispatch_recv = cli->dispatch_recv;

	/* In parameters */
	state->orig.in.level = _level;
	state->orig.in.bufsize = _bufsize;

	/* Out parameters */
	state->orig.out.status = _status;
	state->orig.out.convert = _convert;
	state->orig.out.count = _count;
	state->orig.out.available = _available;
	state->orig.out.info = _info;

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "rpccli_rap_NetShareEnum_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = cli->dispatch_send(state, ev, cli,
				    &ndr_table_rap,
				    NDR_RAP_NETSHAREENUM,
				    &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, rpccli_rap_NetShareEnum_done, req);
	return req;
}

static void rpccli_rap_NetShareEnum_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct rpccli_rap_NetShareEnum_state *state = tevent_req_data(
		req, struct rpccli_rap_NetShareEnum_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = state->dispatch_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	*state->orig.out.info = *state->tmp.out.info;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS rpccli_rap_NetShareEnum_recv(struct tevent_req *req,
				      TALLOC_CTX *mem_ctx)
{
	struct rpccli_rap_NetShareEnum_state *state = tevent_req_data(
		req, struct rpccli_rap_NetShareEnum_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possbile out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS rpccli_rap_NetShareEnum(struct rpc_pipe_client *cli,
				 TALLOC_CTX *mem_ctx,
				 uint16_t level /* [in]  */,
				 uint16_t bufsize /* [in]  */,
				 uint16_t status /* [out]  */,
				 uint16_t convert /* [out]  */,
				 uint16_t count /* [out]  */,
				 uint16_t available /* [out]  */,
				 union rap_share_info *info /* [out] [ref,switch_is(level)] */)
{
	struct rap_NetShareEnum r;
	NTSTATUS status;

	/* In parameters */
	r.in.level = level;
	r.in.bufsize = bufsize;

	status = cli->dispatch(cli,
				mem_ctx,
				&ndr_table_rap,
				NDR_RAP_NETSHAREENUM,
				&r);

	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}

	/* Return variables */
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	*info = *r.out.info;

	/* Return result */
	return NT_STATUS_OK;
}

struct rpccli_rap_NetServerEnum2_state {
	struct rap_NetServerEnum2 orig;
	struct rap_NetServerEnum2 tmp;
	TALLOC_CTX *out_mem_ctx;
	NTSTATUS (*dispatch_recv)(struct tevent_req *req, TALLOC_CTX *mem_ctx);
};

static void rpccli_rap_NetServerEnum2_done(struct tevent_req *subreq);

struct tevent_req *rpccli_rap_NetServerEnum2_send(TALLOC_CTX *mem_ctx,
						  struct tevent_context *ev,
						  struct rpc_pipe_client *cli,
						  uint16_t _level /* [in]  */,
						  uint16_t _bufsize /* [in]  */,
						  uint32_t _servertype /* [in]  */,
						  const char *_domain /* [in] [ref,charset(DOS)] */,
						  uint16_t _status /* [out]  */,
						  uint16_t _convert /* [out]  */,
						  uint16_t _count /* [out]  */,
						  uint16_t _available /* [out]  */,
						  union rap_server_info *_info /* [out] [ref,switch_is(level)] */)
{
	struct tevent_req *req;
	struct rpccli_rap_NetServerEnum2_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct rpccli_rap_NetServerEnum2_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;
	state->dispatch_recv = cli->dispatch_recv;

	/* In parameters */
	state->orig.in.level = _level;
	state->orig.in.bufsize = _bufsize;
	state->orig.in.servertype = _servertype;
	state->orig.in.domain = _domain;

	/* Out parameters */
	state->orig.out.status = _status;
	state->orig.out.convert = _convert;
	state->orig.out.count = _count;
	state->orig.out.available = _available;
	state->orig.out.info = _info;

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "rpccli_rap_NetServerEnum2_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = cli->dispatch_send(state, ev, cli,
				    &ndr_table_rap,
				    NDR_RAP_NETSERVERENUM2,
				    &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, rpccli_rap_NetServerEnum2_done, req);
	return req;
}

static void rpccli_rap_NetServerEnum2_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct rpccli_rap_NetServerEnum2_state *state = tevent_req_data(
		req, struct rpccli_rap_NetServerEnum2_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = state->dispatch_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	*state->orig.out.info = *state->tmp.out.info;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS rpccli_rap_NetServerEnum2_recv(struct tevent_req *req,
					TALLOC_CTX *mem_ctx)
{
	struct rpccli_rap_NetServerEnum2_state *state = tevent_req_data(
		req, struct rpccli_rap_NetServerEnum2_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possbile out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS rpccli_rap_NetServerEnum2(struct rpc_pipe_client *cli,
				   TALLOC_CTX *mem_ctx,
				   uint16_t level /* [in]  */,
				   uint16_t bufsize /* [in]  */,
				   uint32_t servertype /* [in]  */,
				   const char *domain /* [in] [ref,charset(DOS)] */,
				   uint16_t status /* [out]  */,
				   uint16_t convert /* [out]  */,
				   uint16_t count /* [out]  */,
				   uint16_t available /* [out]  */,
				   union rap_server_info *info /* [out] [ref,switch_is(level)] */)
{
	struct rap_NetServerEnum2 r;
	NTSTATUS status;

	/* In parameters */
	r.in.level = level;
	r.in.bufsize = bufsize;
	r.in.servertype = servertype;
	r.in.domain = domain;

	status = cli->dispatch(cli,
				mem_ctx,
				&ndr_table_rap,
				NDR_RAP_NETSERVERENUM2,
				&r);

	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}

	/* Return variables */
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	*info = *r.out.info;

	/* Return result */
	return NT_STATUS_OK;
}

struct rpccli_rap_WserverGetInfo_state {
	struct rap_WserverGetInfo orig;
	struct rap_WserverGetInfo tmp;
	TALLOC_CTX *out_mem_ctx;
	NTSTATUS (*dispatch_recv)(struct tevent_req *req, TALLOC_CTX *mem_ctx);
};

static void rpccli_rap_WserverGetInfo_done(struct tevent_req *subreq);

struct tevent_req *rpccli_rap_WserverGetInfo_send(TALLOC_CTX *mem_ctx,
						  struct tevent_context *ev,
						  struct rpc_pipe_client *cli,
						  uint16_t _level /* [in]  */,
						  uint16_t _bufsize /* [in]  */,
						  uint16_t _status /* [out]  */,
						  uint16_t _convert /* [out]  */,
						  uint16_t _available /* [out]  */,
						  union rap_server_info _info /* [out] [switch_is(level)] */)
{
	struct tevent_req *req;
	struct rpccli_rap_WserverGetInfo_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct rpccli_rap_WserverGetInfo_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;
	state->dispatch_recv = cli->dispatch_recv;

	/* In parameters */
	state->orig.in.level = _level;
	state->orig.in.bufsize = _bufsize;

	/* Out parameters */
	state->orig.out.status = _status;
	state->orig.out.convert = _convert;
	state->orig.out.available = _available;
	state->orig.out.info = _info;

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "rpccli_rap_WserverGetInfo_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = cli->dispatch_send(state, ev, cli,
				    &ndr_table_rap,
				    NDR_RAP_WSERVERGETINFO,
				    &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, rpccli_rap_WserverGetInfo_done, req);
	return req;
}

static void rpccli_rap_WserverGetInfo_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct rpccli_rap_WserverGetInfo_state *state = tevent_req_data(
		req, struct rpccli_rap_WserverGetInfo_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = state->dispatch_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS rpccli_rap_WserverGetInfo_recv(struct tevent_req *req,
					TALLOC_CTX *mem_ctx)
{
	struct rpccli_rap_WserverGetInfo_state *state = tevent_req_data(
		req, struct rpccli_rap_WserverGetInfo_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possbile out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS rpccli_rap_WserverGetInfo(struct rpc_pipe_client *cli,
				   TALLOC_CTX *mem_ctx,
				   uint16_t level /* [in]  */,
				   uint16_t bufsize /* [in]  */,
				   uint16_t status /* [out]  */,
				   uint16_t convert /* [out]  */,
				   uint16_t available /* [out]  */,
				   union rap_server_info info /* [out] [switch_is(level)] */)
{
	struct rap_WserverGetInfo r;
	NTSTATUS status;

	/* In parameters */
	r.in.level = level;
	r.in.bufsize = bufsize;

	status = cli->dispatch(cli,
				mem_ctx,
				&ndr_table_rap,
				NDR_RAP_WSERVERGETINFO,
				&r);

	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}

	/* Return variables */
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;

	/* Return result */
	return NT_STATUS_OK;
}

struct rpccli_rap_NetPrintQEnum_state {
	struct rap_NetPrintQEnum orig;
	struct rap_NetPrintQEnum tmp;
	TALLOC_CTX *out_mem_ctx;
	NTSTATUS (*dispatch_recv)(struct tevent_req *req, TALLOC_CTX *mem_ctx);
};

static void rpccli_rap_NetPrintQEnum_done(struct tevent_req *subreq);

struct tevent_req *rpccli_rap_NetPrintQEnum_send(TALLOC_CTX *mem_ctx,
						 struct tevent_context *ev,
						 struct rpc_pipe_client *cli,
						 uint16_t _level /* [in]  */,
						 uint16_t _bufsize /* [in]  */,
						 uint16_t _status /* [out]  */,
						 uint16_t _convert /* [out]  */,
						 uint16_t _count /* [out]  */,
						 uint16_t _available /* [out]  */,
						 union rap_printq_info *_info /* [out] [ref,switch_is(level)] */)
{
	struct tevent_req *req;
	struct rpccli_rap_NetPrintQEnum_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct rpccli_rap_NetPrintQEnum_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;
	state->dispatch_recv = cli->dispatch_recv;

	/* In parameters */
	state->orig.in.level = _level;
	state->orig.in.bufsize = _bufsize;

	/* Out parameters */
	state->orig.out.status = _status;
	state->orig.out.convert = _convert;
	state->orig.out.count = _count;
	state->orig.out.available = _available;
	state->orig.out.info = _info;

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "rpccli_rap_NetPrintQEnum_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = cli->dispatch_send(state, ev, cli,
				    &ndr_table_rap,
				    NDR_RAP_NETPRINTQENUM,
				    &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, rpccli_rap_NetPrintQEnum_done, req);
	return req;
}

static void rpccli_rap_NetPrintQEnum_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct rpccli_rap_NetPrintQEnum_state *state = tevent_req_data(
		req, struct rpccli_rap_NetPrintQEnum_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = state->dispatch_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	*state->orig.out.info = *state->tmp.out.info;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS rpccli_rap_NetPrintQEnum_recv(struct tevent_req *req,
				       TALLOC_CTX *mem_ctx)
{
	struct rpccli_rap_NetPrintQEnum_state *state = tevent_req_data(
		req, struct rpccli_rap_NetPrintQEnum_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possbile out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS rpccli_rap_NetPrintQEnum(struct rpc_pipe_client *cli,
				  TALLOC_CTX *mem_ctx,
				  uint16_t level /* [in]  */,
				  uint16_t bufsize /* [in]  */,
				  uint16_t status /* [out]  */,
				  uint16_t convert /* [out]  */,
				  uint16_t count /* [out]  */,
				  uint16_t available /* [out]  */,
				  union rap_printq_info *info /* [out] [ref,switch_is(level)] */)
{
	struct rap_NetPrintQEnum r;
	NTSTATUS status;

	/* In parameters */
	r.in.level = level;
	r.in.bufsize = bufsize;

	status = cli->dispatch(cli,
				mem_ctx,
				&ndr_table_rap,
				NDR_RAP_NETPRINTQENUM,
				&r);

	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}

	/* Return variables */
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	return NT_STATUS_NOT_SUPPORTED;
	*info = *r.out.info;

	/* Return result */
	return NT_STATUS_OK;
}

