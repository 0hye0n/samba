/* client functions auto-generated by pidl */

#include "includes.h"
#include <tevent.h>
#include "lib/util/tevent_ntstatus.h"
#include "../librpc/gen_ndr/ndr_rap.h"
#include "../librpc/gen_ndr/ndr_rap_c.h"

/* rap - client functions generated by pidl */

NTSTATUS dcerpc_rap_NetShareEnum(struct dcerpc_pipe *p, TALLOC_CTX *mem_ctx, struct rap_NetShareEnum *r)
{

	NTSTATUS status;

	if (p->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(rap_NetShareEnum, r);
	}

	status = dcerpc_ndr_request(p, NULL, &ndr_table_rap,
				    NDR_RAP_NETSHAREENUM, mem_ctx, r);

	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(rap_NetShareEnum, r);
	}

	return status;
}

static struct rpc_request *dcerpc_rap_NetShareEnum_send(struct dcerpc_pipe *p, TALLOC_CTX *mem_ctx, struct rap_NetShareEnum *r)
{

	if (p->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(rap_NetShareEnum, r);
	}

	return dcerpc_ndr_request_send(p, NULL, &ndr_table_rap,
				       NDR_RAP_NETSHAREENUM, true, mem_ctx, r);
}

static NTSTATUS dcerpc_rap_NetShareEnum_recv(struct rpc_request *rreq)
{
NTSTATUS status;
	struct dcerpc_pipe *p = rreq->p;
	struct rap_NetShareEnum *r = (struct rap_NetShareEnum *)rreq->ndr.struct_ptr;

	status = dcerpc_ndr_request_recv(rreq);

	if (NT_STATUS_EQUAL(status, NT_STATUS_NET_WRITE_FAULT)) {
		status = dcerpc_fault_to_nt_status(p->last_fault_code);
	}

	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(rap_NetShareEnum, r);
	}

	return status;
}

struct dcerpc_rap_NetShareEnum_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_rap_NetShareEnum_r_done(struct rpc_request *subreq);

struct tevent_req *dcerpc_rap_NetShareEnum_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct rap_NetShareEnum *r)
{
	struct tevent_req *req;
	struct dcerpc_rap_NetShareEnum_r_state *state;
	struct dcerpc_pipe *p =
		talloc_get_type_abort(h->private_data,
		struct dcerpc_pipe);
	struct rpc_request *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_rap_NetShareEnum_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_rap_NetShareEnum_send(p, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	subreq->async.callback = dcerpc_rap_NetShareEnum_r_done;
	subreq->async.private_data = req;

	return req;
}

static void dcerpc_rap_NetShareEnum_r_done(struct rpc_request *subreq)
{
	struct tevent_req *req =
		talloc_get_type_abort(subreq->async.private_data,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_rap_NetShareEnum_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_rap_NetShareEnum_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_rap_NetShareEnum_r_state *state =
		tevent_req_data(req,
		struct dcerpc_rap_NetShareEnum_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_rap_NetShareEnum_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct rap_NetShareEnum *r)
{
	struct dcerpc_pipe *p =
		talloc_get_type_abort(h->private_data,
		struct dcerpc_pipe);


	NTSTATUS status;

	if (p->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(rap_NetShareEnum, r);
	}

	status = dcerpc_ndr_request(p, NULL, &ndr_table_rap,
				    NDR_RAP_NETSHAREENUM, mem_ctx, r);

	if (NT_STATUS_EQUAL(status, NT_STATUS_NET_WRITE_FAULT)) {
		status = dcerpc_fault_to_nt_status(p->last_fault_code);
	}

	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(rap_NetShareEnum, r);
	}
	return status;
}

NTSTATUS dcerpc_rap_NetServerEnum2(struct dcerpc_pipe *p, TALLOC_CTX *mem_ctx, struct rap_NetServerEnum2 *r)
{

	NTSTATUS status;

	if (p->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(rap_NetServerEnum2, r);
	}

	status = dcerpc_ndr_request(p, NULL, &ndr_table_rap,
				    NDR_RAP_NETSERVERENUM2, mem_ctx, r);

	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(rap_NetServerEnum2, r);
	}

	return status;
}

static struct rpc_request *dcerpc_rap_NetServerEnum2_send(struct dcerpc_pipe *p, TALLOC_CTX *mem_ctx, struct rap_NetServerEnum2 *r)
{

	if (p->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(rap_NetServerEnum2, r);
	}

	return dcerpc_ndr_request_send(p, NULL, &ndr_table_rap,
				       NDR_RAP_NETSERVERENUM2, true, mem_ctx, r);
}

static NTSTATUS dcerpc_rap_NetServerEnum2_recv(struct rpc_request *rreq)
{
NTSTATUS status;
	struct dcerpc_pipe *p = rreq->p;
	struct rap_NetServerEnum2 *r = (struct rap_NetServerEnum2 *)rreq->ndr.struct_ptr;

	status = dcerpc_ndr_request_recv(rreq);

	if (NT_STATUS_EQUAL(status, NT_STATUS_NET_WRITE_FAULT)) {
		status = dcerpc_fault_to_nt_status(p->last_fault_code);
	}

	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(rap_NetServerEnum2, r);
	}

	return status;
}

struct dcerpc_rap_NetServerEnum2_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_rap_NetServerEnum2_r_done(struct rpc_request *subreq);

struct tevent_req *dcerpc_rap_NetServerEnum2_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct rap_NetServerEnum2 *r)
{
	struct tevent_req *req;
	struct dcerpc_rap_NetServerEnum2_r_state *state;
	struct dcerpc_pipe *p =
		talloc_get_type_abort(h->private_data,
		struct dcerpc_pipe);
	struct rpc_request *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_rap_NetServerEnum2_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_rap_NetServerEnum2_send(p, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	subreq->async.callback = dcerpc_rap_NetServerEnum2_r_done;
	subreq->async.private_data = req;

	return req;
}

static void dcerpc_rap_NetServerEnum2_r_done(struct rpc_request *subreq)
{
	struct tevent_req *req =
		talloc_get_type_abort(subreq->async.private_data,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_rap_NetServerEnum2_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_rap_NetServerEnum2_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_rap_NetServerEnum2_r_state *state =
		tevent_req_data(req,
		struct dcerpc_rap_NetServerEnum2_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_rap_NetServerEnum2_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct rap_NetServerEnum2 *r)
{
	struct dcerpc_pipe *p =
		talloc_get_type_abort(h->private_data,
		struct dcerpc_pipe);


	NTSTATUS status;

	if (p->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(rap_NetServerEnum2, r);
	}

	status = dcerpc_ndr_request(p, NULL, &ndr_table_rap,
				    NDR_RAP_NETSERVERENUM2, mem_ctx, r);

	if (NT_STATUS_EQUAL(status, NT_STATUS_NET_WRITE_FAULT)) {
		status = dcerpc_fault_to_nt_status(p->last_fault_code);
	}

	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(rap_NetServerEnum2, r);
	}
	return status;
}

NTSTATUS dcerpc_rap_WserverGetInfo(struct dcerpc_pipe *p, TALLOC_CTX *mem_ctx, struct rap_WserverGetInfo *r)
{

	NTSTATUS status;

	if (p->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(rap_WserverGetInfo, r);
	}

	status = dcerpc_ndr_request(p, NULL, &ndr_table_rap,
				    NDR_RAP_WSERVERGETINFO, mem_ctx, r);

	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(rap_WserverGetInfo, r);
	}

	return status;
}

static struct rpc_request *dcerpc_rap_WserverGetInfo_send(struct dcerpc_pipe *p, TALLOC_CTX *mem_ctx, struct rap_WserverGetInfo *r)
{

	if (p->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(rap_WserverGetInfo, r);
	}

	return dcerpc_ndr_request_send(p, NULL, &ndr_table_rap,
				       NDR_RAP_WSERVERGETINFO, true, mem_ctx, r);
}

static NTSTATUS dcerpc_rap_WserverGetInfo_recv(struct rpc_request *rreq)
{
NTSTATUS status;
	struct dcerpc_pipe *p = rreq->p;
	struct rap_WserverGetInfo *r = (struct rap_WserverGetInfo *)rreq->ndr.struct_ptr;

	status = dcerpc_ndr_request_recv(rreq);

	if (NT_STATUS_EQUAL(status, NT_STATUS_NET_WRITE_FAULT)) {
		status = dcerpc_fault_to_nt_status(p->last_fault_code);
	}

	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(rap_WserverGetInfo, r);
	}

	return status;
}

struct dcerpc_rap_WserverGetInfo_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_rap_WserverGetInfo_r_done(struct rpc_request *subreq);

struct tevent_req *dcerpc_rap_WserverGetInfo_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct rap_WserverGetInfo *r)
{
	struct tevent_req *req;
	struct dcerpc_rap_WserverGetInfo_r_state *state;
	struct dcerpc_pipe *p =
		talloc_get_type_abort(h->private_data,
		struct dcerpc_pipe);
	struct rpc_request *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_rap_WserverGetInfo_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_rap_WserverGetInfo_send(p, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	subreq->async.callback = dcerpc_rap_WserverGetInfo_r_done;
	subreq->async.private_data = req;

	return req;
}

static void dcerpc_rap_WserverGetInfo_r_done(struct rpc_request *subreq)
{
	struct tevent_req *req =
		talloc_get_type_abort(subreq->async.private_data,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_rap_WserverGetInfo_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_rap_WserverGetInfo_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_rap_WserverGetInfo_r_state *state =
		tevent_req_data(req,
		struct dcerpc_rap_WserverGetInfo_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_rap_WserverGetInfo_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct rap_WserverGetInfo *r)
{
	struct dcerpc_pipe *p =
		talloc_get_type_abort(h->private_data,
		struct dcerpc_pipe);


	NTSTATUS status;

	if (p->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(rap_WserverGetInfo, r);
	}

	status = dcerpc_ndr_request(p, NULL, &ndr_table_rap,
				    NDR_RAP_WSERVERGETINFO, mem_ctx, r);

	if (NT_STATUS_EQUAL(status, NT_STATUS_NET_WRITE_FAULT)) {
		status = dcerpc_fault_to_nt_status(p->last_fault_code);
	}

	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(rap_WserverGetInfo, r);
	}
	return status;
}

NTSTATUS dcerpc_rap_NetPrintQEnum(struct dcerpc_pipe *p, TALLOC_CTX *mem_ctx, struct rap_NetPrintQEnum *r)
{

	NTSTATUS status;

	if (p->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(rap_NetPrintQEnum, r);
	}

	status = dcerpc_ndr_request(p, NULL, &ndr_table_rap,
				    NDR_RAP_NETPRINTQENUM, mem_ctx, r);

	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(rap_NetPrintQEnum, r);
	}

	return status;
}

static struct rpc_request *dcerpc_rap_NetPrintQEnum_send(struct dcerpc_pipe *p, TALLOC_CTX *mem_ctx, struct rap_NetPrintQEnum *r)
{

	if (p->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(rap_NetPrintQEnum, r);
	}

	return dcerpc_ndr_request_send(p, NULL, &ndr_table_rap,
				       NDR_RAP_NETPRINTQENUM, true, mem_ctx, r);
}

static NTSTATUS dcerpc_rap_NetPrintQEnum_recv(struct rpc_request *rreq)
{
NTSTATUS status;
	struct dcerpc_pipe *p = rreq->p;
	struct rap_NetPrintQEnum *r = (struct rap_NetPrintQEnum *)rreq->ndr.struct_ptr;

	status = dcerpc_ndr_request_recv(rreq);

	if (NT_STATUS_EQUAL(status, NT_STATUS_NET_WRITE_FAULT)) {
		status = dcerpc_fault_to_nt_status(p->last_fault_code);
	}

	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(rap_NetPrintQEnum, r);
	}

	return status;
}

struct dcerpc_rap_NetPrintQEnum_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_rap_NetPrintQEnum_r_done(struct rpc_request *subreq);

struct tevent_req *dcerpc_rap_NetPrintQEnum_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct rap_NetPrintQEnum *r)
{
	struct tevent_req *req;
	struct dcerpc_rap_NetPrintQEnum_r_state *state;
	struct dcerpc_pipe *p =
		talloc_get_type_abort(h->private_data,
		struct dcerpc_pipe);
	struct rpc_request *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_rap_NetPrintQEnum_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_rap_NetPrintQEnum_send(p, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	subreq->async.callback = dcerpc_rap_NetPrintQEnum_r_done;
	subreq->async.private_data = req;

	return req;
}

static void dcerpc_rap_NetPrintQEnum_r_done(struct rpc_request *subreq)
{
	struct tevent_req *req =
		talloc_get_type_abort(subreq->async.private_data,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_rap_NetPrintQEnum_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_rap_NetPrintQEnum_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_rap_NetPrintQEnum_r_state *state =
		tevent_req_data(req,
		struct dcerpc_rap_NetPrintQEnum_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_rap_NetPrintQEnum_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct rap_NetPrintQEnum *r)
{
	struct dcerpc_pipe *p =
		talloc_get_type_abort(h->private_data,
		struct dcerpc_pipe);


	NTSTATUS status;

	if (p->conn->flags & DCERPC_DEBUG_PRINT_IN) {
		NDR_PRINT_IN_DEBUG(rap_NetPrintQEnum, r);
	}

	status = dcerpc_ndr_request(p, NULL, &ndr_table_rap,
				    NDR_RAP_NETPRINTQENUM, mem_ctx, r);

	if (NT_STATUS_EQUAL(status, NT_STATUS_NET_WRITE_FAULT)) {
		status = dcerpc_fault_to_nt_status(p->last_fault_code);
	}

	if (NT_STATUS_IS_OK(status) && (p->conn->flags & DCERPC_DEBUG_PRINT_OUT)) {
		NDR_PRINT_OUT_DEBUG(rap_NetPrintQEnum, r);
	}
	return status;
}

