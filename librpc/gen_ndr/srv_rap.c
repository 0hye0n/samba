/*
 * Unix SMB/CIFS implementation.
 * server auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "../librpc/gen_ndr/srv_rap.h"

static bool api_rap_NetShareEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct rap_NetShareEnum *r;

	call = &ndr_table_rap.calls[NDR_RAP_NETSHAREENUM];

	r = talloc(talloc_tos(), struct rap_NetShareEnum);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(rap_NetShareEnum, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info = talloc_zero(r, union rap_share_info);
	if (r->out.info == NULL) {
		talloc_free(r);
		return false;
	}

	_rap_NetShareEnum(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(rap_NetShareEnum, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_rap_NetServerEnum2(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct rap_NetServerEnum2 *r;

	call = &ndr_table_rap.calls[NDR_RAP_NETSERVERENUM2];

	r = talloc(talloc_tos(), struct rap_NetServerEnum2);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(rap_NetServerEnum2, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info = talloc_zero(r, union rap_server_info);
	if (r->out.info == NULL) {
		talloc_free(r);
		return false;
	}

	_rap_NetServerEnum2(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(rap_NetServerEnum2, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_rap_WserverGetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct rap_WserverGetInfo *r;

	call = &ndr_table_rap.calls[NDR_RAP_WSERVERGETINFO];

	r = talloc(talloc_tos(), struct rap_WserverGetInfo);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(rap_WserverGetInfo, r);
	}

	ZERO_STRUCT(r->out);
	_rap_WserverGetInfo(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(rap_WserverGetInfo, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_rap_NetPrintQEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct rap_NetPrintQEnum *r;

	call = &ndr_table_rap.calls[NDR_RAP_NETPRINTQENUM];

	r = talloc(talloc_tos(), struct rap_NetPrintQEnum);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(rap_NetPrintQEnum, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info = talloc_zero(r, union rap_printq_info);
	if (r->out.info == NULL) {
		talloc_free(r);
		return false;
	}

	_rap_NetPrintQEnum(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(rap_NetPrintQEnum, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}


/* Tables */
static struct api_struct api_rap_cmds[] =
{
	{"RAP_NETSHAREENUM", NDR_RAP_NETSHAREENUM, api_rap_NetShareEnum},
	{"RAP_NETSERVERENUM2", NDR_RAP_NETSERVERENUM2, api_rap_NetServerEnum2},
	{"RAP_WSERVERGETINFO", NDR_RAP_WSERVERGETINFO, api_rap_WserverGetInfo},
	{"RAP_NETPRINTQENUM", NDR_RAP_NETPRINTQENUM, api_rap_NetPrintQEnum},
};

void rap_get_pipe_fns(struct api_struct **fns, int *n_fns)
{
	*fns = api_rap_cmds;
	*n_fns = sizeof(api_rap_cmds) / sizeof(struct api_struct);
}

NTSTATUS rpc_rap_dispatch(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, const struct ndr_interface_table *table, uint32_t opnum, void *_r)
{
	if (cli->pipes_struct == NULL) {
		return NT_STATUS_INVALID_PARAMETER;
	}

	switch (opnum)
	{
		case NDR_RAP_NETSHAREENUM: {
			struct rap_NetShareEnum *r = (struct rap_NetShareEnum *)_r;
			ZERO_STRUCT(r->out);
			r->out.info = talloc_zero(mem_ctx, union rap_share_info);
			if (r->out.info == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			_rap_NetShareEnum(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_RAP_NETSERVERENUM2: {
			struct rap_NetServerEnum2 *r = (struct rap_NetServerEnum2 *)_r;
			ZERO_STRUCT(r->out);
			r->out.info = talloc_zero(mem_ctx, union rap_server_info);
			if (r->out.info == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			_rap_NetServerEnum2(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_RAP_WSERVERGETINFO: {
			struct rap_WserverGetInfo *r = (struct rap_WserverGetInfo *)_r;
			ZERO_STRUCT(r->out);
			_rap_WserverGetInfo(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_RAP_NETPRINTQENUM: {
			struct rap_NetPrintQEnum *r = (struct rap_NetPrintQEnum *)_r;
			ZERO_STRUCT(r->out);
			r->out.info = talloc_zero(mem_ctx, union rap_printq_info);
			if (r->out.info == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			_rap_NetPrintQEnum(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		default:
			return NT_STATUS_NOT_IMPLEMENTED;
	}
}

NTSTATUS rpc_rap_init(void)
{
	return rpc_srv_register(SMB_RPC_INTERFACE_VERSION, "rap", "rap", &ndr_table_rap, api_rap_cmds, sizeof(api_rap_cmds) / sizeof(struct api_struct));
}
