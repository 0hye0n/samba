<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>qooxdoo &raquo; Demo</title>
  <link type="text/css" rel="stylesheet" href="../../resource/css/layout.css"/>
  <!--[if IE]>
  <link
   type="text/css" rel="stylesheet" href="../../resource/css/layout_ie.css"/>
  <![endif]-->
  <script type="text/javascript" src="../../script/qx.js"></script>
</head>
<body>
  <script type="text/javascript" src="../../script/layout.js"></script>


  <div id="demoDescription">
    <p>
    A simple LDB browser.
  </div>

<script type="text/javascript">

// All of our variables which must be in a global scope will be part of this
// object
globals = new Object();

// Default database File to open
globals.dbFile = "/usr/local/samba/private/sam.ldb";

// No database is yet open
globals.dbHandle = null;
        


/*
Root is as found by:
  source/bin/ldbsearch -H /usr/local/samba/private/sam.ldb -b '' \
    -s base defaultNamingContext

Schema page:
  source/bin/ldbsearch -H /usr/local/samba/private/sam.ldb -b '' \
    -s base subschemaSubentry
  source/bin/ldbsearch -H /usr/local/samba/private/sam.ldb -b \
    'CN=Aggregate,CN=Schema,CN=Configuration,DC=workgroup,DC=example,DC=com' \
    -s base objectClasses attributeTypes matchingRules ldapSyntaxes        
*/

function setAppearances()
{
    // Modify the default appearance of a ComboBox for use in Search tab:
    //   use more of the available width.
    //
    // If we had multiple uses, we'd create a new appearance.  Since we don't,
    // we can just modify this default appearance.
    //
    // See http://qooxdoo.org/documentation/user_manual/appearance for an
    // explanation of what's going on here.  The missing significant point in
    // the discussion is that in the current qooxdoo appearance
    // implementation, it's not possible to override a specific widget's
    // appearance with explicit settings just for that widget (stupid!).  I
    // expect that to change in a future version.
    var appMgr = qx.manager.object.AppearanceManager.getInstance();
    var theme = appMgr.getAppearanceTheme();
    var appearance = theme._appearances["combo-box"];
    if (! appearance)
    {
        return;
    }
    var oldInitial = appearance.initial;
    appearance.initial = function(vTheme)
    {
        var res = oldInitial ? oldInitial.apply(this, arguments) : {};
        res.width = "80%";
        return res;
    }
}

function setupMenu(clientDocument)
{
    var c1 = new qx.client.Command();
    c1.addEventListener("execute", function(e) {
                            this.debug("Execute: " + e.getData().getLabel());
                        });

    // Create the File menu pulldown
    var fileMenu_ = new qx.ui.menu.Menu();
      
    // Create items for within File menu
    var fileMenu_NewTab_ = new qx.ui.menu.Menu();
    {
        var fileMenu_NewTab_Search =
            new qx.ui.menu.MenuButton("Search", null, c1);
        var fileMenu_NewTab_Browse =
            new qx.ui.menu.MenuButton("Browse", null, c1);
        var fileMenu_NewTab_Schema =
            new qx.ui.menu.MenuButton("Schema", null, c1);
        fileMenu_NewTab_.add(fileMenu_NewTab_Search,
                             fileMenu_NewTab_Browse,
                             fileMenu_NewTab_Schema);
    }
    var fileMenu_NewTab =
        new qx.ui.menu.MenuButton("New tab", null, null, fileMenu_NewTab_);

    var fileMenu_Preferences =
        new qx.ui.menu.MenuButton("Preferences", null, c1);
    var fileMenu_CloseTab =
        new qx.ui.menu.MenuButton("Close Tab", null, c1);
    var fileMenu_ShowMessageLog =
        new qx.ui.menu.MenuButton("Show Message Log", null, c1);
    var fileMenu_Quit =
        new qx.ui.menu.MenuButton("Quit", null, c1);
      
    // Add the menu items to the menu
    fileMenu_.add(fileMenu_NewTab,
                  fileMenu_Preferences,
                  fileMenu_CloseTab,
                  fileMenu_ShowMessageLog,
                  fileMenu_Quit);


    // Create the Filter menu pulldown
    var filterMenu_ = new qx.ui.menu.Menu();

    // Create items for within Filter menu
    var filterMenu_NewFilter =
        new qx.ui.menu.MenuButton("New Filter", null, c1);
    var filterMenu_EditFilters =
        new qx.ui.menu.MenuButton("Edit Filters", null, c1);
    var filterMenu_Separator =
        new qx.ui.menu.MenuSeparator();

    // Add the menu items to the menu
    filterMenu_.add(filterMenu_NewFilter,
                    filterMenu_EditFilters,
                    filterMenu_Separator);


    // Add the menu items to the document
    clientDocument.add(fileMenu_,
                       fileMenu_NewTab_,
                       filterMenu_);


    // Create and position the toolbar which will act as our menubar
    var toolBar = new qx.ui.toolbar.ToolBar();
    toolBar.set(
        {
            top: 28,
            left: 20,
            right: 300
        });
      
    // Create the toolbar menu items and associate them with the pulldowns
    var fileMenuButton =
        new qx.ui.toolbar.ToolBarMenuButton("File", fileMenu_);
    var filterMenuButton =
        new qx.ui.toolbar.ToolBarMenuButton("Filters", filterMenu_);
            
    // Add the toolbar items to the toolbar
    toolBar.add(fileMenuButton,
                filterMenuButton);
      
    // Add the toolbar to the document
    clientDocument.add(toolBar);

    // Give 'em what we built!
    return toolBar;
}

function setupTabs(clientDocument)
{
    // Create and position the tabview
    var tabView_ = new qx.ui.pageview.tabview.TabView;
    tabView_.set(
        {
            top: 60,
            left: 20,
            right: 300,
            bottom: 30
        });

    // Create each of the tabs
    var tabView_Search =
        new qx.ui.pageview.tabview.TabViewButton("Search");
    var tabView_Browse =
        new qx.ui.pageview.tabview.TabViewButton("Browse");
    var tabView_Schema =
        new qx.ui.pageview.tabview.TabViewButton("Schema");

    // Specify the initially-selected tab
    tabView_Search.setChecked(true);

    // Add each of the tabs to the tabview
    tabView_.getBar().add(tabView_Search,
                          tabView_Browse,
                          tabView_Schema);

    // Create the pages to display when each tab is selected
    var tabViewPage_Search =
        new qx.ui.pageview.tabview.TabViewPage(tabView_Search);
    var tabViewPage_Browse =
        new qx.ui.pageview.tabview.TabViewPage(tabView_Browse);
    var tabViewPage_Schema =
        new qx.ui.pageview.tabview.TabViewPage(tabView_Schema);

    // Build the search page
    var searchResultsTable = buildPageSearch(tabViewPage_Search);

    // Provide access to the search results table
    tabView_.searchResultTable = searchResultsTable;

    // Build the browse page
    buildPageBrowse(tabViewPage_Browse);

    // Build the schema page
    buildPageSchema(tabViewPage_Schema);

    // Add the pages to the tabview
    tabView_.getPane().add(tabViewPage_Search,
                           tabViewPage_Browse,
                           tabViewPage_Schema);

    // Add the tabview to the document
    clientDocument.add(tabView_);

    // Give 'em what we built!
    return tabView_;
}

function buildPageSearch(page)
{
    // We need a vertical box layout for the various input fields
    var vlayout = new qx.ui.layout.VerticalBoxLayout();
    vlayout.setWidth("100%");

    // We need a horizontal box layout for the search combo box and its label
    var hlayout = new qx.ui.layout.HorizontalBoxLayout();
    hlayout.setWidth("100%");
    hlayout.setHeight(25);

    // Create a label for the list of required attributes
    var label = new qx.ui.basic.Atom("Search Expression:");
    label.setWidth(100);
    label.setHorizontalChildrenAlign("right");

    // Add the label to the horizontal layout
    hlayout.add(label);

    // Create a combo box for entry of the search expression
    var search = new qx.ui.form.ComboBox();
    search.getField().setWidth("100%");
    search.setEditable(true);
    
    // Add the combo box to the horizontal layout
    hlayout.add(search);

    // Add the horizontal layout to the vertical layout
    vlayout.add(hlayout);

    // We need a horizontal box layout for the base combo box and its label
    hlayout = new qx.ui.layout.HorizontalBoxLayout();
    hlayout.setWidth("100%");
    hlayout.setHeight(25);

    // Create a label for the list of required attributes
    var label = new qx.ui.basic.Atom("Base:");
    label.setWidth(100);
    label.setHorizontalChildrenAlign("right");

    // Add the label to the horizontal layout
    hlayout.add(label);

    // Create a combo box for entry of the search expression
    var base = new qx.ui.form.ComboBox();
    base.getField().setWidth("100%");
    base.setEditable(true);
    
    // Add the combo box to the horizontal layout
    hlayout.add(base);

    // Add the horizontal layout to the vertical layout
    vlayout.add(hlayout);

    // We need a horizontal box layout for scope radio buttons
    hlayout = new qx.ui.layout.HorizontalBoxLayout();
    hlayout.setWidth("100%");
    hlayout.setHeight(25);

    // Create a label for the list of required attributes
    var label = new qx.ui.basic.Atom("Scope:");
    label.setWidth(100);
    label.setHorizontalChildrenAlign("right");

    // Add the label to the horizontal layout
    hlayout.add(label);

    // Create a radio button for each scope
    var rbDefault = new qx.ui.form.RadioButton("Default",   "default");
    var rbBase    = new qx.ui.form.RadioButton("Base",      "base");
    var rbOne     = new qx.ui.form.RadioButton("One Level", "one");
    var rbSubtree = new qx.ui.form.RadioButton("Subtree",   "subtree");

    // Use a default of "Default"
    rbDefault.setChecked(true);

    // Add the radio buttons to the horizontal layout
    hlayout.add(rbDefault, rbBase, rbOne, rbSubtree);

    // Group the radio buttons so only one in the group may be selected
    var scope = new qx.manager.selection.RadioManager("scope",
                                                      [
                                                          rbDefault,
                                                          rbBase,
                                                          rbOne,
                                                          rbSubtree
                                                      ]);
    
    // Right-justify the 'Find' button
    var spacer = new qx.ui.basic.HorizontalSpacer;
    hlayout.add(spacer);

    // Create the 'Find' button
    var find = new qx.ui.form.Button('Find');
    hlayout.add(find);

    // Add the Find button line to the vertical layout
    vlayout.add(hlayout);

    // We'll be setting url and service upon execute; no need to do it now.
    var rpc = new qx.io.remote.Rpc();
    rpc.setTimeout(10000);
    var mycall = null;

    find.addEventListener("execute", function()
    {
        // Set the URL and Service
        rpc.setUrl("/services/");
        rpc.setServiceName("samba.ldb");
        rpc.setCrossDomain(false);

        find.setEnabled(false);
        mycall = rpc.callAsync(function(result, ex, id)
        {
            mycall = null;
            if (ex == null)
            {
                var rowData = [];
                for (var i = 0; i < result.length; i++)
                {
                    var o = result[i];
                    if (typeof(o) != "object")
                    {
                        alert("Found unexpected result, type " +
                              typeof(o) +
                              ", " +
                              o +
                              "\n");
                        continue;
                    }
                    for (var field in o)
                    {
                        // skip dn and distinguishedName fields;
                        // they're shown in each row anyway.
                        if (field == "dn" || field == "distinguishedName")
                        {
                            continue;
                        }
                        rowData.push( [
                                          o["dn"],
                                          field,
                                          o[field]
                                      ] );
                    }

                    // Tell the table to use the new data
                    tableModel.setData(rowData);
                }
            }
            else
            {
                alert("Async(" + id + ") exception: " + ex);
            }
            find.setEnabled(true);
        },
        "search",                       // method
        globals.dbHandle,               // database handle
        search.getValue(),              // search expression
        base.getValue(),                // baseDN
        scope.getSelected().getValue(), // scope
        [ "*" ]);                       // attributes
    });

    // Add the horizontal box layout to the page
    page.add(vlayout);

    // Create a simple table model
    var tableModel = new qx.ui.table.SimpleTableModel();
    tableModel.setColumns([ "Distinguished Name", "Attribute", "Value" ]);

    tableModel.setColumnEditable(0, false);
    tableModel.setColumnEditable(1, false);
    tableModel.setColumnEditable(2, false);

    // Create a table
    var table = new qx.ui.table.Table(tableModel);
    with (table)
    {
      set({
              top: 80,
              left: 0,
              right: 0,
              bottom: 10,
              statusBarVisible: false,
              columnVisibilityButtonVisible: false
          });
      setColumnWidth(0, 300);
      setColumnWidth(1, 180);
      setColumnWidth(2, 240);
      setMetaColumnCounts([ 1, -1 ]); // h-scroll attribute and value together
    };

    page.add(table);

    return table;
}

function buildPageBrowse(page)
{
    /*
     * Reset the default of always showing the plus/minus symbol.  The
     * default is 'false'.  We want to always display it for each folder
     * (and then stop displaying it if we determine upon open that there
     * are no contents).
     */
    var constructor = qx.OO.classes["qx.ui.treefullcontrol.TreeFolder"];
    qx.Proto = constructor.prototype;
    qx.OO.changeProperty(
        {
            name         : "alwaysShowPlusMinusSymbol",
            type         : qx.constant.Type.BOOLEAN,
            defaultValue : true
        });

    // Create a vertical splitpane for tree (top) and table (bottom)
    var splitpane = new qx.ui.splitpane.VerticalSplitPane("1*", "2*");
    splitpane.setEdge(0);

    // Create a tree row structure for the tree root
    var trs = qx.ui.treefullcontrol.TreeRowStructure.getInstance().standard(globals.dbFile);

    // Create the tree and set its characteristics
    var tree = new qx.ui.treefullcontrol.Tree(trs);
    tree.set(
        {
            backgroundColor: 255,
            border: qx.renderer.border.BorderPresets.getInstance().inset,
            overflow: "auto",
            height: null,
            top: 10,
            left: 0,
            right: 0,
            bottom: 10,
            open: false
        });

    var addChildren = function(parent, children, retrieve)
    {
        var t;
        var trs;
        var child;

        // Any children?
        if (! children || children["length"] == 0)
        {
            // Nope.  Allow parent's expand/contract button to be removed
            parent.setAlwaysShowPlusMinusSymbol(false);
            return;
        }

        for (i = 0; i < children.length; i++)
        {
            var name;

            child = children[i];

            // Determine name for new tree row.  If first level, use entire
            // DN.  Otherwise, strip off first additional component.
            if (retrieve == "defaultNamingContext")
            {
                name = child["defaultNamingContext"];
            }
            else
            {
                name = child["dn"].split(",")[0];
            }

            // Build a standard tree row
            trs = qx.ui.treefullcontrol.TreeRowStructure.getInstance().standard(name);

            // This row is a "folder" (it can have children)
            t = new qx.ui.treefullcontrol.TreeFolder(trs);

            // Add this row to its parent
            parent.add(t);
        }

        // Force flushing of pending DOM updates.  This is actually a
        // work-around for a bug.  Without this, occasionally, updates to the
        // gui aren't displayed until some 'action' takes place, e.g. key
        // press or mouse movement.
        qx.ui.core.Widget.flushGlobalQueues(true);
    }

    // Prepare to issue RPC calls
    var rpc = new qx.io.remote.Rpc();
    rpc.setUrl("/services/");
    rpc.setServiceName("samba.ldb");
    rpc.setCrossDomain(false);

    /*
     * All subtrees will use this root node's event listeners.  Create an
     * event listener for an open while empty.
     */
    tree.addEventListener(
        qx.constant.Event.TREEOPENWHILEEMPTY,
        function(e)
        {
            var parent = e.getData();
            var hierarchy = parent.getHierarchy(new Array());

            parent.debug("Requesting children...");

            // Strip off the root node
            hierarchy.shift();

            // Determine the children.  Differs depending on root or otherwise
            var attributes;
            var scope;
            var baseDN;
            
            // If parent is the root...
            if (parent == tree)
            {
                // ... then we want the defaultNamingContext, ...
                attributes = "defaultNamingContext";

                // ... and we want only base scope
                scope = "base";

                // ... and an empty base DN
                baseDN = "";
            }
            else
            {
                // otherwise, retrieve the DN,
                attributes = "dn";

                // ... and we want one level of scope
                scope = "one";

                // ... and base DN is the parent
                baseDN = hierarchy.reverse().join(",");
            }

            mycall = rpc.callAsync(function(result, ex, id)
            {
                mycall = null;
                if (ex == null)
                {
                    parent.debug("Children obtained.  Rendering...");
                    addChildren(parent, result, attributes);
                    parent.debug("Rendering complete.");
                }
                else
                {
                    alert("Async(" + id + ") exception: " + ex);
                }
            },
            "search",                       // method
            globals.dbHandle,               // database handle
            "(objectclass=*)",              // search expression
            baseDN,                         // baseDN
            scope,                          // scope
            [ attributes ]);                // attributes
        });

    /*
     * All subtrees will use this root node's event listeners.  Create an
     * event listener for selection changed, to populate attribute/value table
     */
    tree.getManager().addEventListener(
        qx.constant.Event.CHANGESELECTION,
        function(e)
        {
            var element = e.getData()[0];
            var hierarchy = element.getHierarchy(new Array());

            // Strip off the root node
            hierarchy.shift();

            // Determine the children.  Differs depending on root or otherwise
            var attributes;
            var scope;
            var baseDN;
            
            // If element is the root...
            if (element == tree)
            {
                // ... then just clear out the attribute/value table.
                tableModel.setData([]);
                return;
            }

            // We want all attributes
            attributes = "*";

            // We want the attributes only for the current element
            scope = "base";

            // Base DN is the current element
            baseDN = hierarchy.reverse().join(",");

            mycall = rpc.callAsync(function(result, ex, id)
            {
                mycall = null;
                if (ex == null)
                {
                    // If we received an empty list, ...
                    if (result == null)
                    {
                        // ... then just clear the attribute/value table.
                        tableModel.setData([]);
                        return;
                    }

                    // Start with an empty table dataset
                    var rowData = [];

                    // The result contains a single object: attributes
                    var attributes = result[0];

                    // For each attribute we received...
                    for (var attr in attributes)
                    {
                        // If it's multi-valued (type is an array)...
                        if (typeof(attributes[attr]) == "object")
                        {
                            // ... then add each value with same name
                            var a = attributes[attr];
                            for (var i = 0; i < a.length; i++)
                            {
                                rowData.push([ attr, a[i] ]);
                            }
                        }
                        else    // single-valued
                        {
                            // ... add its name and value to the table dataset
                            rowData.push([ attr, attributes[attr] ]);
                        }
                    }

                    // Add the dataset to the table
                    tableModel.setData(rowData);
                }
                else
                {
                    alert("Async(" + id + ") exception: " + ex);
                }
            },
            "search",                       // method
            globals.dbHandle,               // database handle
            "(objectclass=*)",              // search expression
            baseDN,                         // baseDN
            scope,                          // scope
            [ attributes ]);                // attributes
        });




    // Add the tree to the page.
    splitpane.addTop(tree);

    // Create a simple table model
    var tableModel = new qx.ui.table.SimpleTableModel();
    tableModel.setColumns([ "Attribute", "Value" ]);

    tableModel.setColumnEditable(0, false);
    tableModel.setColumnEditable(1, true);

    // Create a table
    var table = new qx.ui.table.Table(tableModel);
    with (table) {
      set({
              top: 10,
              left: 0,
              right: 0,
              bottom: 10,
              statusBarVisible: false,
              columnVisibilityButtonVisible: false
          });
      setColumnWidth(0, 200);
      setColumnWidth(1, 440);
      setMetaColumnCounts([1, -1]);
    };

    // Add the table to the bottom portion of the splitpane
    splitpane.addBottom(table);

    // Add the first splitpane to the page
    page.add(splitpane);
}

function buildPageSchema(page)
{
    // Create a vertical splitpane for tree (top) and remainder (bottom)
    var splitpane1 = new qx.ui.splitpane.VerticalSplitPane("1*", "2*");
    splitpane1.setEdge(0);

    // Create a tree row structure for the tree root
    var trs = qx.ui.treefullcontrol.TreeRowStructure.getInstance().standard(globals.dbFile);

    // Create the tree and set its characteristics
    var tree = new qx.ui.treefullcontrol.Tree(trs);
    tree.set(
        {
            backgroundColor: 255,
            border: qx.renderer.border.BorderPresets.getInstance().inset,
            overflow: "auto",
            height: null,
            top: 10,
            left: 0,
            right: 0,
            bottom: 10
        });

    // Add the tree to the page.
    splitpane1.addTop(tree);

    // Create another vertical splitpane for table (top) and required/allowed
    // attributes lists (bottom)
    var splitpane2 = new qx.ui.splitpane.VerticalSplitPane("1*", "2*");
    splitpane2.setEdge(0);

    // Create a simple table model
    var tableModel = new qx.ui.table.SimpleTableModel();
    tableModel.setColumns([ "Attribute", "Value" ]);

    // Add some garbage data to it
    var attributeNames =
        [
            [ "Nickname" ],
            [ "Hostname" ],
            [ "Port" ],
            [ "Connection caching" ],
            [ "TLS" ],
            [ "Client-side caching" ],
            [ "Connections so far" ],
            [ "LDAP protocol version" ],
            [ "Vendor Name" ],
            [ "Vendor Version" ],
            [ "Support LDAP Version" ],
            [ "Supported SASL Mechanisms" ],
            [ "Junk 1" ],
            [ "Junk 2" ],
            [ "Junk 3" ]
        ];
            

    var rowData = [];
    for (var row = 0; row < attributeNames.length; row++)
    {
        rowData.push([ attributeNames[row], "" + (Math.random() * 10000) ]);
    }
    tableModel.setData(rowData);
    tableModel.setColumnEditable(0, false);
    tableModel.setColumnEditable(1, true);

    // Create a table
    var table = new qx.ui.table.Table(tableModel);
    with (table) {
      set({
              top: 10,
              left: 0,
              right: 0,
              bottom: 10,
              statusBarVisible: false,
              columnVisibilityButtonVisible: false
          });
      setColumnWidth(0, 200);
      setColumnWidth(1, 440);
      setMetaColumnCounts([1, -1]);
    };

    splitpane2.addTop(table);

    // Create a horizontal splitpane for required attributes (left) and
    // allowed attributes (right)
    var splitpane3 = new qx.ui.splitpane.HorizontalSplitPane("1*", "1*");
    splitpane3.setEdge(0);

    // Create a vertical box layout for a label and list
    var layout = new qx.ui.layout.VerticalBoxLayout();
    layout.setWidth("100%");
    layout.setHeight("100%");

    // Create a label for the list of required attributes
    var label = new qx.ui.basic.Atom("Required Attributes");

    // Add the label to the vertical box layout
    layout.add(label);

    // Create a list for required attributes
    var requiredAttributes = new qx.ui.form.List();
    requiredAttributes.setWidth("100%");
      
    requiredAttributes.set(
        {
            top: 0,
            left: 0,
            width: "98%",
            height: "90%",
            overflow : "scrollY"
        });
      
    var item;
    for( var i=1; i<=35; i++ ) 
    {
        item = new qx.ui.form.ListItem("Item No " + i);
        !(i % 9) && (item.setEnabled(false));
        requiredAttributes.add(item);
    };
    
    // Add the required attributes to the layout
    layout.add(requiredAttributes);

    // Add the vertical box layout to the left of the third splitpane
    splitpane3.addLeft(layout);

    // Create a vertical box layout for a label and list
    layout = new qx.ui.layout.VerticalBoxLayout();
    layout.set(
        {
            width: "100%",
            height: "100%"
        });

    // Create a label for the list of allowed attributes
    var label = new qx.ui.basic.Atom("Allowed Attributes");
    label.setLeft(10);

    // Add the label to the vertical box layout
    layout.add(label);

    // Create a list for allowed attributes
    var allowedAttributes = new qx.ui.form.List();
    allowedAttributes.setWidth("100%");
      
    allowedAttributes.set(
        {
            top: 0,
            left: 10,
            width: "98%",
            height: "90%",
            overflow : "scrollY"
        });
      
    var item;
    for( var i=1; i<=35; i++ ) 
    {
        item = new qx.ui.form.ListItem("Item No " + i);
        !(i % 9) && (item.setEnabled(false));
        allowedAttributes.add(item);
    };
    
    // Add the allowed attributes to the layout
    layout.add(allowedAttributes);

    // Add the vertical box layout to the left of the third splitpane
    splitpane3.addRight(layout);

    // Add the third splitpane to the bottom of the second splitpane
    splitpane2.addBottom(splitpane3);

    // Add the second splitpane to the bottom of the first splitpane
    splitpane1.addBottom(splitpane2);

    // Add the first splitpane to the page
    page.add(splitpane1);
}

qx.core.Init.getInstance().defineMain(
    function()
    {
        // Enable JSON-RPC debugging
        qx.Settings.setCustomOfClass("qx.io.Json", "enableDebug", true);

        if (false)
        {
            // We'd like all table columns to do "live resize". Unfortunately,
            // it's too slow.  Maybe someone wants to work on it...
            var constructor = qx.OO.classes["qx.ui.table.TablePaneScroller"];
            qx.Proto = constructor.prototype;
            qx.OO.changeProperty(
                {
                    name         : "liveResize",
                    type         : qx.constant.Type.BOOLEAN,
                    defaultValue : true
                });
        }

        // Set appearances for this application
        setAppearances();

        // Get the client document
        var clientDocument = qx.ui.core.ClientDocument.getInstance();

        // Create the toolbar and attach it to the client document
        var toolBar = setupMenu(clientDocument);

        // Create the tabs and their windows, and attach to client document
        var tabView = setupTabs(clientDocument);

        // Open a database connection.  Uses the dangerous sync request.
        var rpc = new qx.io.remote.Rpc();
        rpc.setUrl("/services/");
        rpc.setServiceName("samba.ldb");
        rpc.setCrossDomain(false);

        try
        {
            // Database handle
            globals.dbHandle = rpc.callSync("connect", globals.dbFile);
        }
        catch (ex)
        {
            alert("Sync exception: " + ex);
        }
    });
/*
 * Local Variables:
 * mode: c
 * End:
 */
</script>

</body>
</html>

