diff -ur third_party/zlib/adler32.c /tmp/zlib-1.2.3/adler32.c
--- third_party/zlib/adler32.c	2017-02-10 15:46:01.762584808 +1300
+++ /tmp/zlib-1.2.3/adler32.c	2004-12-22 05:52:08.000000000 +1300
@@ -5,7 +5,8 @@

 /* @(#) $Id$ */

-#include "zutil.h"
+#define ZLIB_INTERNAL
+#include "zlib.h"

 #define BASE 65521UL    /* largest prime smaller than 65536 */
 #define NMAX 5552
diff -ur third_party/zlib/compress.c /tmp/zlib-1.2.3/compress.c
--- third_party/zlib/compress.c	2017-02-10 15:46:01.762584808 +1300
+++ /tmp/zlib-1.2.3/compress.c	2003-07-07 17:37:56.000000000 +1200
@@ -5,7 +5,8 @@

 /* @(#) $Id$ */

-#include "zutil.h"
+#define ZLIB_INTERNAL
+#include "zlib.h"

 /* ===========================================================================
      Compresses the source buffer into the destination buffer. The level
@@ -28,7 +29,7 @@
     z_stream stream;
     int err;

-    stream.next_in = source;
+    stream.next_in = (Bytef*)source;
     stream.avail_in = (uInt)sourceLen;
 #ifdef MAXSEG_64K
     /* Check for source > 64K on 16-bit machine: */
Only in /tmp/zlib-1.2.3: configure
diff -ur third_party/zlib/contrib/ada/zlib-streams.ads /tmp/zlib-1.2.3/contrib/ada/zlib-streams.ads
--- third_party/zlib/contrib/ada/zlib-streams.ads	2017-02-10 15:46:01.762584808 +1300
+++ /tmp/zlib-1.2.3/contrib/ada/zlib-streams.ads	2004-10-04 14:55:30.000000000 +1300
@@ -31,7 +31,7 @@
       Mode   : in     Flush_Mode := Sync_Flush);
    --  Flush the written data to the back stream,
    --  all data placed to the compressor is flushing to the Back stream.
-   --  Should not be used untill necessary, because it is decreasing
+   --  Should not be used untill necessary, becouse it is decreasing
    --  compression.

    function Read_Total_In (Stream : in Stream_Type) return Count;
@@ -97,13 +97,13 @@
       Rest_Last  : Stream_Element_Offset;
       --  Buffer for Read operation.
       --  We need to have this buffer in the record
-      --  because not all read data from back stream
+      --  becouse not all read data from back stream
       --  could be processed during the read operation.

       Buffer_Size : Stream_Element_Offset;
       --  Buffer size for write operation.
       --  We do not need to have this buffer
-      --  in the record because all data could be
+      --  in the record becouse all data could be
       --  processed in the write operation.

       Back       : Stream_Access;
diff -ur third_party/zlib/contrib/ada/zlib-thin.ads /tmp/zlib-1.2.3/contrib/ada/zlib-thin.ads
--- third_party/zlib/contrib/ada/zlib-thin.ads	2017-02-10 15:46:01.762584808 +1300
+++ /tmp/zlib-1.2.3/contrib/ada/zlib-thin.ads	2004-07-23 18:33:11.000000000 +1200
@@ -436,7 +436,7 @@

    pragma Import (C, inflateBackInit, "inflateBackInit_");

-   --  I stopped binding the inflateBack routines, because realize that
+   --  I stopped binding the inflateBack routines, becouse realize that
    --  it does not support zlib and gzip headers for now, and have no
    --  symmetric deflateBack routines.
    --  ZLib-Ada is symmetric regarding deflate/inflate data transformation
Only in /tmp/zlib-1.2.3/contrib/masmx64: gvmat64.obj
Only in /tmp/zlib-1.2.3/contrib/masmx64: inffasx64.obj
Only in /tmp/zlib-1.2.3/contrib/masmx86: gvmat32.obj
Only in /tmp/zlib-1.2.3/contrib/masmx86: inffas32.obj
diff -ur third_party/zlib/contrib/minizip/miniunz.c /tmp/zlib-1.2.3/contrib/minizip/miniunz.c
--- third_party/zlib/contrib/minizip/miniunz.c	2017-02-10 15:46:01.766584718 +1300
+++ /tmp/zlib-1.2.3/contrib/minizip/miniunz.c	2005-07-13 06:08:40.000000000 +1200
@@ -536,7 +536,7 @@
 #        endif

         strncpy(filename_try, zipfilename,MAXFILENAME-1);
-        /* strncpy doesn't append the trailing NULL, if the string is too long. */
+        /* strncpy doesnt append the trailing NULL, of the string is too long. */
         filename_try[ MAXFILENAME ] = '\0';

 #        ifdef USEWIN32IOAPI
diff -ur third_party/zlib/contrib/minizip/minizip.c /tmp/zlib-1.2.3/contrib/minizip/minizip.c
--- third_party/zlib/contrib/minizip/minizip.c	2017-02-10 15:46:01.766584718 +1300
+++ /tmp/zlib-1.2.3/contrib/minizip/minizip.c	2005-07-13 06:08:40.000000000 +1200
@@ -77,7 +77,7 @@
       len = MAXFILENAME;

     strncpy(name, f,MAXFILENAME-1);
-    /* strncpy doesn't append the trailing NULL, if the string is too long. */
+    /* strncpy doesnt append the trailing NULL, of the string is too long. */
     name[ MAXFILENAME ] = '\0';

     if (name[len - 1] == '/')
@@ -253,7 +253,7 @@

         zipok = 1 ;
         strncpy(filename_try, argv[zipfilenamearg],MAXFILENAME-1);
-        /* strncpy doesn't append the trailing NULL, if the string is too long. */
+        /* strncpy doesnt append the trailing NULL, of the string is too long. */
         filename_try[ MAXFILENAME ] = '\0';

         len=(int)strlen(filename_try);
diff -ur third_party/zlib/contrib/minizip/unzip.c /tmp/zlib-1.2.3/contrib/minizip/unzip.c
--- third_party/zlib/contrib/minizip/unzip.c	2017-02-10 15:46:01.766584718 +1300
+++ /tmp/zlib-1.2.3/contrib/minizip/unzip.c	2005-07-13 06:08:40.000000000 +1200
@@ -159,7 +159,7 @@
 /* ===========================================================================
      Read a byte from a gz_stream; update next_in and avail_in. Return EOF
    for end of file.
-   IN assertion: the stream s has been successfully opened for reading.
+   IN assertion: the stream s has been sucessfully opened for reading.
 */

@@ -295,10 +295,10 @@

 /*
    Compare two filename (fileName1,fileName2).
-   If iCaseSensitivity = 1, comparison is case sensitive (like strcmp)
-   If iCaseSensitivity = 2, comparison is not case sensitive (like strcmpi
+   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
+   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
                                                                 or strcasecmp)
-   If iCaseSensitivity = 0, case sensitivity is default of your operating system
+   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
         (like 1 on Unix, 2 on Windows)

 */
diff -ur third_party/zlib/contrib/minizip/unzip.h /tmp/zlib-1.2.3/contrib/minizip/unzip.h
--- third_party/zlib/contrib/minizip/unzip.h	2017-02-10 15:46:01.766584718 +1300
+++ /tmp/zlib-1.2.3/contrib/minizip/unzip.h	2005-07-13 06:08:40.000000000 +1200
@@ -124,10 +124,10 @@
                                                  int iCaseSensitivity));
 /*
    Compare two filename (fileName1,fileName2).
-   If iCaseSensitivity = 1, comparison is case sensitive (like strcmp)
-   If iCaseSensitivity = 2, comparison is not case sensitive (like strcmpi
+   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
+   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
                                 or strcasecmp)
-   If iCaseSensitivity = 0, case sensitivity is default of your operating system
+   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
     (like 1 on Unix, 2 on Windows)
 */

diff -ur third_party/zlib/contrib/minizip/zip.c /tmp/zlib-1.2.3/contrib/minizip/zip.c
--- third_party/zlib/contrib/minizip/zip.c	2017-02-10 15:46:01.766584718 +1300
+++ /tmp/zlib-1.2.3/contrib/minizip/zip.c	2005-07-13 06:08:40.000000000 +1200
@@ -99,7 +99,7 @@
   struct linkedlist_datablock_internal_s* next_datablock;
   uLong  avail_in_this_block;
   uLong  filled_in_this_block;
-  uLong  unused; /* for future use and alignment */
+  uLong  unused; /* for future use and alignement */
   unsigned char data[SIZEDATA_INDATABLOCK];
 } linkedlist_datablock_internal;

@@ -117,12 +117,12 @@
     uInt pos_in_buffered_data;  /* last written byte in buffered_data */

     uLong pos_local_header;     /* offset of the local header of the file
-                                     currently writing */
+                                     currenty writing */
     char* central_header;       /* central header data for the current file */
     uLong size_centralheader;   /* size of the central header for cur file */
     uLong flag;                 /* flag of the file currently writing */

-    int  method;                /* compression method of file currently wr.*/
+    int  method;                /* compression method of file currenty wr.*/
     int  raw;                   /* 1 for directly writing raw data */
     Byte buffered_data[Z_BUFSIZE];/* buffer contain compressed data to be writ*/
     uLong dosDate;
diff -ur third_party/zlib/contrib/puff/puff.c /tmp/zlib-1.2.3/contrib/puff/puff.c
--- third_party/zlib/contrib/puff/puff.c	2017-02-10 15:46:01.766584718 +1300
+++ /tmp/zlib-1.2.3/contrib/puff/puff.c	2004-01-09 23:33:12.000000000 +1300
@@ -585,7 +585,7 @@
  *   are themselves compressed using Huffman codes and run-length encoding.  In
  *   the list of code lengths, a 0 symbol means no code, a 1..15 symbol means
  *   that length, and the symbols 16, 17, and 18 are run-length instructions.
- *   Each of 16, 17, and 18 are followed by extra bits to define the length of
+ *   Each of 16, 17, and 18 are follwed by extra bits to define the length of
  *   the run.  16 copies the last length 3 to 6 times.  17 represents 3 to 10
  *   zero lengths, and 18 represents 11 to 138 zero lengths.  Unused symbols
  *   are common, hence the special coding for zero lengths.
diff -ur third_party/zlib/crc32.c /tmp/zlib-1.2.3/crc32.c
--- third_party/zlib/crc32.c	2017-02-10 15:46:01.766584718 +1300
+++ /tmp/zlib-1.2.3/crc32.c	2005-06-13 11:56:07.000000000 +1200
@@ -11,8 +11,6 @@

 /* @(#) $Id$ */

-#include "zutil.h"      /* for STDC and FAR definitions */
-
 /*
   Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
   protection on the static variables used to control the first-use generation
@@ -28,6 +26,8 @@
 #  endif /* !DYNAMIC_CRC_TABLE */
 #endif /* MAKECRCH */

+#include "zutil.h"      /* for STDC and FAR definitions */
+
 #define local static

 /* Find a four-byte integer type for crc32_little() and crc32_big(). */
diff -ur third_party/zlib/deflate.c /tmp/zlib-1.2.3/deflate.c
--- third_party/zlib/deflate.c	2017-02-10 15:46:01.770584631 +1300
+++ /tmp/zlib-1.2.3/deflate.c	2005-07-18 14:27:31.000000000 +1200
@@ -154,6 +154,9 @@
  * meaning.
  */

+#define EQUAL 0
+/* result of memcmp for equal strings */
+
 #ifndef NO_DUMMY_DECL
 struct static_tree_desc_s {int dummy;}; /* for buggy compilers */
 #endif
@@ -294,7 +297,7 @@
     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
         s->pending_buf == Z_NULL) {
         s->status = FINISH_STATE;
-        strm->msg = ERR_MSG(Z_MEM_ERROR);
+        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);
         deflateEnd (strm);
         return Z_MEM_ERROR;
     }
@@ -1223,9 +1226,6 @@
 }

 #ifdef DEBUG
-#define EQUAL 0
-/* result of memcmp for equal strings */
-
 /* ===========================================================================
  * Check that the match at match_start is indeed a match.
  */
diff -ur third_party/zlib/deflate.h /tmp/zlib-1.2.3/deflate.h
--- third_party/zlib/deflate.h	2017-02-10 15:46:01.770584631 +1300
+++ /tmp/zlib-1.2.3/deflate.h	2005-05-30 03:55:22.000000000 +1200
@@ -188,7 +188,7 @@
     int nice_match; /* Stop searching when current match exceeds this */

                 /* used by trees.c: */
-    /* Didn't use ct_data typedef below to suppress compiler warning */
+    /* Didn't use ct_data typedef below to supress compiler warning */
     struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
     struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
     struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
diff -ur third_party/zlib/examples/fitblk.c /tmp/zlib-1.2.3/examples/fitblk.c
--- third_party/zlib/examples/fitblk.c	2017-02-10 15:46:01.770584631 +1300
+++ /tmp/zlib-1.2.3/examples/fitblk.c	2005-06-13 12:31:28.000000000 +1200
@@ -17,7 +17,7 @@
    data in order to determine how much of that input will compress to
    nearly the requested output block size.  The first pass generates
    enough deflate blocks to produce output to fill the requested
-   output size plus a specified excess amount (see the EXCESS define
+   output size plus a specfied excess amount (see the EXCESS define
    below).  The last deflate block may go quite a bit past that, but
    is discarded.  The second pass decompresses and recompresses just
    the compressed data that fit in the requested plus excess sized
diff -ur third_party/zlib/examples/gun.c /tmp/zlib-1.2.3/examples/gun.c
--- third_party/zlib/examples/gun.c	2017-02-10 15:46:01.770584631 +1300
+++ /tmp/zlib-1.2.3/examples/gun.c	2005-06-13 12:15:07.000000000 +1200
@@ -42,7 +42,7 @@
    end-of-file, they cannot be concantenated.  If a Unix compress stream is
    encountered in an input file, it is the last stream in that file.

-   Like gunzip and uncompress, the file attributes of the original compressed
+   Like gunzip and uncompress, the file attributes of the orignal compressed
    file are maintained in the final uncompressed file, to the extent that the
    user permissions allow it.

diff -ur third_party/zlib/gzio.c /tmp/zlib-1.2.3/gzio.c
--- third_party/zlib/gzio.c	2017-02-10 15:46:01.770584631 +1300
+++ /tmp/zlib-1.2.3/gzio.c	2005-07-12 08:31:48.000000000 +1200
@@ -7,6 +7,8 @@

 /* @(#) $Id$ */

+#include <stdio.h>
+
 #include "zutil.h"

 #ifdef NO_DEFLATE       /* for compatibility with old definition */
@@ -44,7 +46,7 @@
 static int const gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */

 /* gzip flag byte */
-/*#define ASCII_FLAG   0x01 *//* bit 0 set: file probably ascii text */
+#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
 #define HEAD_CRC     0x02 /* bit 1 set: header CRC present */
 #define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
 #define ORIG_NAME    0x08 /* bit 3 set: original file name present */
@@ -96,7 +98,7 @@
     int err;
     int level = Z_DEFAULT_COMPRESSION; /* compression level */
     int strategy = Z_DEFAULT_STRATEGY; /* compression strategy */
-    const char *p = mode;
+    char *p = (char*)mode;
     gz_stream *s;
     char fmode[80]; /* copy of mode, without the compression level */
     char *m = fmode;
@@ -254,7 +256,7 @@
 /* ===========================================================================
      Read a byte from a gz_stream; update next_in and avail_in. Return EOF
    for end of file.
-   IN assertion: the stream s has been successfully opened for reading.
+   IN assertion: the stream s has been sucessfully opened for reading.
 */
 local int get_byte(s)
     gz_stream *s;
@@ -279,7 +281,7 @@
     mode to transparent if the gzip magic header is not present; set s->err
     to Z_DATA_ERROR if the magic header is present but the rest of the header
     is incorrect.
-    IN assertion: the stream s has already been created successfully;
+    IN assertion: the stream s has already been created sucessfully;
        s->stream.avail_in is zero for the first time, but may be non-zero
        for concatenated .gz files.
 */
@@ -563,7 +565,7 @@

     if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

-    s->stream.next_in = (const Bytef*)buf;
+    s->stream.next_in = (Bytef*)buf;
     s->stream.avail_in = len;

     while (s->stream.avail_in != 0) {
@@ -692,7 +694,7 @@
     gzFile file;
     const char *s;
 {
-    return gzwrite(file, (voidpc)s, (unsigned)strlen(s));
+    return gzwrite(file, (char*)s, (unsigned)strlen(s));
 }

@@ -986,7 +988,7 @@
     gzFile file;
     int *errnum;
 {
-    const char *m;
+    char *m;
     gz_stream *s = (gz_stream*)file;

     if (s == NULL) {
@@ -996,9 +998,9 @@
     *errnum = s->z_err;
     if (*errnum == Z_OK) return (const char*)"";

-    m = (*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);
+    m = (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);

-    if (m == NULL || *m == '\0') m = ERR_MSG(s->z_err);
+    if (m == NULL || *m == '\0') m = (char*)ERR_MSG(s->z_err);

     TRYFREE(s->msg);
     s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);
diff -ur third_party/zlib/infback.c /tmp/zlib-1.2.3/infback.c
--- third_party/zlib/infback.c	2017-02-10 15:46:01.770584631 +1300
+++ /tmp/zlib-1.2.3/infback.c	2005-05-31 10:58:00.000000000 +1200
@@ -246,7 +246,7 @@
 void FAR *out_desc;
 {
     struct inflate_state FAR *state;
-    unsigned const char FAR *next; /* next input */
+    unsigned char FAR *next;    /* next input */
     unsigned char FAR *put;     /* next output */
     unsigned have, left;        /* available input and output */
     unsigned long hold;         /* bit buffer */
@@ -308,8 +308,8 @@
                 state->mode = TABLE;
                 break;
             case 3:
-                strm->msg = "invalid block type";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid block type";
+                state->mode = BAD;
             }
             DROPBITS(2);
             break;
@@ -319,8 +319,8 @@
             BYTEBITS();                         /* go to byte boundary */
             NEEDBITS(32);
             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
-                strm->msg = "invalid stored block lengths";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid stored block lengths";
+                state->mode = BAD;
                 break;
             }
             state->length = (unsigned)hold & 0xffff;
@@ -357,8 +357,8 @@
             DROPBITS(4);
 #ifndef PKZIP_BUG_WORKAROUND
             if (state->nlen > 286 || state->ndist > 30) {
-                strm->msg = "too many length or distance symbols";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"too many length or distance symbols";
+                state->mode = BAD;
                 break;
             }
 #endif
@@ -379,8 +379,8 @@
             ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                 &(state->lenbits), state->work);
             if (ret) {
-                strm->msg = "invalid code lengths set";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid code lengths set";
+                state->mode = BAD;
                 break;
             }
             Tracev((stderr, "inflate:       code lengths ok\n"));
@@ -403,8 +403,8 @@
                         NEEDBITS(this.bits + 2);
                         DROPBITS(this.bits);
                         if (state->have == 0) {
-                            strm->msg = "invalid bit length repeat";
-                            state->mode = BAD_DATA;
+                            strm->msg = (char *)"invalid bit length repeat";
+                            state->mode = BAD;
                             break;
                         }
                         len = (unsigned)(state->lens[state->have - 1]);
@@ -426,8 +426,8 @@
                         DROPBITS(7);
                     }
                     if (state->have + copy > state->nlen + state->ndist) {
-                        strm->msg = "invalid bit length repeat";
-                        state->mode = BAD_DATA;
+                        strm->msg = (char *)"invalid bit length repeat";
+                        state->mode = BAD;
                         break;
                     }
                     while (copy--)
@@ -436,7 +436,7 @@
             }

             /* handle error breaks in while */
-            if (state->mode == BAD_DATA) break;
+            if (state->mode == BAD) break;

             /* build code tables */
             state->next = state->codes;
@@ -445,8 +445,8 @@
             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
                                 &(state->lenbits), state->work);
             if (ret) {
-                strm->msg = "invalid literal/lengths set";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid literal/lengths set";
+                state->mode = BAD;
                 break;
             }
             state->distcode = (code const FAR *)(state->next);
@@ -454,8 +454,8 @@
             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
                             &(state->next), &(state->distbits), state->work);
             if (ret) {
-                strm->msg = "invalid distances set";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid distances set";
+                state->mode = BAD;
                 break;
             }
             Tracev((stderr, "inflate:       codes ok\n"));
@@ -512,8 +512,8 @@

             /* invalid code */
             if (this.op & 64) {
-                strm->msg = "invalid literal/length code";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid literal/length code";
+                state->mode = BAD;
                 break;
             }

@@ -544,8 +544,8 @@
             }
             DROPBITS(this.bits);
             if (this.op & 64) {
-                strm->msg = "invalid distance code";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid distance code";
+                state->mode = BAD;
                 break;
             }
             state->offset = (unsigned)this.val;
@@ -559,8 +559,8 @@
             }
             if (state->offset > state->wsize - (state->whave < state->wsize ?
                                                 left : 0)) {
-                strm->msg = "invalid distance too far back";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid distance too far back";
+                state->mode = BAD;
                 break;
             }
             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
@@ -595,7 +595,7 @@
             }
             goto inf_leave;

-        case BAD_DATA:
+        case BAD:
             ret = Z_DATA_ERROR;
             goto inf_leave;

diff -ur third_party/zlib/inffast.c /tmp/zlib-1.2.3/inffast.c
--- third_party/zlib/inffast.c	2017-02-10 15:46:01.770584631 +1300
+++ /tmp/zlib-1.2.3/inffast.c	2004-11-13 19:05:29.000000000 +1300
@@ -49,7 +49,7 @@

         LEN -- ran out of enough output space or enough available input
         TYPE -- reached end of block code, inflate() to interpret next block
-        BAD_DATA -- error in block data
+        BAD -- error in block data

    Notes:

@@ -69,8 +69,8 @@
 unsigned start;         /* inflate()'s starting value for strm->avail_out */
 {
     struct inflate_state FAR *state;
-    unsigned const char FAR *in;   /* local strm->next_in */
-    unsigned const char FAR *last; /* while in < last, enough input available */
+    unsigned char FAR *in;      /* local strm->next_in */
+    unsigned char FAR *last;    /* while in < last, enough input available */
     unsigned char FAR *out;     /* local strm->next_out */
     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
     unsigned char FAR *end;     /* while out < end, enough space available */
@@ -176,7 +176,7 @@
 #ifdef INFLATE_STRICT
                 if (dist > dmax) {
                     strm->msg = (char *)"invalid distance too far back";
-                    state->mode = BAD_DATA;
+                    state->mode = BAD;
                     break;
                 }
 #endif
@@ -187,8 +187,8 @@
                 if (dist > op) {                /* see if copy from window */
                     op = dist - op;             /* distance back in window */
                     if (op > whave) {
-                        strm->msg = "invalid distance too far back";
-                        state->mode = BAD_DATA;
+                        strm->msg = (char *)"invalid distance too far back";
+                        state->mode = BAD;
                         break;
                     }
                     from = window - OFF;
@@ -263,8 +263,8 @@
                 goto dodist;
             }
             else {
-                strm->msg = "invalid distance code";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid distance code";
+                state->mode = BAD;
                 break;
             }
         }
@@ -278,8 +278,8 @@
             break;
         }
         else {
-            strm->msg = "invalid literal/length code";
-            state->mode = BAD_DATA;
+            strm->msg = (char *)"invalid literal/length code";
+            state->mode = BAD;
             break;
         }
     } while (in < last && out < end);
diff -ur third_party/zlib/inflate.c /tmp/zlib-1.2.3/inflate.c
--- third_party/zlib/inflate.c	2017-02-10 15:46:01.770584631 +1300
+++ /tmp/zlib-1.2.3/inflate.c	2005-06-15 09:50:12.000000000 +1200
@@ -97,7 +97,7 @@
 #ifdef BUILDFIXED
    void makefixed OF((void));
 #endif
-local unsigned syncsearch OF((unsigned FAR *have, unsigned const char FAR *buf,
+local unsigned syncsearch OF((unsigned FAR *have, unsigned char FAR *buf,
                               unsigned len));

 int ZEXPORT inflateReset(strm)
@@ -556,7 +556,7 @@
 int flush;
 {
     struct inflate_state FAR *state;
-    unsigned const char FAR *next;    /* next input */
+    unsigned char FAR *next;    /* next input */
     unsigned char FAR *put;     /* next output */
     unsigned have, left;        /* available input and output */
     unsigned long hold;         /* bit buffer */
@@ -608,20 +608,20 @@
             if (
 #endif
                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
-                strm->msg = "incorrect header check";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"incorrect header check";
+                state->mode = BAD;
                 break;
             }
             if (BITS(4) != Z_DEFLATED) {
-                strm->msg = "unknown compression method";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"unknown compression method";
+                state->mode = BAD;
                 break;
             }
             DROPBITS(4);
             len = BITS(4) + 8;
             if (len > state->wbits) {
-                strm->msg = "invalid window size";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid window size";
+                state->mode = BAD;
                 break;
             }
             state->dmax = 1U << len;
@@ -635,13 +635,13 @@
             NEEDBITS(16);
             state->flags = (int)(hold);
             if ((state->flags & 0xff) != Z_DEFLATED) {
-                strm->msg = "unknown compression method";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"unknown compression method";
+                state->mode = BAD;
                 break;
             }
             if (state->flags & 0xe000) {
-                strm->msg = "unknown header flags set";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"unknown header flags set";
+                state->mode = BAD;
                 break;
             }
             if (state->head != Z_NULL)
@@ -744,8 +744,8 @@
             if (state->flags & 0x0200) {
                 NEEDBITS(16);
                 if (hold != (state->check & 0xffff)) {
-                    strm->msg = "header crc mismatch";
-                    state->mode = BAD_DATA;
+                    strm->msg = (char *)"header crc mismatch";
+                    state->mode = BAD;
                     break;
                 }
                 INITBITS();
@@ -799,8 +799,8 @@
                 state->mode = TABLE;
                 break;
             case 3:
-                strm->msg = "invalid block type";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid block type";
+                state->mode = BAD;
             }
             DROPBITS(2);
             break;
@@ -808,8 +808,8 @@
             BYTEBITS();                         /* go to byte boundary */
             NEEDBITS(32);
             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
-                strm->msg = "invalid stored block lengths";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid stored block lengths";
+                state->mode = BAD;
                 break;
             }
             state->length = (unsigned)hold & 0xffff;
@@ -844,8 +844,8 @@
             DROPBITS(4);
 #ifndef PKZIP_BUG_WORKAROUND
             if (state->nlen > 286 || state->ndist > 30) {
-                strm->msg = "too many length or distance symbols";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"too many length or distance symbols";
+                state->mode = BAD;
                 break;
             }
 #endif
@@ -866,8 +866,8 @@
             ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                 &(state->lenbits), state->work);
             if (ret) {
-                strm->msg = "invalid code lengths set";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid code lengths set";
+                state->mode = BAD;
                 break;
             }
             Tracev((stderr, "inflate:       code lengths ok\n"));
@@ -890,8 +890,8 @@
                         NEEDBITS(this.bits + 2);
                         DROPBITS(this.bits);
                         if (state->have == 0) {
-                            strm->msg = "invalid bit length repeat";
-                            state->mode = BAD_DATA;
+                            strm->msg = (char *)"invalid bit length repeat";
+                            state->mode = BAD;
                             break;
                         }
                         len = state->lens[state->have - 1];
@@ -913,8 +913,8 @@
                         DROPBITS(7);
                     }
                     if (state->have + copy > state->nlen + state->ndist) {
-                        strm->msg = "invalid bit length repeat";
-                        state->mode = BAD_DATA;
+                        strm->msg = (char *)"invalid bit length repeat";
+                        state->mode = BAD;
                         break;
                     }
                     while (copy--)
@@ -923,7 +923,7 @@
             }

             /* handle error breaks in while */
-            if (state->mode == BAD_DATA) break;
+            if (state->mode == BAD) break;

             /* build code tables */
             state->next = state->codes;
@@ -932,8 +932,8 @@
             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
                                 &(state->lenbits), state->work);
             if (ret) {
-                strm->msg = "invalid literal/lengths set";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid literal/lengths set";
+                state->mode = BAD;
                 break;
             }
             state->distcode = (code const FAR *)(state->next);
@@ -941,8 +941,8 @@
             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
                             &(state->next), &(state->distbits), state->work);
             if (ret) {
-                strm->msg = "invalid distances set";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid distances set";
+                state->mode = BAD;
                 break;
             }
             Tracev((stderr, "inflate:       codes ok\n"));
@@ -984,8 +984,8 @@
                 break;
             }
             if (this.op & 64) {
-                strm->msg = "invalid literal/length code";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid literal/length code";
+                state->mode = BAD;
                 break;
             }
             state->extra = (unsigned)(this.op) & 15;
@@ -1016,8 +1016,8 @@
             }
             DROPBITS(this.bits);
             if (this.op & 64) {
-                strm->msg = "invalid distance code";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid distance code";
+                state->mode = BAD;
                 break;
             }
             state->offset = (unsigned)this.val;
@@ -1031,14 +1031,14 @@
             }
 #ifdef INFLATE_STRICT
             if (state->offset > state->dmax) {
-                strm->msg = "invalid distance too far back";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid distance too far back";
+                state->mode = BAD;
                 break;
             }
 #endif
             if (state->offset > state->whave + out - left) {
-                strm->msg = "invalid distance too far back";
-                state->mode = BAD_DATA;
+                strm->msg = (char *)"invalid distance too far back";
+                state->mode = BAD;
                 break;
             }
             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
@@ -1089,8 +1089,8 @@
                      state->flags ? hold :
 #endif
                      REVERSE(hold)) != state->check) {
-                    strm->msg = "incorrect data check";
-                    state->mode = BAD_DATA;
+                    strm->msg = (char *)"incorrect data check";
+                    state->mode = BAD;
                     break;
                 }
                 INITBITS();
@@ -1102,8 +1102,8 @@
             if (state->wrap && state->flags) {
                 NEEDBITS(32);
                 if (hold != (state->total & 0xffffffffUL)) {
-                    strm->msg = "incorrect length check";
-                    state->mode = BAD_DATA;
+                    strm->msg = (char *)"incorrect length check";
+                    state->mode = BAD;
                     break;
                 }
                 INITBITS();
@@ -1114,7 +1114,7 @@
         case DONE:
             ret = Z_STREAM_END;
             goto inf_leave;
-        case BAD_DATA:
+        case BAD:
             ret = Z_DATA_ERROR;
             goto inf_leave;
         case MEM:
@@ -1238,7 +1238,7 @@
  */
 local unsigned syncsearch(have, buf, len)
 unsigned FAR *have;
-unsigned const char FAR *buf;
+unsigned char FAR *buf;
 unsigned len;
 {
     unsigned got;
diff -ur third_party/zlib/inflate.h /tmp/zlib-1.2.3/inflate.h
--- third_party/zlib/inflate.h	2017-02-10 15:46:01.770584631 +1300
+++ /tmp/zlib-1.2.3/inflate.h	2004-11-13 18:38:28.000000000 +1300
@@ -45,7 +45,7 @@
     CHECK,      /* i: waiting for 32-bit check value */
     LENGTH,     /* i: waiting for 32-bit length (gzip) */
     DONE,       /* finished check, done -- remain here until reset */
-    BAD_DATA,        /* got a data error -- remain here until reset */
+    BAD,        /* got a data error -- remain here until reset */
     MEM,        /* got an inflate() memory error -- remain here until reset */
     SYNC        /* looking for synchronization bytes to restart inflate() */
 } inflate_mode;
@@ -53,7 +53,7 @@
 /*
     State transitions between above modes -

-    (most modes can go to the BAD_DATA or MEM mode -- not shown for clarity)
+    (most modes can go to the BAD or MEM mode -- not shown for clarity)

     Process header:
         HEAD -> (gzip) or (zlib)
diff -ur third_party/zlib/trees.c /tmp/zlib-1.2.3/trees.c
--- third_party/zlib/trees.c	2017-02-10 15:46:01.770584631 +1300
+++ /tmp/zlib-1.2.3/trees.c	2005-06-13 12:34:41.000000000 +1200
@@ -150,8 +150,8 @@
 local int  build_bl_tree  OF((deflate_state *s));
 local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
                               int blcodes));
-local void compress_block OF((deflate_state *s, const ct_data *ltree,
-                              const ct_data *dtree));
+local void compress_block OF((deflate_state *s, ct_data *ltree,
+                              ct_data *dtree));
 local void set_data_type  OF((deflate_state *s));
 local unsigned bi_reverse OF((unsigned value, int length));
 local void bi_windup      OF((deflate_state *s));
@@ -986,7 +986,7 @@
     } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {
 #endif
         send_bits(s, (STATIC_TREES<<1)+eof, 3);
-        compress_block(s, static_ltree, static_dtree);
+        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
 #ifdef DEBUG
         s->compressed_len += 3 + s->static_len;
 #endif
@@ -994,7 +994,7 @@
         send_bits(s, (DYN_TREES<<1)+eof, 3);
         send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
                        max_blindex+1);
-        compress_block(s, s->dyn_ltree, s->dyn_dtree);
+        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
 #ifdef DEBUG
         s->compressed_len += 3 + s->opt_len;
 #endif
@@ -1071,8 +1071,8 @@
  */
 local void compress_block(s, ltree, dtree)
     deflate_state *s;
-    const ct_data *ltree; /* literal tree */
-    const ct_data *dtree; /* distance tree */
+    ct_data *ltree; /* literal tree */
+    ct_data *dtree; /* distance tree */
 {
     unsigned dist;      /* distance of matched string */
     int lc;             /* match length or unmatched char (if dist == 0) */
diff -ur third_party/zlib/uncompr.c /tmp/zlib-1.2.3/uncompr.c
--- third_party/zlib/uncompr.c	2017-02-10 15:46:01.770584631 +1300
+++ /tmp/zlib-1.2.3/uncompr.c	2003-07-07 17:36:56.000000000 +1200
@@ -5,7 +5,8 @@

 /* @(#) $Id$ */

-#include "zutil.h"
+#define ZLIB_INTERNAL
+#include "zlib.h"

 /* ===========================================================================
      Decompresses the source buffer into the destination buffer.  sourceLen is
@@ -31,7 +32,7 @@
     z_stream stream;
     int err;

-    stream.next_in = source;
+    stream.next_in = (Bytef*)source;
     stream.avail_in = (uInt)sourceLen;
     /* Check for source > 64K on 16-bit machine: */
     if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
Only in third_party/zlib/: wscript
diff -ur third_party/zlib/zconf.h /tmp/zlib-1.2.3/zconf.h
--- third_party/zlib/zconf.h	2017-02-10 15:46:01.770584631 +1300
+++ /tmp/zlib-1.2.3/zconf.h	2005-05-28 18:40:35.000000000 +1200
@@ -5,9 +5,6 @@

 /* @(#) $Id$ */

-#include "replace.h"
-#define Z_PREFIX
-
 #ifndef ZCONF_H
 #define ZCONF_H

Only in /tmp/zlib-1.2.3: zlib.3
diff -ur third_party/zlib/zlib.h /tmp/zlib-1.2.3/zlib.h
--- third_party/zlib/zlib.h	2019-08-16 17:41:10.157682822 +1200
+++ /tmp/zlib-1.2.3/zlib.h	2005-07-18 14:26:49.000000000 +1200
@@ -37,14 +37,8 @@
 extern "C" {
 #endif

-#define ZLIB_VERSION "1.2.3.1.Samba"
-#define ZLIB_VERNUM 0x1231
-/*
- * Modified for Samba by Stefan Metzmacher <metze@samba.org> 2008
- *
- * inflateReset2() added and compiler warnings fixed
- */
-
+#define ZLIB_VERSION "1.2.3"
+#define ZLIB_VERNUM 0x1230

 /*
      The 'zlib' compression library provides in-memory compression and
@@ -86,7 +80,7 @@
 struct internal_state;

 typedef struct z_stream_s {
-    const Bytef *next_in; /* next input byte */
+    Bytef    *next_in;  /* next input byte */
     uInt     avail_in;  /* number of bytes available at next_in */
     uLong    total_in;  /* total nb of input bytes read so far */

@@ -94,7 +88,7 @@
     uInt     avail_out; /* remaining free space at next_out */
     uLong    total_out; /* total nb of bytes output so far */

-    const char    *msg; /* last error message, NULL if no error */
+    char     *msg;      /* last error message, NULL if no error */
     struct internal_state FAR *state; /* not visible by applications */

     alloc_func zalloc;  /* used to allocate the internal state */
@@ -213,16 +207,6 @@
 #define zlib_version zlibVersion()
 /* for compatibility with versions < 1.0.2 */

-#ifdef HAVE___ATTRIBUTE__
-/** Use gcc attribute to check printf fns.  a1 is the 1-based index of
- * the parameter containing the format, and a2 the index of the first
- * argument. Note that some gcc 2.x versions don't handle this
- * properly **/
-#define _Z_PRINTF_ATTRIBUTE(a1, a2) __attribute__ ((format (__printf__, a1, a2)))
-#else
-#define _Z_PRINTF_ATTRIBUTE(a1, a2)
-#endif
-
                         /* basic functions */

 ZEXTERN const char * ZEXPORT zlibVersion OF((void));
@@ -885,12 +869,12 @@
      See inflateBack() for the usage of these routines.

      inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
-   the parameters are invalid, Z_MEM_ERROR if the internal state could not
+   the paramaters are invalid, Z_MEM_ERROR if the internal state could not
    be allocated, or Z_VERSION_ERROR if the version of the library does not
    match the version of the header file.
 */

-typedef unsigned (*in_func) OF((void FAR *, unsigned const char FAR * FAR *));
+typedef unsigned (*in_func) OF((void FAR *, unsigned char FAR * FAR *));
 typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));

 ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
@@ -1135,8 +1119,7 @@
    (0 in case of error).
 */

-ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...))
-				    _Z_PRINTF_ATTRIBUTE(2, 3);
+ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
 /*
      Converts, formats, and writes the args to the compressed file under
    control of the format string, as in fprintf. gzprintf returns the number of
diff -ur third_party/zlib/zutil.h /tmp/zlib-1.2.3/zutil.h
--- third_party/zlib/zutil.h	2017-02-10 15:46:01.770584631 +1300
+++ /tmp/zlib-1.2.3/zutil.h	2005-07-12 08:35:48.000000000 +1200
@@ -56,7 +56,7 @@
 #define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]

 #define ERR_RETURN(strm,err) \
-  return (strm->msg = ERR_MSG(err), (err))
+  return (strm->msg = (char*)ERR_MSG(err), (err))
 /* To be used only when the state is known to be valid */

         /* common constants */
