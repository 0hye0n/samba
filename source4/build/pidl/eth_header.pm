###################################################
# create C header files for an IDL structure
# Copyright tridge@samba.org 2000
# Copyright jelmer@samba.org 2005
# released under the GNU GPL

package EthHeader;

use strict;
use typelist;

my($res);
my($tab_depth);

sub pidl ($)
{
	$res .= shift;
}

sub tabs()
{
	for (my($i)=0; $i < $tab_depth; $i++) {
		pidl "\t";
	}
}

#####################################################################
# prototype a typedef
sub HeaderTypedefProto($)
{
    my($d) = shift;

    my $tf = EthParser::get_typefamily($d->{DATA}{TYPE});

    return unless util::has_property($d, "public");

    unless (util::has_property($d, "nopull")) {
		pidl "dcerpc_dissect_fnct_t $d->{NAME};\n";
    }
}

#####################################################################
# parse a const
sub HeaderConst($)
{
    my($const) = shift;
    if (!defined($const->{ARRAY_LEN}[0])) {
    	pidl "#define $const->{NAME}\t( $const->{VALUE} )\n";
    } else {
    	pidl "#define $const->{NAME}\t $const->{VALUE}\n";
    }
}

my %headerstructs = ();

#####################################################################
# parse the interface definitions
sub HeaderInterface($)
{
    my($interface) = shift;

    my $count = 0;

    pidl "#ifndef _HEADER_NDR_$interface->{NAME}\n";
    pidl "#define _HEADER_NDR_$interface->{NAME}\n\n";

    if (defined $interface->{PROPERTIES}->{depends}) {
	    my @d = split / /, $interface->{PROPERTIES}->{depends};
	    foreach my $i (@d) {
		    pidl "#include \"packet-dcerpc-$i\.h\"\n";
	    }
    }

	foreach my $d (@{$interface->{CONSTS}}) {
	    HeaderConst($d);
    }

    foreach my $d (@{$interface->{TYPEDEFS}}) {
	    HeaderTypedefProto($d);
	}

    pidl "#endif /* _HEADER_NDR_$interface->{NAME} */\n";
}

#####################################################################
# parse a parsed IDL into a C header
sub Parse($)
{
    my($idl) = shift;
    $tab_depth = 0;

	$res = "";
    pidl "/* header auto-generated by pidl */\n\n";
    foreach my $x (@{$idl}) {
	    if ($x->{TYPE} eq "INTERFACE") {
		    HeaderInterface($x);
	    }
    }
    return $res;
}

1;
