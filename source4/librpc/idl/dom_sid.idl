/*
   use the same structure for dom_sid2 as dom_sid. A dom_sid2 is really
   just a dom sid, but with the sub_auths represented as a conformant
   array. As with all in-structure conformant arrays, the array length
   is placed before the start of the structure. That's what gives rise
   to the extra num_auths elemenent. We don't want the Samba code to
   have to bother with such esoteric NDR details, so its easier to just
   define it as a dom_sid and use pidl magic to make it all work. It
   just means you need to mark a sid as a "dom_sid2" in the IDL when you
   know it is of the conformant array variety
*/
cpp_quote("#define dom_sid2 dom_sid")

/* same struct as dom_sid but inside a 28 bytes fixed buffer in NDR */
cpp_quote("#define dom_sid28 dom_sid")

/* same struct as dom_sid but in a variable byte buffer, which is maybe empty in NDR */
cpp_quote("#define dom_sid0 dom_sid")

[
	pointer_default(unique)
]
interface dom_sid
{
	/* a domain SID. Note that unlike Samba3 this contains a pointer,
	   so you can't copy them using assignment */
	typedef [public,gensize,noprint,nosize] struct {
		uint8  sid_rev_num;             /**< SID revision number */
		[range(0,15)] int8  num_auths;  /**< Number of sub-authorities */
		uint8  id_auth[6];              /**< Identifier Authority */
		uint32 sub_auths[num_auths];
	} dom_sid;

	/* id used to identify a endpoint, possibly in a cluster */
	typedef [public] struct {
		hyper id;
		uint32 id2;
		uint32 node;
	} server_id;

}

