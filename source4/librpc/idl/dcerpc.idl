#include "idl_types.h"

/*
  the base dcerpc packet definitions - not traditionally coded as IDL,
  but given that pidl can handle it nicely it simplifies things a lot
  to do it this way
*/
[] 
interface dcerpc
{
	typedef struct {
		GUID uuid;
		uint16 major_version;
		uint16 minor_version;
	} dcerpc_syntax_id;

	typedef struct {
		uint16 context_id;
		uint8 num_transfer_syntaxes;
		dcerpc_syntax_id abstract_syntax;
		dcerpc_syntax_id transfer_syntaxes[num_transfer_syntaxes];
	} dcerpc_ctx_list;

	typedef struct {
		uint16 max_xmit_frag;
		uint16 max_recv_frag;
		uint32 assoc_group_id;
		uint8 num_contexts;
		dcerpc_ctx_list ctx_list[num_contexts];
		[flag(NDR_ALIGN8)]    DATA_BLOB _pad;
		[flag(NDR_REMAINING)] DATA_BLOB auth_verifier;
	} dcerpc_bind;

	typedef struct {
		uint32 alloc_hint;
		uint16 context_id;
		uint16 opnum;
		[flag(NDR_ALIGN8)]    DATA_BLOB _pad;
		[flag(NDR_REMAINING)] DATA_BLOB stub_and_verifier;
	} dcerpc_request;

	typedef struct {
		uint16 result;
		uint16 reason;
		dcerpc_syntax_id syntax;
	} dcerpc_ack_ctx;

	typedef struct {
		uint16 max_xmit_frag;
		uint16 max_recv_frag;
		uint32 assoc_group_id;
		ascstr3 secondary_address;
		[flag(NDR_ALIGN4)]    DATA_BLOB _pad1;
		uint8 num_results;
		dcerpc_ack_ctx ctx_list[num_results];
		[flag(NDR_ALIGN8)]    DATA_BLOB _pad2;
		[flag(NDR_REMAINING)] DATA_BLOB auth_verifier;
	} dcerpc_bind_ack;

	typedef struct {
		uint16 reject_reason;
		uint32 num_versions;
		uint32 versions[num_versions];
	} dcerpc_bind_nak;

	typedef struct {
		uint32 alloc_hint;
		uint16 context_id;
		uint8 cancel_count;
		[flag(NDR_ALIGN8)]    DATA_BLOB _pad;
		[flag(NDR_REMAINING)] DATA_BLOB stub_and_verifier;
	} dcerpc_response;

	typedef struct {
		uint32 status;
	} dcerpc_fault;

	typedef enum {
		DCERPC_PKT_REQUEST=0,
		DCERPC_PKT_RESPONSE=2,
		DCERPC_PKT_FAULT=3,
		DCERPC_PKT_BIND=11,
		DCERPC_PKT_BIND_ACK=12,
		DCERPC_PKT_BIND_NAK=13
	} dcerpc_pkt_type;

	typedef [nodiscriminant] union {
		[case(DCERPC_PKT_REQUEST)]  dcerpc_request  request;
		[case(DCERPC_PKT_RESPONSE)] dcerpc_response response;
		[case(DCERPC_PKT_BIND)]     dcerpc_bind     bind;
		[case(DCERPC_PKT_BIND_ACK)] dcerpc_bind_ack bind_ack;
		[case(DCERPC_PKT_FAULT)]    dcerpc_fault    fault;
	} dcerpc_payload;


	/* pfc_flags values */
	const uint8 DCERPC_PFC_FLAG_FIRST  = 0x01;
	const uint8 DCERPC_PFC_FLAG_LAST   = 0x02;
	const uint8 DCERPC_PFC_FLAG_NOCALL = 0x20;

	typedef [public] struct {
		uint8 rpc_vers;		/* RPC version */
		uint8 rpc_vers_minor;	/* Minor version */
		uint8 ptype;		/* Packet type */
		uint8 pfc_flags;	/* Fragmentation flags */
		uint8 drep[4];		/* NDR data representation */
		uint16 frag_length;	/* Total length of fragment */
		uint16 auth_length;	/* authenticator length */
		uint32 call_id;		/* Call identifier */
		
		[switch_is(ptype)] dcerpc_payload u;
	} dcerpc_packet;
}
