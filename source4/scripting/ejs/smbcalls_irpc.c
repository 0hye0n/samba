/* 
   Unix SMB/CIFS implementation.

   provide hooks into IRPC calls from ejs scripts.

   Copyright (C) Andrew Tridgell 2005
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/
/*
  I hope that this code will eventually be autogenerated.


  In this code, the convention is:

    ejs_pull_*()   from MprVar -> C structure
    ejs_push_*()   from C structure -> MprVar

  note that for ejs calls, pull only ever needs to do
  NDR_IN, and push only ever needs to do NDR_OUT. This is
  because ejs code is (at least for the moment) only used for
  the client, not the server

  also note that we don't need the NDR_SCALARS/NDR_BUFFERS stuff, as
  we aren't dealing with wire marshalling where scalars and buffers
  are separated
*/

#include "includes.h"
#include "lib/ejs/ejs.h"
#include "librpc/gen_ndr/ndr_irpc.h"

struct ndr_ejs {
	/* nothing here yet */
	int dummy;
};

struct enum_table {
	uint32_t evalue;
	const char *name;
};

#define EJS_ASSERT(condition) do { \
	if (!(condition)) { \
		DEBUG(0,("ejs assert failed at %s: %s\n", __location__, #condition)); \
		return NT_STATUS_INVALID_PARAMETER; \
	} \
} while (0)


/* first some common helper functions */

static NTSTATUS ejs_pull_enum(struct ndr_ejs *ndr,
			      uint32_t *evalue,
			      struct MprVar *v,
			      const struct enum_table *etable)
{
	const char *s;
	int i;
	EJS_ASSERT(v->type == MPR_TYPE_STRING);
	s = v->string;
	for (i=0;etable[i].name;i++) {
		if (strcmp(s, etable[i].name) == 0) {
			*evalue = etable[i].evalue;
			return NT_STATUS_OK;
		}
	}
	return NT_STATUS_INVALID_PARAMETER;
}

static NTSTATUS ejs_push_enum(struct ndr_ejs *ndr,
			      uint32_t evalue,
			      struct MprVar *v,
			      const struct enum_table *etable)
{
	int i;
	for (i=0;etable[i].name;i++) {
		if (evalue == etable[i].evalue) {
			*v = mprCreateStringVar(etable[i].name, 0);
			return NT_STATUS_OK;
		}
	}
	return NT_STATUS_INVALID_PARAMETER;
}

static NTSTATUS ejs_push_hyper(struct ndr_ejs *ndr,
			       uint64_t evalue,
			       struct MprVar *v,
			       const char *name)
{
}


NTSTATUS ejs_element(struct ndr_ejs *ndr,
		     struct MprVar *v,
		     const char *name,
		     struct MprVar **e)
{
	*e = mprGetProperty(v, name, NULL);
	if (*e == NULL) {
		return NT_STATUS_INVALID_PARAMETER;
	}
	return NT_STATUS_OK;
}


/* when we auto-generate, the enum tables should also be used by
   the ndr_print_*() functions for non-ejs handling of enums
*/
static const struct enum_table enum_table_nbdt_info_level[] = {
	{NBTD_INFO_STATISTICS, "NBTD_INFO_STATISTICS"},
	{-1, NULL}
};



/* pull-side functions for nbtd_information call */

static NTSTATUS ejs_pull_nbtd_info_level(struct ndr_ejs *ndr, 
					 enum nbtd_info_level *r,
					 struct MprVar *v)
{
	uint32_t e;
	NDR_CHECK(ejs_pull_enum(ndr, &e, v, enum_table_nbdt_info_level));
	*r = e;
	return NT_STATUS_OK;
}

static NTSTATUS ejs_pull_nbtd_information(struct ndr_ejs *ndr, 
					  struct nbtd_information *r, 
					  struct MprVar *v)
{
	struct MprVar *e;
	NDR_CHECK(ejs_element(ndr, v, "level", &e));
	NDR_CHECK(ejs_pull_nbtd_info_level(ndr, &r->in.level, e));
	return NT_STATUS_OK;
}


/* push side functions for nbtd_information */

static NTSTATUS ejs_push_nbtd_info_level(struct ndr_ejs *ndr, enum nbtd_info_level r, 
					 struct MprVar *v)
{
	NDR_CHECK(ejs_push_enum(ndr, r, v, enum_table_nbdt_info_level));
	return NT_STATUS_OK;
}

static NTSTATUS ejs_push_nbtd_statistics(struct ndr_ejs *ndr, struct nbtd_statistics *r,
					 struct MprVar *v)
{
	NDR_CHECK(ejs_push_hyper(ndr, r->total_received, v, "total_received"));
	NDR_CHECK(ejs_push_hyper(ndr, r->total_sent, v, "total_sent"));
	NDR_CHECK(ejs_push_hyper(ndr, r->query_count, v, "query_count"));
	NDR_CHECK(ejs_push_hyper(ndr, r->register_count, v, "register_count"));
	NDR_CHECK(ejs_push_hyper(ndr, r->release_count, v, "release_count"));
	NDR_CHECK(ejs_push_hyper(ndr, r->refresh_count, v, "refresh_count"));
	return NT_STATUS_OK;
}

static NTSTATUS ejs_push_nbtd_info(struct ndr_ejs *ndr, union nbtd_info *r, 
				   struct MprVar *v)
{
	int level;
	level = ejs_push_get_switch_value(ndr, r);
	switch (level) {
	case NBTD_INFO_STATISTICS:
		NDR_CHECK(ejs_push_object(ndr, r->stats, 
					  (ejs_push_fn_t)ejs_push_nbtd_statistics, 
					  v, "stats"));
		break;
	default:
		return ejs_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u", level);
	}
	return NT_STATUS_OK;
}

static NTSTATUS ndr_push_nbtd_information(struct ndr_ejs *ndr, 
					  struct nbtd_information *r, struct MprVar *v)
{
	NDR_CHECK(ejs_push_set_switch_value(ndr, &r->out.info, r->in.level));
	NDR_CHECK(ejs_push_object(ndr, &r->out.info, 
				  (ejs_push_fn_t)ejs_push_nbtd_info, v, "info"));
	return NT_STATUS_OK;
}
