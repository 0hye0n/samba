#!/usr/bin/env python
# vim: expandtab
#
# Copyright (C) Matthieu Patou <mat@matws.net> 2009
#
# Based on provision a Samba4 server by
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007-2008
# Copyright (C) Andrew Bartlett <abartlet@samba.org> 2008
#
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


import logging
import optparse
import os
import shutil
import sys
import tempfile
import re
# Allow to run from s4 source directory (without installing samba)
sys.path.insert(0, "bin/python")

import samba
import samba.getopt as options
from samba.credentials import DONT_USE_KERBEROS
from samba.auth import system_session, admin_session
from samba import Ldb, version
from ldb import SCOPE_ONELEVEL, SCOPE_SUBTREE, SCOPE_BASE,\
                FLAG_MOD_REPLACE, FLAG_MOD_ADD, FLAG_MOD_DELETE,\
                MessageElement, Message, Dn
from samba import param
from samba.misc import messageEltFlagToString
from samba.provision import (find_setup_dir, get_domain_descriptor,
    get_config_descriptor, secretsdb_self_join, set_gpo_acl, 
    getpolicypath, create_gpo_struct, ProvisioningError)
from samba.schema import get_linked_attributes, Schema, get_schema_descriptor
from samba.dcerpc import security
from samba.ndr import ndr_unpack
from samba.dcerpc.misc import SEC_CHAN_BDC
from samba.upgradehelpers import dn_sort, get_paths, newprovision,\
                                 find_provision_key_parameters, get_ldbs

replace=2**FLAG_MOD_REPLACE
add=2**FLAG_MOD_ADD
delete=2**FLAG_MOD_DELETE
never=0

LAST_PROVISION_USN_ATTRIBUTE = "lastProvisionUSN"

#Errors are always logged
ERROR =     -1
SIMPLE =     0x00
CHANGE =     0x01
CHANGESD =     0x02
GUESS =     0x04
PROVISION =    0x08
CHANGEALL =    0xff

__docformat__ = "restructuredText"

# Attributes that are never copied from the reference provision (even if they
# do not exist in the destination object).
# This is most probably because they are populated automatcally when object is
# created
# This also apply to imported object from reference provision
hashAttrNotCopied = {     "dn": 1, "whenCreated": 1, "whenChanged": 1, "objectGUID": 1, "replPropertyMetaData": 1, "uSNChanged": 1,
                        "uSNCreated": 1, "parentGUID": 1, "objectCategory": 1, "distinguishedName": 1,
                        "showInAdvancedViewOnly": 1, "instanceType": 1, "cn": 1, "msDS-Behavior-Version":1, "nextRid":1,
                        "nTMixedDomain": 1, "versionNumber":1, "lmPwdHistory":1, "pwdLastSet": 1, "ntPwdHistory":1, "unicodePwd":1,
                        "dBCSPwd":1, "supplementalCredentials":1, "gPCUserExtensionNames":1, "gPCMachineExtensionNames":1,
                        "maxPwdAge":1, "secret":1, "possibleInferiors":1, "privilege":1, "sAMAccountType":1 }

# Usually for an object that already exists we do not overwrite attributes as
# they might have been changed for good reasons. Anyway for a few of them it's
# mandatory to replace them otherwise the provision will be broken somehow.
hashOverwrittenAtt = {    "prefixMap": replace, "systemMayContain": replace, "systemOnly":replace, "searchFlags":replace,
                        "mayContain":replace,  "systemFlags":replace, "description":replace,
                        "operatingSystemVersion":replace, "adminPropertyPages":replace,
                        "defaultSecurityDescriptor": replace, "wellKnownObjects":replace, "privilege":never, "groupType":replace,
                        "rIDAvailablePool": never, "defaultSecurityDescriptor": replace + add}


backlinked = []
dn_syntax_att = []
def define_what_to_log(opts):
    what = 0
    if opts.debugchange:
        what = what | CHANGE
    if opts.debugchangesd:
        what = what | CHANGESD
    if opts.debugguess:
        what = what | GUESS
    if opts.debugprovision:
        what = what | PROVISION
    if opts.debugall:
        what = what | CHANGEALL
    return what


parser = optparse.OptionParser("provision [options]")
sambaopts = options.SambaOptions(parser)
parser.add_option_group(sambaopts)
parser.add_option_group(options.VersionOptions(parser))
credopts = options.CredentialsOptions(parser)
parser.add_option_group(credopts)
parser.add_option("--setupdir", type="string", metavar="DIR",
                    help="directory with setup files")
parser.add_option("--debugprovision", help="Debug provision", action="store_true")
parser.add_option("--debugguess", help="Print information on what is different but won't be changed", action="store_true")
parser.add_option("--debugchange", help="Print information on what is different but won't be changed", action="store_true")
parser.add_option("--debugchangesd", help="Print information security descriptors differences", action="store_true")
parser.add_option("--debugall", help="Print all available information (very verbose)", action="store_true")
parser.add_option("--full", help="Perform full upgrade of the samdb (schema, configuration, new objects, ...", action="store_true")

opts = parser.parse_args()[0]

handler = logging.StreamHandler(sys.stdout)
upgrade_logger = logging.getLogger("upgradeprovision")
upgrade_logger.addHandler(handler)

provision_logger = logging.getLogger("provision")
provision_logger.addHandler(handler)

whatToLog = define_what_to_log(opts)

def message(what, text):
    """Print a message if this message type has been selected to be printed

    :param what: Category of the message
    :param text: Message to print """
    if (whatToLog & what) or what <= 0:
        upgrade_logger.info("%s", text)

if len(sys.argv) == 1:
    opts.interactive = True
lp = sambaopts.get_loadparm()
smbconf = lp.configfile

creds = credopts.get_credentials(lp)
creds.set_kerberos_state(DONT_USE_KERBEROS)
setup_dir = opts.setupdir
if setup_dir is None:
    setup_dir = find_setup_dir()


def identic_rename(ldbobj,dn):
    """Perform a back and forth rename to trigger renaming on attribute that can't be directly modified.

    :param lbdobj: An Ldb Object
    :param dn: DN of the object to manipulate """

    (before, sep, after)=str(dn).partition('=')
    ldbobj.rename(dn, Dn(ldbobj, "%s=foo%s" % (before, after)))
    ldbobj.rename(Dn(ldbobj, "%s=foo%s" % (before, after)), dn)

def check_for_DNS(refprivate, private):
    """Check if the provision has already the requirement for dynamic dns

    :param refprivate: The path to the private directory of the reference
                       provision
    :param private: The path to the private directory of the upgraded
                    provision"""

    spnfile = "%s/spn_update_list" % private
    namedfile = lp.get("dnsupdate:path")

    if not namedfile:
       namedfile = "%s/named.conf.update" % private

    if not os.path.exists(spnfile):
        shutil.copy("%s/spn_update_list" % refprivate, "%s" % spnfile)

    destdir = "%s/new_dns" % private
    dnsdir = "%s/dns" % private

    if not os.path.exists(namedfile):
        if not os.path.exists(destdir):
            os.mkdir(destdir)
        if not os.path.exists(dnsdir):
            os.mkdir(dnsdir)
        shutil.copy("%s/named.conf" % refprivate, "%s/named.conf" % destdir)
        shutil.copy("%s/named.txt" % refprivate, "%s/named.txt" % destdir)
        message(SIMPLE, "It seems that you provision didn't integrate new rules "
                "for dynamic dns update of domain related entries")
        message(SIMPLE, "A copy of the new bind configuration files and "
                "template as been put in %s, you should read them and configure dynamic "
                " dns update" % destdir)


#    dnsupdate:path


def populate_backlink(samdb, schemadn):
    """Populate an array with all the back linked attributes

    This attributes that are modified automaticaly when
    front attibutes are changed

    :param samdb: A LDB object for sam.ldb file
    :param schemadn: DN of the schema for the partition"""
    linkedAttHash = get_linked_attributes(Dn(samdb,str(schemadn)), samdb)
    backlinked.extend(linkedAttHash.values())

def populate_dnsyntax(samdb, schemadn):
    """Populate an array with all the attributes that have DN synthax
       (oid 2.5.5.1)

    :param samdb: A LDB object for sam.ldb file
    :param schemadn: DN of the schema for the partition"""
    res = samdb.search(expression="(attributeSyntax=2.5.5.1)", base=Dn(samdb,
                        str(schemadn)), scope=SCOPE_SUBTREE,
                        attrs=["lDAPDisplayName"])
    for elem in res:
        dn_syntax_att.append(elem["lDAPDisplayName"])


def sanitychecks(samdb, names):
    """Make some checks before trying to update

    :param samdb: An LDB object opened on sam.ldb
    :param names: list of key provision parameters
    :return: Status of check (1 for Ok, 0 for not Ok) """
    res = samdb.search(expression="objectClass=ntdsdsa", base=str(names.configdn),
                         scope=SCOPE_SUBTREE, attrs=["dn"],
                         controls=["search_options:1:2"])
    if len(res) == 0:
        print "No DC found, your provision is most probably hardly broken !"
        return False
    elif len(res) != 1:
        print "Found %d domain controllers, for the moment upgradeprovision" \
              "is not able to handle upgrade on domain with more than one DC, please demote" \
              " the other(s) DC(s) before upgrading" % len(res)
        return False
    else:
        return True


def print_provision_key_parameters(names):
    """Do a a pretty print of provision parameters

    :param names: list of key provision parameters """
    message(GUESS, "rootdn      :" + str(names.rootdn))
    message(GUESS, "configdn    :" + str(names.configdn))
    message(GUESS, "schemadn    :" + str(names.schemadn))
    message(GUESS, "serverdn    :" + str(names.serverdn))
    message(GUESS, "netbiosname :" + names.netbiosname)
    message(GUESS, "defaultsite :" + names.sitename)
    message(GUESS, "dnsdomain   :" + names.dnsdomain)
    message(GUESS, "hostname    :" + names.hostname)
    message(GUESS, "domain      :" + names.domain)
    message(GUESS, "realm       :" + names.realm)
    message(GUESS, "invocationid:" + names.invocation)
    message(GUESS, "policyguid  :" + names.policyid)
    message(GUESS, "policyguiddc:" + str(names.policyid_dc))
    message(GUESS, "domainsid   :" + str(names.domainsid))
    message(GUESS, "domainguid  :" + names.domainguid)
    message(GUESS, "ntdsguid    :" + names.ntdsguid)
    message(GUESS, "domainlevel :" + str(names.domainlevel))


def handle_special_case(att, delta, new, old):
    """Define more complicate update rules for some attributes

    :param att: The attribute to be updated
    :param delta: A messageElement object that correspond to the difference between the updated object and the reference one
    :param new: The reference object
    :param old: The Updated object
    :return: Tru to indicate that the attribute should be kept, False for discarding it
    """
    flag = delta.get(att).flags()
    if (att == "gPLink" or att == "gPCFileSysPath") and \
        flag == FLAG_MOD_REPLACE and str(new[0].dn).lower() == str(old[0].dn).lower():
        delta.remove(att)
        return True
    if att == "forceLogoff":
        ref=0x8000000000000000
        oldval=int(old[0][att][0])
        newval=int(new[0][att][0])
        ref == old and ref == abs(new)
        return True
    if (att == "adminDisplayName" or att == "adminDescription"):
        return True

    if (str(old[0].dn) == "CN=Samba4-Local-Domain,%s" % (str(names.schemadn))\
        and att == "defaultObjectCategory" and flag == FLAG_MOD_REPLACE):
        return True

    if (str(old[0].dn) == "CN=Title,%s"%(str(names.schemadn)) and att == "rangeUpper" and flag == FLAG_MOD_REPLACE):
        return True

    if ((att == "member" or att == "servicePrincipalName") and flag == FLAG_MOD_REPLACE):
        hash = {}
        newval = []
        changeDelta=0
        for elem in old[0][att]:
            hash[str(elem)]=1
            newval.append(str(elem))

        for elem in new[0][att]:
            if not hash.has_key(str(elem)):
                changeDelta=1
                newval.append(str(elem))
        if changeDelta == 1:
            delta[att] = MessageElement(newval, FLAG_MOD_REPLACE, att)
        else:
            delta.remove(att)
        return True

    if (str(old[0].dn) == "%s"%(str(names.rootdn)) and att == "subRefs" and flag == FLAG_MOD_REPLACE):
        return True
    if str(delta.dn).endswith("CN=DisplaySpecifiers,%s"%names.configdn):
        return True
    return False

def update_secrets(newsecrets_ldb, secrets_ldb):
    """Update secrets.ldb

    :param newsecrets_ldb: An LDB object that is connected to the secrets.ldb
                            of the reference provision
    :param secrets_ldb: An LDB object that is connected to the secrets.ldb
                            of the updated provision"""

    message(SIMPLE, "update secrets.ldb")
    reference = newsecrets_ldb.search(expression="dn=@MODULES", base="",
                                        scope=SCOPE_SUBTREE)
    current = secrets_ldb.search(expression="dn=@MODULES", base="",
                                        scope=SCOPE_SUBTREE)
    delta = secrets_ldb.msg_diff(current[0], reference[0])
    delta.dn = current[0].dn
    secrets_ldb.modify(delta)

    reference = newsecrets_ldb.search(expression="objectClass=top", base="",
                                        scope=SCOPE_SUBTREE, attrs=["dn"])
    current = secrets_ldb.search(expression="objectClass=top", base="",
                                        scope=SCOPE_SUBTREE, attrs=["dn"])
    hash_new = {}
    hash = {}
    listMissing = []
    listPresent = []

    empty = Message()
    for i in range(0, len(reference)):
        hash_new[str(reference[i]["dn"]).lower()] = reference[i]["dn"]

    # Create a hash for speeding the search of existing object in the
    # current provision
    for i in range(0, len(current)):
        hash[str(current[i]["dn"]).lower()] = current[i]["dn"]

    for k in hash_new.keys():
        if not hash.has_key(k):
            listMissing.append(hash_new[k])
        else:
            listPresent.append(hash_new[k])

    for entry in listMissing:
        reference = newsecrets_ldb.search(expression="dn=%s"%entry,base="", scope=SCOPE_SUBTREE)
        current = secrets_ldb.search(expression="dn=%s"%entry,base="", scope=SCOPE_SUBTREE)
        delta = secrets_ldb.msg_diff(empty,reference[0])
        for att in hashAttrNotCopied.keys():
            delta.remove(att)
        message(CHANGE, "Entry %s is missing from secrets.ldb"%reference[0].dn)
        for att in delta:
            message(CHANGE, " Adding attribute %s"%att)
        delta.dn = reference[0].dn
        secrets_ldb.add(delta)

    for entry in listPresent:
        reference = newsecrets_ldb.search(expression="dn=%s"%entry,base="", scope=SCOPE_SUBTREE)
        current = secrets_ldb.search(expression="dn=%s"%entry,base="", scope=SCOPE_SUBTREE)
        delta = secrets_ldb.msg_diff(current[0],reference[0])
        for att in hashAttrNotCopied.keys():
            delta.remove(att)
        for att in delta:
            if att == "name":
                message(CHANGE, "Found attribute name on  %s, must rename the DN "%(current[0].dn))
                identic_rename(secrets_ldb,reference[0].dn)
            else:
                delta.remove(att)

    for entry in listPresent:
        reference = newsecrets_ldb.search(expression="dn=%s"%entry,base="", scope=SCOPE_SUBTREE)
        current = secrets_ldb.search(expression="dn=%s"%entry,base="", scope=SCOPE_SUBTREE)
        delta = secrets_ldb.msg_diff(current[0],reference[0])
        for att in hashAttrNotCopied.keys():
            delta.remove(att)
        for att in delta:
            if att != "dn":
                message(CHANGE, " Adding/Changing attribute %s to %s"%(att,current[0].dn))

        delta.dn = current[0].dn
        secrets_ldb.modify(delta)


def dump_denied_change(dn, att, flagtxt, current, reference):
    """Print detailed information about why a changed is denied

    :param dn: DN of the object which attribute is denied
    :param att: Attribute that was supposed to be upgraded
    :param flagtxt: Type of the update that should be performed
                    (add, change, remove, ...)
    :param current: Value(s) of the current attribute
    :param reference: Value(s) of the reference attribute"""

    message(CHANGE, "dn= " + str(dn)+" " + att+" with flag " + flagtxt
                +" is not allowed to be changed/removed, I discard this change")
    if att != "objectSid" :
        i = 0
        for e in range(0, len(current)):
            message(CHANGE, "old %d : %s" % (i, str(current[e])))
            i+=1
        if reference != None:
            i = 0
            for e in range(0, len(reference)):
                message(CHANGE, "new %d : %s" % (i, str(reference[e])))
                i+=1
    else:
        message(CHANGE, "old : %s" % str(ndr_unpack( security.dom_sid, current[0])))
        message(CHANGE, "new : %s" % str(ndr_unpack( security.dom_sid, reference[0])))


def handle_special_add(samdb, dn, names):
    """Handle special operation (like remove) on some object needed during
       upgrade

    This is mostly due to wrong creation of the object in previous provision.
    :param samdb: An Ldb object representing the SAM database
    :param dn: DN of the object to inspect
    :param names: list of key provision parameters"""

    dntoremove = None
    if str(dn).lower() == ("CN=IIS_IUSRS, CN=Builtin, %s" % names.rootdn).lower():
        #This entry was misplaced lets remove it if it exists
        dntoremove = "CN=IIS_IUSRS, CN=Users, %s" % names.rootdn

    objname = "CN=Certificate Service DCOM Access, CN=Builtin, %s" % names.rootdn
    if str(dn).lower() == objname.lower():
        #This entry was misplaced lets remove it if it exists
        dntoremove = "CN=Certificate Service DCOM Access,"\
                     "CN=Users, %s" % names.rootdn

    objname = "CN=Cryptographic Operators, CN=Builtin, %s" % names.rootdn
    if str(dn).lower() == objname.lower():
        #This entry was misplaced lets remove it if it exists
        dntoremove = "CN=Cryptographic Operators, CN=Users, %s" % names.rootdn

    objname = "CN=Event Log Readers, CN=Builtin, %s" % names.rootdn
    if str(dn).lower() == objname.lower():
        #This entry was misplaced lets remove it if it exists
        dntoremove = "CN=Event Log Readers, CN=Users, %s" % names.rootdn

    if dntoremove != None:
        res = samdb.search(expression="(dn=%s)" % dntoremove,
                            base=str(names.rootdn),
                            scope=SCOPE_SUBTREE, attrs=["dn"],
                            controls=["search_options:1:2"])
        if len(res) > 0:
            message(CHANGE, "Existing object %s must be replaced by %s,"\
                            "removing old object" % (dntoremove, str(dn)))
            samdb.delete(res[0]["dn"])


def check_dn_nottobecreated(hash, index, listdn):
    """Check if one of the DN present in the list has a creation order
       greater than the current.

    Hash is indexed by dn to be created, with each key
    is associated the creation order.

    First dn to be created has the creation order 0, second has 1, ...
    Index contain the current creation order

    :param hash: Hash holding the different DN of the object to be created as key
    :param index: Current creation order
    :param listdn: List of DNs on which the current DN depends on
    :return: None if the current object do not depend on other
              object or if all object have been created before."""
    if listdn == None:
        return None
    for dn in listdn:
        key = str(dn).lower()
        if hash.has_key(key) and hash[key] > index:
            return str(dn)
    return None



def add_missing_object(ref_samdb, samdb, dn, names, basedn, hash, index):
    """Add a new object if the dependencies are satisfied

    The function add the object if the object on which it depends are already
    created

    :param ref_samdb: Ldb object representing the SAM db of the reference
                       provision
    :param samdb: Ldb object representing the SAM db of the upgraded
                   provision
    :param dn: DN of the object to be added
    :param names: List of key provision parameters
    :param basedn: DN of the partition to be updated
    :param hash: Hash holding the different DN of the object to be
                  created as key
    :param index: Current creation order
    :return: True if the object was created False otherwise"""

    handle_special_add(samdb, dn, names)
    reference = ref_samdb.search(expression="dn=%s" % (str(dn)), base=basedn,
                    scope=SCOPE_SUBTREE, controls=["search_options:1:2"])
    empty = Message()
    delta = samdb.msg_diff(empty, reference[0])
    delta.dn
    for att in hashAttrNotCopied.keys():
        delta.remove(att)
    for att in backlinked:
        delta.remove(att)
    depend_on_yettobecreated = None
    for att in dn_syntax_att:
        depend_on_yet_tobecreated = check_dn_nottobecreated(hash, index,
                                                            delta.get(str(att)))
        if depend_on_yet_tobecreated != None:
            message(CHANGE, "Object %s depends on %s in attribute %s," \
                            "delaying the creation" % (str(dn), \
                                      depend_on_yet_tobecreated, str(att)))
            return False

    delta.dn = dn
    message(CHANGE,"Object %s will be added" % dn)
    samdb.add(delta, ["relax:0"])
    return True

def gen_dn_index_hash(listMissing):
    """Generate a hash associating the DN to its creation order

    :param listMissing: List of DN
    :return: Hash with DN as keys and creation order as values"""
    hash = {}
    for i in range(0, len(listMissing)):
        hash[str(listMissing[i]).lower()] = i
    return hash

def add_deletedobj_containers(ref_samdb, samdb, names):
    """Add the object containter: CN=Deleted Objects

    This function create the container for each partition that need one and
    then reference the object into the root of the partition

    :param ref_samdb: Ldb object representing the SAM db of the reference
                       provision
    :param samdb: Ldb object representing the SAM db of the upgraded provision
    :param names: List of key provision parameters"""


    wkoPrefix = "B:32:18E2EA80684F11D2B9AA00C04F79F805"
    partitions = [str(names.rootdn), str(names.configdn)]
    for part in partitions:
        ref_delObjCnt = ref_samdb.search(expression="(cn=Deleted Objects)",
                                            base=part, scope=SCOPE_SUBTREE,
                                            attrs=["dn"],
                                            controls=["show_deleted:0"])
        delObjCnt = samdb.search(expression="(cn=Deleted Objects)",
                                    base=part, scope=SCOPE_SUBTREE,
                                    attrs=["dn"],
                                    controls=["show_deleted:0"])
        if len(ref_delObjCnt) > len(delObjCnt):
            reference = ref_samdb.search(expression="cn=Deleted Objects",
                                            base=part, scope=SCOPE_SUBTREE,
                                            controls=["show_deleted:0"])
            empty = Message()
            delta = samdb.msg_diff(empty, reference[0])

            delta.dn = Dn(samdb, str(reference[0]["dn"]))
            for att in hashAttrNotCopied.keys():
                delta.remove(att)
            samdb.add(delta)

            listwko = []
            res = samdb.search(expression="(objectClass=*)", base=part,
                               scope=SCOPE_BASE,
                               attrs=["dn", "wellKnownObjects"])

            targetWKO = "%s:%s" % (wkoPrefix, str(reference[0]["dn"]))
            found = 0

            if len(res[0]) > 0:
                wko = res[0]["wellKnownObjects"]

                # The wellKnownObject that we want to add.
                for o in wko:
                    if str(o) == targetWKO:
                        found = 1
                    listwko.append(str(o))

            if not found:
                listwko.append(targetWKO)

                delta = Message()
                delta.dn = Dn(samdb, str(res[0]["dn"]))
                delta["wellKnownObjects"] = MessageElement(listwko,
                                                FLAG_MOD_REPLACE,
                                                "wellKnownObjects" )
                samdb.modify(delta)

def add_missing_entries(ref_samdb, samdb, names, basedn, list):
    """Add the missing object whose DN is the list

    The function add the object if the objects on which it depends are
    already created.

    :param ref_samdb: Ldb object representing the SAM db of the reference
                      provision
    :param samdb: Ldb object representing the SAM db of the upgraded
                  provision
    :param dn: DN of the object to be added
    :param names: List of key provision parameters
    :param basedn: DN of the partition to be updated
    :param list: List of DN to be added in the upgraded provision"""

    listMissing = []
    listDefered = list

    while(len(listDefered) != len(listMissing) and len(listDefered) > 0):
        index = 0
        listMissing = listDefered
        listDefered = []
        hashMissing = gen_dn_index_hash(listMissing)
        for dn in listMissing:
            ret = add_missing_object(ref_samdb, samdb, dn, names, basedn,
                                        hashMissing, index)
            index = index + 1
            if ret == 0:
                # DN can't be created because it depends on some
                # other DN in the list
                listDefered.append(dn)
    if len(listDefered) != 0:
        raise ProvisioningError("Unable to insert missing elements:" \
                                "circular references")


def update_partition(ref_samdb, samdb, basedn, names, use_ref_schema, highestUSN):
    """Check differences between the reference provision and the upgraded one.

    It looks for all objects which base DN is name. If ischema is "false" then
    the scan is done in cross partition mode.
    If "use_ref_schema" is true, then special handling is done for dealing with schema

    This function will also add the missing object and update existing object to add
    or remove attributes that were missing.
    :param ref_sambdb: An LDB object conntected to the sam.ldb of the reference provision
    :param samdb: An LDB object connected to the sam.ldb of the update provision
    :param basedn: String value of the DN of the partition
    :param names: List of key provision parameters
    :param use_ref_schema: A flag to indicate if we should use the shema of the reference provision
    :param highestUSN:  The highest USN modified by provision/upgradeprovision last time"""

    hash_new = {}
    hash = {}
    listMissing = []
    listPresent = []
    reference = []
    current = []

    # Connect to the reference provision and get all the attribute in the
    # partition referred by name
    reference = ref_samdb.search(expression="objectClass=*",base=basedn, scope=SCOPE_SUBTREE,attrs=["dn"],controls=["search_options:1:2"])
    current = samdb.search(expression="objectClass=*",base=basedn, scope=SCOPE_SUBTREE,attrs=["dn"],controls=["search_options:1:2"])

    # Create a hash for speeding the search of new object
    for i in range(0,len(reference)):
        hash_new[str(reference[i]["dn"]).lower()] = reference[i]["dn"]

    # Create a hash for speeding the search of existing object in the
    # current provision
    for i in range(0,len(current)):
        hash[str(current[i]["dn"]).lower()] = current[i]["dn"]


    for k in hash_new.keys():
        if not hash.has_key(k):
            if not str(hash_new[k]) == "CN=Deleted Objects,%s" % names.rootdn:
                listMissing.append(hash_new[k])
        else:
            listPresent.append(hash_new[k])

    # Sort the missing object in order to have object of the lowest level
    # first (which can be containers for higher level objects)
    listMissing.sort(dn_sort)
    listPresent.sort(dn_sort)

    if use_ref_schema == 1:
        # The following lines (up to the for loop) is to load the up to
        # date schema into our current LDB
        # a complete schema is needed as the insertion of attributes
        # and class is done against it
        # and the schema is self validated
        # The double ldb open and schema validation is taken from the
        # initial provision script
        # it's not certain that it is really needed ....
        schema = Schema(setup_path, names.domainsid, schemadn=basedn, serverdn=str(names.serverdn))
        # Load the schema from the one we computed earlier
        samdb.set_schema_from_ldb(schema.ldb)

    try:
        message(SIMPLE,"There are %d missing objects" % (len(listMissing)))
        add_deletedobj_containers(ref_samdb, samdb, names)

        add_missing_entries(ref_samdb,samdb,names,basedn,listMissing)
        changed = 0

        for dn in listPresent:
            reference = ref_samdb.search(expression="dn=%s" % (str(dn)),base=basedn, scope=SCOPE_SUBTREE,controls=["search_options:1:2"])
            current = samdb.search(expression="dn=%s" % (str(dn)),base=basedn, scope=SCOPE_SUBTREE,controls=["search_options:1:2"])
            if ((str(current[0].dn) != str(reference[0].dn)) and (str(current[0].dn).upper() == str(reference[0].dn).upper())):
                message(CHANGE,"Name are the same but case change, let's rename %s to %s" % (str(current[0].dn),str(reference[0].dn)))
                identic_rename(samdb,reference[0].dn)
                current = samdb.search(expression="dn=%s" % (str(dn)),base=basedn, scope=SCOPE_SUBTREE,controls=["search_options:1:2"])

            delta = samdb.msg_diff(current[0],reference[0])
            for att in hashAttrNotCopied.keys():
                delta.remove(att)
            for att in backlinked:
                delta.remove(att)
            delta.remove("parentGUID")
            nb = 0

            for att in delta:
                msgElt = delta.get(att)
                if att == "dn":
                    continue
                if att == "name":
                    delta.remove(att)
                    continue
                if (not hashOverwrittenAtt.has_key(att) or not (hashOverwrittenAtt.get(att)&2^msgElt.flags())):
                    if  hashOverwrittenAtt.has_key(att) and hashOverwrittenAtt.get(att)==never:
                        delta.remove(att)
                        continue
                    if not handle_special_case(att,delta,reference,current) and msgElt.flags()!=FLAG_MOD_ADD:
                        if opts.debugchange or opts.debugall:
                            try:
                                dump_denied_change(dn,att,messageEltFlagToString(msgElt.flags()),current[0][att],reference[0][att])
                            except KeyError:
                                dump_denied_change(dn,att,messageEltFlagToString(msgElt.flags()),current[0][att],None)
                        delta.remove(att)

            delta.dn = dn
            if len(delta.items()) >1:
                attributes=",".join(delta.keys())
                message(CHANGE,"%s is different from the reference one, changed attributes: %s" % (dn,attributes))
                changed = changed + 1
                samdb.modify(delta)

        message(SIMPLE,"There are %d changed objects" % (changed))
        return 1

    except Exception, err:
        message(ERROR,"Exception during upgrade of samdb: %s" % str(err))
        return 0


def check_updated_sd(ref_sam,cur_sam, names):
    """Check if the security descriptor in the upgraded provision are the same as the reference

    :param ref_sam: A LDB object connected to the sam.ldb file used as the reference provision
    :param cur_sam: A LDB object connected to the sam.ldb file used as upgraded provision
    :param names: List of key provision parameters"""
    reference = ref_sam.search(expression="objectClass=*",base=str(names.rootdn), scope=SCOPE_SUBTREE,attrs=["dn","nTSecurityDescriptor"],controls=["search_options:1:2"])
    current = cur_sam.search(expression="objectClass=*",base=str(names.rootdn), scope=SCOPE_SUBTREE,attrs=["dn","nTSecurityDescriptor"],controls=["search_options:1:2"])
    hash_new = {}
    for i in range(0,len(reference)):
        hash_new[str(reference[i]["dn"]).lower()] = ndr_unpack(security.descriptor,str(reference[i]["nTSecurityDescriptor"])).as_sddl(names.domainsid)

    for i in range(0,len(current)):
        key = str(current[i]["dn"]).lower()
        if hash_new.has_key(key):
            sddl = ndr_unpack(security.descriptor,str(current[i]["nTSecurityDescriptor"])).as_sddl(names.domainsid)
            if sddl != hash_new[key]:
                print "%s \nnew sddl /  sddl in ref" % key
                print "%s\n%s\n" % (sddl,hash_new[key])


def rebuild_sd(samdb, names):
    """Rebuild security descriptor of the current provision from scratch

    During the different pre release of samba4 security descriptors (SD) were notarly broken (up to alpha11 included)
    This function allow to get them back in order, this function make the assumption that nobody has modified manualy an SD
    and so SD can be safely recalculated from scratch to get them right.

    :param names: List of key provision parameters"""

    # First update the SD for the rootdn
    res = samdb.search(expression="objectClass=*", base=str(names.rootdn), scope=SCOPE_BASE,\
                         attrs=["dn", "whenCreated"], controls=["search_options:1:2"])
    delta = Message()
    delta.dn = Dn(samdb,str(res[0]["dn"]))
    descr = get_domain_descriptor(names.domainsid)
    delta["nTSecurityDescriptor"] = MessageElement(descr, FLAG_MOD_REPLACE, "nTSecurityDescriptor")
    samdb.modify(delta,["recalculate_sd:0"])
    # Then the config dn
    res = samdb.search(expression="objectClass=*",base=str(names.configdn), scope=SCOPE_BASE,attrs=["dn","whenCreated"],controls=["search_options:1:2"])
    delta = Message()
    delta.dn = Dn(samdb,str(res[0]["dn"]))
    descr = get_config_descriptor(names.domainsid)
    delta["nTSecurityDescriptor"] = MessageElement(descr, FLAG_MOD_REPLACE, "nTSecurityDescriptor" )
    samdb.modify(delta,["recalculate_sd:0"])
    # Then the schema dn
    res = samdb.search(expression="objectClass=*",base=str(names.schemadn), scope=SCOPE_BASE,attrs=["dn","whenCreated"],controls=["search_options:1:2"])
    delta = Message()
    delta.dn = Dn(samdb,str(res[0]["dn"]))
    descr = get_schema_descriptor(names.domainsid)
    delta["nTSecurityDescriptor"] = MessageElement(descr, FLAG_MOD_REPLACE, "nTSecurityDescriptor" )
    samdb.modify(delta,["recalculate_sd:0"])

    # Then the rest
    hash = {}
    res = samdb.search(expression="objectClass=*",base=str(names.rootdn), scope=SCOPE_SUBTREE,attrs=["dn","whenCreated"],controls=["search_options:1:2"])
    for obj in res:
        if not (str(obj["dn"]) == str(names.rootdn) or
            str(obj["dn"]) == str(names.configdn) or \
            str(obj["dn"]) == str(names.schemadn)):
            hash[str(obj["dn"])] = obj["whenCreated"]

    listkeys = hash.keys()
    listkeys.sort(dn_sort)

    for key in listkeys:
        try:
            delta = Message()
            delta.dn = Dn(samdb,key)
            delta["whenCreated"] = MessageElement(hash[key], FLAG_MOD_REPLACE, "whenCreated" )
            samdb.modify(delta,["recalculate_sd:0"])
        except:
            # XXX: We should always catch an explicit exception.
            # What could go wrong here?
            samdb.transaction_cancel()
            res = samdb.search(expression="objectClass=*", base=str(names.rootdn), scope=SCOPE_SUBTREE,\
                                 attrs=["dn","nTSecurityDescriptor"], controls=["search_options:1:2"])
            print "bad stuff" +ndr_unpack(security.descriptor,str(res[0]["nTSecurityDescriptor"])).as_sddl(names.domainsid)
            return


def getLastProvisionUSN(paths, creds, session, lp):
    """Get the lastest USN modified by a provision or an upgradeprovision

    :param paths: An object holding the different importants paths for upgraded provision object
    :param creds: Credential used for openning LDB files
    :param session: Session to use for openning LDB files
    :param lp: A loadparam object
    :return an integer corresponding to the highest USN modified by (upgrade)provision, 0 is this value is unknown"""

    sam = Ldb(paths.samdb, session_info=session, credentials=creds, lp=lp, options=["modules:"] )
    entry = sam.search(expression="(&(dn=@PROVISION)(%s=*))" % LAST_PROVISION_USN_ATTRIBUTE, scope=SCOPE_SUBTREE,attrs=[LAST_PROVISION_USN_ATTRIBUTE])
    if len(entry):
        message(CHANGE,"Find a last provision USN: %d" % entry[0][LAST_PROVISION_USN_ATTRIBUTE])
        return entry[0][LAST_PROVISION_USN_ATTRIBUTE]
    else:
        return 0




def delta_update_basesamdb(refpaths, paths, creds, session, lp):
    """Update the provision container db: sam.ldb
    This function is aimed for alpha9 and newer;

    :param refpaths: An object holding the different importants paths for reference provision object
    :param paths: An object holding the different importants paths for upgraded provision object
    :param creds: Credential used for openning LDB files
    :param session: Session to use for openning LDB files
    :param lp: A loadparam object"""

    message(SIMPLE,"Update base samdb by searching difference with reference one")
    refsam = Ldb(refpaths.samdb, session_info=session, credentials=creds, lp=lp, options=["modules:"] )
    sam = Ldb(paths.samdb, session_info=session, credentials=creds, lp=lp, options=["modules:"] )

    empty = Message()

    reference = refsam.search(expression="")

    for refentry in reference:
        entry = sam.search(expression="dn=%s" % refentry["dn"],scope=SCOPE_SUBTREE)
        if not len(entry[0]):
            message(CHANGE,"Adding %s to sam db" % str(delta.dn))
            delta = sam.msg_diff(empty,refentry)
            delta.dn = refentry.dn
            sam.add(delta)
        else:
            delta = sam.msg_diff(entry[0],refentry)
            if refentry.dn == "@PARTITION" and delta.get(LAST_PROVISION_USN_ATTRIBUTE):
                delta.remove(LAST_PROVISION_USN_ATTRIBUTE)
            if len(delta.items()) > 1:
                delta.dn = refentry.dn
                sam.modify(delta)


def simple_update_basesamdb(newpaths, paths, names):
    """Update the provision container db: sam.ldb
    This function is aimed at very old provision (before alpha9)

    :param newpaths: List of paths for different provision objects from the reference provision
    :param paths: List of paths for different provision objects from the upgraded provision
    :param names: List of key provision parameters"""

    message(SIMPLE, "Copy samdb")
    shutil.copy(newpaths.samdb,paths.samdb)

    message(SIMPLE, "Update partitions filename if needed")
    schemaldb = os.path.join(paths.private_dir, "schema.ldb")
    configldb = os.path.join(paths.private_dir, "configuration.ldb")
    usersldb = os.path.join(paths.private_dir, "users.ldb")
    samldbdir = os.path.join(paths.private_dir, "sam.ldb.d")

    if not os.path.isdir(samldbdir):
        os.mkdir(samldbdir)
        os.chmod(samldbdir,0700)
    if os.path.isfile(schemaldb):
        shutil.copy(schemaldb, os.path.join(samldbdir, "%s.ldb" % str(names.schemadn).upper()))
        os.remove(schemaldb)
    if os.path.isfile(usersldb):
        shutil.copy(usersldb, os.path.join(samldbdir, "%s.ldb" % str(names.rootdn).upper()))
        os.remove(usersldb)
    if os.path.isfile(configldb):
        shutil.copy(configldb, os.path.join(samldbdir, "%s.ldb" % str(names.configdn).upper()))
        os.remove(configldb)


def update_privilege(ref_private_path, cur_private_path):
    """Update the privilege database

    :param ref_private_path: Path to the private directory of the reference provision.
    :param cur_private_path: Path to the private directory of the current (and to be updated) provision."""
    message(SIMPLE, "Copy privilege")
    shutil.copy(os.path.join(ref_private_path, "privilege.ldb"),
                os.path.join(cur_private_path, "privilege.ldb"))


def update_samdb(ref_samdb, samdb, names, highestUSN):
    """Upgrade the SAM DB contents for all the provision partitions

    :param ref_sambdb: An LDB object conntected to the sam.ldb of the reference provision
    :param samdb: An LDB object connected to the sam.ldb of the update provision
    :param names: List of key provision parameters
    :param highestUSN:  The highest USN modified by provision/upgradeprovision last time"""

    message(SIMPLE, "Starting update of samdb")
    ret = update_partition(ref_samdb, samdb, str(names.rootdn), names, 1, highestUSN)
    if ret:
        message(SIMPLE,"Update of samdb finished")
        return 1
    else:
        message(SIMPLE,"Update failed")
        return 0


def update_machine_account_password(samdb, secrets_ldb, names):
    """Update (change) the password of the current DC both in the SAM db and in secret one

    :param samdb: An LDB object related to the sam.ldb file of a given provision
    :param secrets_ldb: An LDB object related to the secrets.ldb file of a given provision
    :param names: List of key provision parameters"""

    message(SIMPLE,"Update machine account")
    secrets_msg = secrets_ldb.search(expression=("samAccountName=%s$" % names.netbiosname), attrs=["secureChannelType"])
    if int(secrets_msg[0]["secureChannelType"][0]) == SEC_CHAN_BDC:
        res = samdb.search(expression=("samAccountName=%s$" % names.netbiosname), attrs=[])
        assert(len(res) == 1)

        msg = Message(res[0].dn)
        machinepass = samba.generate_random_password(128, 255)
        msg["userPassword"] = MessageElement(machinepass, FLAG_MOD_REPLACE, "userPassword")
        samdb.modify(msg)

        res = samdb.search(expression=("samAccountName=%s$" % names.netbiosname),
                     attrs=["msDs-keyVersionNumber"])
        assert(len(res) == 1)
        kvno = int(str(res[0]["msDs-keyVersionNumber"]))

        secretsdb_self_join(secrets_ldb, domain=names.domain,
                    realm=names.realm or sambaopts._lp.get('realm'),
                    domainsid=names.domainsid,
                    dnsdomain=names.dnsdomain,
                    netbiosname=names.netbiosname,
                    machinepass=machinepass,
                    key_version_number=kvno,
                    secure_channel_type=int(secrets_msg[0]["secureChannelType"][0]))
    else:
        raise ProvisioningError("Unable to find a Secure Channel of type SEC_CHAN_BDC")


def update_gpo(paths,creds,session,names):
    """Create missing GPO file object if needed

    Set ACL correctly also.
    """
    dir = getpolicypath(paths.sysvol,names.dnsdomain,names.policyid)
    if not os.path.isdir(dir):
        create_gpo_struct(dir)

    dir = getpolicypath(paths.sysvol,names.dnsdomain,names.policyid_dc)
    if not os.path.isdir(dir):
        create_gpo_struct(dir)
    samdb = Ldb(paths.samdb, session_info=session, credentials=creds,lp=lp)
    set_gpo_acl(paths.sysvol, names.dnsdomain, names.domainsid,
        names.domaindn, samdb, lp)


def getOEMInfo(samdb, rootdn):
    """Return OEM Information on the top level
    Samba4 use to store version info in this field

    :param samdb: An LDB object connect to sam.ldb
    :param rootdn: Root DN of the domain
    :return: The content of the field oEMInformation (if any)"""
    res = samdb.search(expression="(objectClass=*)", base=str(rootdn),
                            scope=SCOPE_BASE, attrs=["dn", "oEMInformation"])
    if len(res) > 0:
        info = res[0]["oEMInformation"]
        return info
    else:
        return ""



def updateProvisionUSN(samdb, names):
    """Update the field provisionUSN in sam.ldb
    This field is used to track the highest USN of a modified or created object.
    This value is used afterward by next provision to figure out if the field have been
    modified since last provision.

    :param samdb: An LDB object connect to sam.ldb
    :param names: Key provision parameters"""
    message(SIMPLE,"Updating the highest USN modified by upgrade: This is a stub function")



def updateOEMInfo(samdb, names):
    res = samdb.search(expression="(objectClass=*)", base=str(names.rootdn),
                            scope=SCOPE_BASE, attrs=["dn", "oEMInformation"])
    if len(res) > 0:
        info = res[0]["oEMInformation"]
        info = "%s, upgrade to %s" % (info, version)
        delta = Message()
        delta.dn = Dn(samdb, str(res[0]["dn"]))
        delta["oEMInformation"] = MessageElement(info, FLAG_MOD_REPLACE,
            "oEMInformation" )
        samdb.modify(delta)


def setup_path(file):
    return os.path.join(setup_dir, file)


if __name__ == '__main__':
    # From here start the big steps of the program
    # First get files paths
    paths = get_paths(param, smbconf=smbconf)
    paths.setup = setup_dir
    # Get ldbs with the system session, it is needed for searching provision parameters
    session = system_session()

    # This variable will hold the last provision USN once if it exists.
    lastProvisionUSN = getLastProvisionUSN(paths, creds, session, lp)

    ldbs = get_ldbs(paths, creds, session, lp)
    ldbs.startTransactions()

    # Guess all the needed names (variables in fact) from the current
    # provision.
    names = find_provision_key_parameters(ldbs.sam, ldbs.secrets, paths, smbconf, lp)

    # Objects will be created with the admin session (not anymore system session)
    adm_session = admin_session(lp, str(names.domainsid))
    # So we reget handle on objects
    # ldbs = get_ldbs(paths, creds, adm_session, lp)


    if not sanitychecks(ldbs.sam, names):
        message(SIMPLE,"Sanity checks for the upgrade fails, checks messages and correct them before rerunning upgradeprovision")
        sys.exit(1)

    # Let's see provision parameters
    print_provision_key_parameters(names)

    # With all this information let's create a fresh new provision used as reference
    message(SIMPLE, "Creating a reference provision")
    provisiondir = tempfile.mkdtemp(dir=paths.private_dir,
                                    prefix="referenceprovision")
    newprovision(names, setup_dir, creds, session, smbconf, provisiondir,
                    provision_logger)

    # TODO
    # We need to get a list of object which SD is directly computed from
    # defaultSecurityDescriptor.
    # This will allow us to know which object we can rebuild the SD in case
    # of change of the parent's SD or of the defaultSD.
    # Get file paths of this new provision
    newpaths = get_paths(param, targetdir=provisiondir)
    new_ldbs = get_ldbs(newpaths, creds, session, lp)
    new_ldbs.startTransactions()

    # Populate some associative array to ease the update process
    populate_backlink(new_ldbs.sam, names.schemadn) # List of attribute which are backlink
    populate_dnsyntax(new_ldbs.sam, names.schemadn) # List of attribute with ASN DN synthax)

    update_privilege(newpaths.private_dir,paths.private_dir)
    oem = getOEMInfo(ldbs.sam, names.rootdn)
    # Do some modification on sam.ldb
    ldbs.groupedCommit()
    if re.match(".*alpha((9)|(\d\d+)).*",str(oem)):
        # Starting from alpha9 we can consider that the structure is quite ok and that we should do only dela
        new_ldbs.groupedCommit()
        delta_update_basesamdb(newpaths, paths, creds, session, lp)
        ldbs.startTransactions()
        new_ldbs.startTransactions()
    else:
        simple_update_basesamdb(newpaths, paths, names)
        ldbs = get_ldbs(paths, creds, session, lp)
        ldbs.startTransactions()

    if opts.full:
        if not update_samdb(new_ldbs.sam, ldbs.sam, names, lastProvisionUSN):
            message(SIMPLE,"Rollbacking every changes. Check the reason of the problem")
            message(SIMPLE,"In any case your system as it was before the upgrade")
            ldbs.groupedRollback()
            new_ldbs.groupedRollback()
            shutil.rmtree(provisiondir)
            sys.exit(1)

    update_secrets(new_ldbs.secrets,ldbs.secrets)
    update_machine_account_password(ldbs.sam,ldbs.secrets, names)

    # SD should be created with admin but as some previous acl were so wrong that admin can't modify them we have first
    # to recreate them with the good form but with system account and then give the ownership to admin ...
    message(SIMPLE, "Updating SD")
    if not re.match(r'alpha(9|\d\d+)',str(oem)):
        rebuild_sd(ldbs.sam,names)

    # We rebuild SD only when we do not have a lastProvisionUSN because otherwise SD have been already updated if needed
    if lastProvisionUSN == 0:
        ldbs.sam.set_session_info(adm_session)
        rebuild_sd(ldbs.sam, names)
        check_updated_sd(new_ldbs.sam,ldbs.sam, names)

    updateOEMInfo(ldbs.sam,names)
    check_for_DNS(newpaths.private_dir, paths.private_dir)
    updateProvisionUSN(ldbs.sam,names)
    ldbs.groupedCommit()
    new_ldbs.groupedCommit()
    message(SIMPLE, "Upgrade finished !")
    # remove reference provision now that everything is done !
    shutil.rmtree(provisiondir)
